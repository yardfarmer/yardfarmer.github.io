<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 11 页 | output stream</title>
  <meta name="author" content="yakun.cyk">
  
  <meta name="description" content="主要内容可能关于 web 技术，感慨心得...">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="output stream"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	    <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
	  <a class="navbar-brand" href="/">output stream</a>
      <div class="collapse navbar-collapse nav-menu">
		    <ul class="nav navbar-nav">
    		  
    		  <li>
    			 <a href="/demos" title="Demos.">
            <i class="fa fa-flask"></i>Demos
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/archives" title="All the articles.">
            <i class="fa fa-archive"></i>归档
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/about" title="About me.">
            <i class="fa fa-user"></i>关于我
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/#" title="Search Posts.">
            <i class="fa fa-search"></i>搜索
    			 </a>
    		  </li>
    		  
    		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <!--
        <i class="fa fa-heart"></i> 
      -->
      
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-04-21 </div>
			<div class="article-title"><a href="/2014/04/21/2014-04-11-grunt/" >Grunt：任务自动管理工具</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>在Javascript的开发过程中，经常会遇到一些重复性的任务，比如合并文件、压缩代码、检查语法错误、将Sass代码转成CSS代码等等。通常，我们需要使用不同的工具，来完成不同的任务，既重复劳动又非常耗时。Grunt就是为了解决这个问题而发明的工具，可以帮助我们自动管理和运行各种任务。</p>
<p>简单说，Grunt是一个自动任务运行器，会按照预先设定的顺序自动运行一系列的任务。这可以简化工作流程，减轻重复性工作带来的负担。</p>
<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>Grunt基于Node.js，安装之前要先安装Node.js，然后运行下面的命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install grunt-cli -g</div></pre></td></tr></table></figure>
<p>grunt-cli表示安装的是grunt的命令行界面，参数g表示全局安装。</p>
<p>Grunt使用模块结构，除了安装命令行界面以外，还要根据需要安装相应的模块。这些模块应该采用局部安装，因为不同项目可能需要同一个模块的不同版本。</p>
<p>首先，在项目的根目录下，创建一个文本文件package.json，指定当前项目所需的模块。下面就是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"my-project-name"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>,</div><div class="line">  <span class="string">"author"</span>: <span class="string">"Your Name"</span>,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;</div><div class="line">    <span class="string">"grunt"</span>: <span class="string">"0.x.x"</span>,</div><div class="line">    <span class="string">"grunt-contrib-jshint"</span>: <span class="string">"*"</span>,</div><div class="line">    <span class="string">"grunt-contrib-concat"</span>: <span class="string">"~0.1.1"</span>,</div><div class="line">    <span class="string">"grunt-contrib-uglify"</span>: <span class="string">"~0.1.0"</span>,</div><div class="line">    <span class="string">"grunt-contrib-watch"</span>: <span class="string">"~0.1.4"</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面这个package.json文件中，除了注明项目的名称和版本以外，还在devDependencies属性中指定了项目依赖的grunt模块和版本：grunt核心模块为最新的0.x.x版，jshint插件为最新版本，concat插件不低于0.1.1版，uglify插件不低于0.1.0版，watch插件不低于0.1.4版。</p>
<p>然后，在项目的根目录下运行下面的命令，这些插件就会被自动安装在node_modules子目录。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install</div></pre></td></tr></table></figure>
<p>上面这种方法是针对已有package.json的情况。如果想要自动生成package.json文件，可以使用npm init命令，按照屏幕提示回答所需模块的名称和版本即可。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm init</div></pre></td></tr></table></figure>
<p>如果已有的package.json文件不包括Grunt模块，可以在直接安装Grunt模块的时候，加上–save-dev参数，该模块就会自动被加入package.json文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install &lt;module&gt; --save-dev</div></pre></td></tr></table></figure>
<p>比如，对应上面package.json文件指定的模块，需要运行以下npm命令。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install grunt --save-dev</div><div class="line">npm install grunt-contrib-jshint --save-dev</div><div class="line">npm install grunt-contrib-concat --save-dev</div><div class="line">npm install grunt-contrib-uglify --save-dev</div><div class="line">npm install grunt-contrib-watch --save-dev</div></pre></td></tr></table></figure>
<h2 id="命令脚本文件Gruntfile-js"><a href="#命令脚本文件Gruntfile-js" class="headerlink" title="命令脚本文件Gruntfile.js"></a>命令脚本文件Gruntfile.js</h2><p>模块安装完以后，下一步在项目的根目录下，新建脚本文件Gruntfile.js。它是grunt的配置文件，就好像package.json是npm的配置文件一样。Gruntfile.js就是一般的Node.js模块的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">  <span class="comment">// 配置Grunt各种模块的参数</span></div><div class="line">  grunt.initConfig(&#123;</div><div class="line">    <span class="attr">jshint</span>: &#123; <span class="comment">/* jshint的参数 */</span> &#125;,</div><div class="line">    <span class="attr">concat</span>: &#123; <span class="comment">/* concat的参数 */</span> &#125;,</div><div class="line">    <span class="attr">uglify</span>: &#123; <span class="comment">/* uglify的参数 */</span> &#125;,</div><div class="line">    <span class="attr">watch</span>:  &#123; <span class="comment">/* watch的参数 */</span> &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  <span class="comment">// 从node_modules目录加载模块文件</span></div><div class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-jshint'</span>);</div><div class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-concat'</span>);</div><div class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-uglify'</span>);</div><div class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-watch'</span>);</div><div class="line"></div><div class="line">  <span class="comment">// 每行registerTask定义一个任务</span></div><div class="line">  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'jshint'</span>, <span class="string">'concat'</span>, <span class="string">'uglify'</span>]);</div><div class="line">  grunt.registerTask(<span class="string">'check'</span>, [<span class="string">'jshint'</span>]);</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>上面的代码用到了grunt代码的三个方法：</p>
<ul>
<li><p><strong>grunt.initConfig</strong>：定义各种模块的参数，每一个成员项对应一个同名模块。</p>
</li>
<li><p><strong>grunt.loadNpmTasks</strong>：加载完成任务所需的模块。</p>
</li>
<li><p><strong>grunt.registerTask</strong>：定义具体的任务。第一个参数为任务名，第二个参数是一个数组，表示该任务需要依次使用的模块。default任务名表示，如果直接输入grunt命令，后面不跟任何参数，这时所调用的模块（该例为jshint，concat和uglify）；该例的check任务则表示使用jshint插件对代码进行语法检查。</p>
</li>
</ul>
<p>上面的代码一共加载了四个模块：jshint（检查语法错误）、concat（合并文件）、uglify（压缩代码）和watch（自动执行）。接下来，有两种使用方法。</p>
<p>（1）命令行执行某个模块，比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grunt jshint</div></pre></td></tr></table></figure>
<p>上面代码表示运行jshint模块。</p>
<p>（2）命令行执行某个任务。比如</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">grunt check</div></pre></td></tr></table></figure>
<p>上面代码表示运行check任务。如果运行成功，就会显示“Done, without errors.”。</p>
<p>如果没有给出任务名，只键入grunt，就表示执行默认的default任务。</p>
<h2 id="Gruntfile-js实例：grunt-contrib-cssmin模块"><a href="#Gruntfile-js实例：grunt-contrib-cssmin模块" class="headerlink" title="Gruntfile.js实例：grunt-contrib-cssmin模块"></a>Gruntfile.js实例：grunt-contrib-cssmin模块</h2><p>下面通过cssmin模块，演示如何编写Gruntfile.js文件。cssmin模块的作用是最小化CSS文件。</p>
<p>首先，在项目的根目录下安装该模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install grunt-contrib-cssmin --save-dev</div></pre></td></tr></table></figure>
<p>然后，新建文件Gruntfile.js。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">grunt</span>) </span>&#123;</div><div class="line"></div><div class="line">  grunt.initConfig(&#123;</div><div class="line">    <span class="attr">cssmin</span>: &#123;</div><div class="line">      <span class="attr">minify</span>: &#123;</div><div class="line">        <span class="attr">expand</span>: <span class="literal">true</span>,</div><div class="line">		<span class="attr">cwd</span>: <span class="string">'css/'</span>,</div><div class="line">		<span class="attr">src</span>: [<span class="string">'*.css'</span>, <span class="string">'!*.min.css'</span>],</div><div class="line">		<span class="attr">dest</span>: <span class="string">'css/'</span>,</div><div class="line">		<span class="attr">ext</span>: <span class="string">'.min.css'</span></div><div class="line">	  &#125;,</div><div class="line">      <span class="attr">combine</span>: &#123;</div><div class="line">	    <span class="attr">files</span>: &#123;</div><div class="line">		  <span class="string">'css/out.min.css'</span>: [<span class="string">'css/part1.min.css'</span>, <span class="string">'css/part2.min.css'</span>]</div><div class="line">		&#125;</div><div class="line">	  &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;);</div><div class="line"></div><div class="line">  grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>);</div><div class="line"></div><div class="line">  grunt.registerTask(<span class="string">'default'</span>, [<span class="string">'cssmin:minify'</span>,<span class="string">'cssmin:combine'</span>]);</div><div class="line"></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<p>下面详细解释上面代码中的三个方法，下面一个个来看。</p>
<p><strong>（1）grunt.loadNpmTasks</strong></p>
<p>grunt.loadNpmTasks方法载入模块文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grunt.loadNpmTasks(<span class="string">'grunt-contrib-cssmin'</span>);</div></pre></td></tr></table></figure>
<p>你需要使用几个模块，这里就要写几条grunt.loadNpmTasks语句，将各个模块一一加载。</p>
<p>如果加载模块很多，这部分会非常冗长。而且，还存在一个问题，就是凡是在这里加载的模块，也同时出现在package.json文件中。如果使用npm命令卸载模块以后，模块会自动从package.json文件中消失，但是必须手动从Gruntfile.js文件中清除，这样很不方便，一旦忘记，还会出现运行错误。这里有一个解决办法，就是安装load-grunt-tasks模块，然后在Gruntfile.js文件中，用下面的语句替代所有的grunt.loadNpmTasks语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="built_in">require</span>(<span class="string">'load-grunt-tasks'</span>)(grunt);</div></pre></td></tr></table></figure>
<p>这条语句的作用是自动分析package.json文件，自动加载所找到的grunt模块。</p>
<p><strong>（2）grunt.initConfig</strong></p>
<p>grunt.initConfig方法用于模块配置，它接受一个对象作为参数。该对象的成员与使用的同名模块一一对应。由于我们要配置的是cssmin模块，所以里面有一个cssmin成员（属性）。</p>
<p>cssmin（属性）指向一个对象，该对象又包含多个成员。除了一些系统设定的成员（比如options），其他自定义的成员称为目标（target）。一个模块可以有多个目标（target），上面代码里面，cssmin模块共有两个目标，一个是“minify”，用于压缩css文件；另一个是“combine”，用于将多个css文件合并一个文件。</p>
<p>每个目标的具体设置，需要参考该模板的文档。就cssmin来讲，minify目标的参数具体含义如下：</p>
<ul>
<li><p><strong>expand</strong>：如果设为true，就表示下面文件名的占位符（即*号）都要扩展成具体的文件名。</p>
</li>
<li><p><strong>cwd</strong>：需要处理的文件（input）所在的目录。</p>
</li>
<li><p><strong>src</strong>：表示需要处理的文件。如果采用数组形式，数组的每一项就是一个文件名，可以使用通配符。</p>
</li>
<li><p><strong>dest</strong>：表示处理后的文件名或所在目录。</p>
</li>
<li><p><strong>ext</strong>：表示处理后的文件后缀名。</p>
</li>
</ul>
<p>除了上面这些参数，还有一些参数也是grunt所有模块通用的。</p>
<ul>
<li><p><strong>filter</strong>：一个返回布尔值的函数，用于过滤文件名。只有返回值为true的文件，才会被grunt处理。</p>
</li>
<li><p><strong>dot</strong>：是否匹配以点号（.）开头的系统文件。</p>
</li>
<li><p><strong>makeBase</strong>：如果设置为true，就只匹配文件路径的最后一部分。比如，a?b可以匹配/xyz/123/acb，而不匹配/xyz/acb/123。</p>
</li>
</ul>
<p>关于通配符，含义如下：</p>
<ul>
<li>*：匹配任意数量的字符，不包括/。</li>
<li>?：匹配单个字符，不包括/。</li>
<li>**：匹配任意数量的字符，包括/。</li>
<li>{}：允许使用逗号分隔的列表，表示“or”（或）关系。</li>
<li>!：用于模式的开头，表示只返回不匹配的情况。</li>
</ul>
<p>比如，foo/*.js匹配foo目录下面的文件名以.js结尾的文件，foo/**/*.js匹配foo目录和它的所有子目录下面的文件名以.js结尾的文件，!*.css表示匹配所有后缀名不为“.css”的文件。</p>
<p>使用通配符设置src属性的更多例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&#123;<span class="attr">src</span>: <span class="string">'foo/th*.js'</span>&#125;grunt-contrib-uglify</div><div class="line"></div><div class="line">&#123;<span class="attr">src</span>: <span class="string">'foo/&#123;a,b&#125;*.js'</span>&#125;</div><div class="line"></div><div class="line">&#123;<span class="attr">src</span>: [<span class="string">'foo/a*.js'</span>, <span class="string">'foo/b*.js'</span>]&#125;</div></pre></td></tr></table></figure>
<p>至于combine目标，就只有一个files参数，表示输出文件是css子目录下的out.min.css，输入文件则是css子目录下的part1.min.css和part2.min.css。</p>
<p>files参数的格式可以是一个对象，也可以是一个数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">files: &#123;</div><div class="line">        <span class="string">'dest/b.js'</span>: [<span class="string">'src/bb.js'</span>, <span class="string">'src/bbb.js'</span>],</div><div class="line">        <span class="string">'dest/b1.js'</span>: [<span class="string">'src/bb1.js'</span>, <span class="string">'src/bbb1.js'</span>],</div><div class="line">&#125;,</div><div class="line"></div><div class="line"><span class="comment">// or</span></div><div class="line"></div><div class="line">files: [</div><div class="line">        &#123;<span class="attr">src</span>: [<span class="string">'src/aa.js'</span>, <span class="string">'src/aaa.js'</span>], <span class="attr">dest</span>: <span class="string">'dest/a.js'</span>&#125;,</div><div class="line">        &#123;<span class="attr">src</span>: [<span class="string">'src/aa1.js'</span>, <span class="string">'src/aaa1.js'</span>], <span class="attr">dest</span>: <span class="string">'dest/a1.js'</span>&#125;,</div><div class="line">],</div></pre></td></tr></table></figure>
<p>如果minify目标和combine目标的属性设置有重合的部分，可以另行定义一个与minify和combine平行的options属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grunt.initConfig(&#123;</div><div class="line">   <span class="attr">cssmin</span>: &#123;</div><div class="line">  <span class="attr">options</span>: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">     <span class="attr">minify</span>: &#123; <span class="comment">/* ... */</span> &#125;,</div><div class="line">     <span class="attr">combine</span>: &#123; <span class="comment">/* ... */</span> &#125;</div><div class="line">   &#125;</div><div class="line"> &#125;);</div></pre></td></tr></table></figure>
<p><strong>（3）grunt.registerTask</strong></p>
<p>grunt.registerTask方法定义如何调用具体的任务。“default”任务表示如果不提供参数，直接输入grunt命令，则先运行“cssmin:minify”，后运行“cssmin:combine”，即先压缩再合并。如果只执行压缩，或者只执行合并，则需要在grunt命令后面指明“模块名:目标名”。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grunt <span class="comment"># 默认情况下，先压缩后合并</span></div><div class="line"></div><div class="line">grunt cssmin:minify <span class="comment"># 只压缩不合并</span></div><div class="line"></div><div class="line">grunt css:combine <span class="comment"># 只合并不压缩</span></div></pre></td></tr></table></figure>
<p>如果不指明目标，只是指明模块，就表示将所有目标依次运行一遍。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">grunt cssmin</div></pre></td></tr></table></figure>
<h2 id="常用模块设置"><a href="#常用模块设置" class="headerlink" title="常用模块设置"></a>常用模块设置</h2><p>grunt的<a href="http://gruntjs.com/plugins" target="_blank" rel="external">模块</a>已经超过了2000个，且还在快速增加。下面是一些常用的模块（按字母排序）。</p>
<ul>
<li><strong>grunt-contrib-clean</strong>：删除文件。</li>
<li><strong>grunt-contrib-compass</strong>：使用compass编译sass文件。</li>
<li><strong>grunt-contrib-concat</strong>：合并文件。</li>
<li><strong>grunt-contrib-copy</strong>：复制文件。</li>
<li><strong>grunt-contrib-cssmin</strong>：压缩以及合并CSS文件。</li>
<li><strong>grunt-contrib-imagemin</strong>：图像压缩模块。</li>
<li><strong>grunt-contrib-jshint</strong>：检查JavaScript语法。</li>
<li><strong>grunt-contrib-uglify</strong>：压缩以及合并JavaScript文件。</li>
<li><strong>grunt-contrib-watch</strong>：监视文件变动，做出相应动作。</li>
</ul>
<p>模块的前缀如果是grunt-contrib，就表示该模块由grunt开发团队维护；如果前缀是grunt（比如grunt-pakmanager），就表示由第三方开发者维护。</p>
<p>以下选几个模块，看看它们配置参数的写法，也就是说如何在grunt.initConfig方法中配置各个模块。</p>
<h3 id="grunt-contrib-jshint"><a href="#grunt-contrib-jshint" class="headerlink" title="grunt-contrib-jshint"></a>grunt-contrib-jshint</h3><p>jshint用来检查语法错误，比如分号的使用是否正确、有没有忘记写括号等等。它在grunt.initConfig方法里面的配置代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">jshint: &#123;</div><div class="line">	<span class="attr">options</span>: &#123;</div><div class="line">		<span class="attr">eqeqeq</span>: <span class="literal">true</span>,</div><div class="line">		<span class="attr">trailing</span>: <span class="literal">true</span></div><div class="line">	&#125;,</div><div class="line">	<span class="attr">files</span>: [<span class="string">'Gruntfile.js'</span>, <span class="string">'lib/**/*.js'</span>]</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面代码先指定jshint的<a href="http://www.jshint.com/docs/options/" target="_blank" rel="external">检查项目</a>，eqeqeq表示要用严格相等运算符取代相等运算符，trailing表示行尾不得有多余的空格。然后，指定files属性，表示检查目标是Gruntfile.js文件，以及lib目录的所有子目录下面的JavaScript文件。</p>
<h3 id="grunt-contrib-concat"><a href="#grunt-contrib-concat" class="headerlink" title="grunt-contrib-concat"></a>grunt-contrib-concat</h3><p>concat用来合并同类文件，它不仅可以合并JavaScript文件，还可以合并CSS文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">concat: &#123;</div><div class="line">  <span class="attr">js</span>: &#123;</div><div class="line">    <span class="attr">src</span>: [<span class="string">'lib/module1.js'</span>, <span class="string">'lib/module2.js'</span>, <span class="string">'lib/plugin.js'</span>],</div><div class="line">    <span class="attr">dest</span>: <span class="string">'dist/script.js'</span></div><div class="line">  &#125;</div><div class="line">  css: &#123;</div><div class="line">    <span class="attr">src</span>: [<span class="string">'style/normalize.css'</span>, <span class="string">'style/base.css'</span>, <span class="string">'style/theme.css'</span>],</div><div class="line">    <span class="attr">dest</span>: <span class="string">'dist/screen.css'</span></div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>js目标用于合并JavaScript文件，css目标用语合并CSS文件。两者的src属性指定需要合并的文件（input），dest属性指定输出的目标文件（output）。</p>
<h3 id="grunt-contrib-uglify"><a href="#grunt-contrib-uglify" class="headerlink" title="grunt-contrib-uglify"></a>grunt-contrib-uglify</h3><p>uglify模块用来压缩代码，减小文件体积。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">uglify: &#123;</div><div class="line">  <span class="attr">options</span>: &#123;</div><div class="line">    <span class="attr">banner</span>: bannerContent,</div><div class="line">    <span class="attr">sourceMapRoot</span>: <span class="string">'../'</span>,</div><div class="line">    <span class="attr">sourceMap</span>: <span class="string">'distrib/'</span>+name+<span class="string">'.min.js.map'</span>,</div><div class="line">    <span class="attr">sourceMapUrl</span>: name+<span class="string">'.min.js.map'</span></div><div class="line">  &#125;,</div><div class="line">  <span class="attr">target</span> : &#123;</div><div class="line">	<span class="attr">expand</span>: <span class="literal">true</span>,</div><div class="line">	<span class="attr">cwd</span>: <span class="string">'js/origin'</span>,</div><div class="line">	<span class="attr">src</span> : <span class="string">'*.js'</span>,</div><div class="line">	<span class="attr">dest</span> : <span class="string">'js/'</span></div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面代码中的options属性指定压缩后文件的文件头，以及sourceMap设置；target目标指定输入和输出文件。</p>
<h3 id="grunt-contrib-copy"><a href="#grunt-contrib-copy" class="headerlink" title="grunt-contrib-copy"></a>grunt-contrib-copy</h3><p><a href="https://github.com/gruntjs/grunt-contrib-copy" target="_blank" rel="external">copy模块</a>用于复制文件与目录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">copy: &#123;</div><div class="line">  <span class="attr">main</span>: &#123;</div><div class="line">    <span class="attr">src</span>: <span class="string">'src/*'</span>,</div><div class="line">    <span class="attr">dest</span>: <span class="string">'dest/'</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面代码将src子目录（只包含它下面的第一层文件和子目录），拷贝到dest子目录下面（即dest/src目录）。如果要更准确控制拷贝行为，比如只拷贝文件、不拷贝目录、不保持目录结构，可以写成下面这样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">copy: &#123;</div><div class="line">  <span class="attr">main</span>: &#123;</div><div class="line">    <span class="attr">expand</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">cwd</span>: <span class="string">'src/'</span>,</div><div class="line">    <span class="attr">src</span>: <span class="string">'**'</span>,</div><div class="line">    <span class="attr">dest</span>: <span class="string">'dest/'</span>,</div><div class="line">    <span class="attr">flatten</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">filter</span>: <span class="string">'isFile'</span>,</div><div class="line">  &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<h3 id="grunt-contrib-watch"><a href="#grunt-contrib-watch" class="headerlink" title="grunt-contrib-watch"></a>grunt-contrib-watch</h3><p><a href="https://github.com/gruntjs/grunt-contrib-watch" target="_blank" rel="external">watch模块</a>用来在后台运行，监听指定事件，然后自动运行指定的任务。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">watch: &#123;</div><div class="line">   <span class="attr">scripts</span>: &#123;</div><div class="line">    <span class="attr">files</span>: <span class="string">'**/*.js'</span>,</div><div class="line">    <span class="attr">tasks</span>: <span class="string">'jshint'</span>,</div><div class="line">	<span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">livereload</span>: <span class="literal">true</span>,</div><div class="line">    &#125;,</div><div class="line">   &#125;,</div><div class="line">   <span class="attr">css</span>: &#123;</div><div class="line">    <span class="attr">files</span>: <span class="string">'**/*.sass'</span>,</div><div class="line">    <span class="attr">tasks</span>: [<span class="string">'sass'</span>],</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">livereload</span>: <span class="literal">true</span>,</div><div class="line">    &#125;,</div><div class="line">   &#125;,</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>设置好上面的代码，打开另一个进程，运行grunt watch。此后，任何的js代码变动，文件保存后就会自动运行jshint任务；任何sass文件变动，文件保存后就会自动运行sass任务。</p>
<p>需要注意的是，这两个任务的options参数之中，都设置了livereload，表示任务运行结束后，自动在浏览器中重载（reload）。这需要在浏览器中安装<a href="http://livereload.com/" target="_blank" rel="external">livereload插件</a>。安装后，livereload的默认端口为localhost:35729，但是也可以用livereload: 1337的形式重设端口（localhost:1337）。</p>
<h3 id="其他模块"><a href="#其他模块" class="headerlink" title="其他模块"></a>其他模块</h3><p>下面是另外一些有用的模块。</p>
<p><strong>（1）grunt-contrib-clean</strong></p>
<p>该模块用于删除文件或目录。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">clean: &#123;</div><div class="line">  <span class="attr">build</span>: &#123;</div><div class="line">    <span class="attr">src</span>: [<span class="string">"path/to/dir/one"</span>, <span class="string">"path/to/dir/two"</span>]</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><strong>（2）grunt-autoprefixer</strong></p>
<p>该模块用于为CSS语句加上浏览器前缀。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">autoprefixer: &#123;</div><div class="line">  <span class="attr">build</span>: &#123;</div><div class="line">    <span class="attr">expand</span>: <span class="literal">true</span>,</div><div class="line">    <span class="attr">cwd</span>: <span class="string">'build'</span>,</div><div class="line">    <span class="attr">src</span>: [ <span class="string">'**/*.css'</span> ],</div><div class="line">    <span class="attr">dest</span>: <span class="string">'build'</span></div><div class="line">  &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p><strong>（3）grunt-contrib-connect</strong></p>
<p>该模块用于在本机运行一个Web Server。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connect: &#123;</div><div class="line">  <span class="attr">server</span>: &#123;</div><div class="line">    <span class="attr">options</span>: &#123;</div><div class="line">      <span class="attr">port</span>: <span class="number">4000</span>,</div><div class="line">      <span class="attr">base</span>: <span class="string">'build'</span>,</div><div class="line">      <span class="attr">hostname</span>: <span class="string">'*'</span></div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>connect模块会随着grunt运行结束而结束，为了使它一直处于运行状态，可以把它放在watch模块之前运行。因为watch模块需要手动中止，所以connect模块也就会一直运行。</p>
<p><strong>（4）grunt-htmlhint</strong></p>
<p>该模块用于检查HTML语法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">htmlhint: &#123;</div><div class="line">    <span class="attr">build</span>: &#123;</div><div class="line">        <span class="attr">options</span>: &#123;</div><div class="line">            <span class="string">'tag-pair'</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">'tagname-lowercase'</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">'attr-lowercase'</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">'attr-value-double-quotes'</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">'spec-char-escape'</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">'id-unique'</span>: <span class="literal">true</span>,</div><div class="line">            <span class="string">'head-script-disabled'</span>: <span class="literal">true</span>,</div><div class="line">        &#125;,</div><div class="line">        <span class="attr">src</span>: [<span class="string">'index.html'</span>]</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码用于检查index.html文件：HTML标记是否配对、标记名和属性名是否小写、属性值是否包括在双引号之中、特殊字符是否转义、HTML元素的id属性是否为唯一值、head部分是否没有script标记。</p>
<p><strong>（5）grunt-contrib-sass模块</strong></p>
<p>该模块用于将SASS文件转为CSS文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">sass: &#123;</div><div class="line">    <span class="attr">build</span>: &#123;</div><div class="line">		<span class="attr">options</span>: &#123;</div><div class="line">            <span class="attr">style</span>: <span class="string">'compressed'</span></div><div class="line">        &#125;,</div><div class="line">        <span class="attr">files</span>: &#123;</div><div class="line">            <span class="string">'build/css/master.css'</span>: <span class="string">'assets/sass/master.scss'</span></div><div class="line">        &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码指定输出文件为build/css/master.css，输入文件为assets/sass/master.scss。</p>
<p><strong>（6）grunt-markdown</strong></p>
<p>该模块用于将markdown文档转为HTML文档。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">markdown: &#123;</div><div class="line">    <span class="attr">all</span>: &#123;</div><div class="line">      <span class="attr">files</span>: [</div><div class="line">        &#123;</div><div class="line">          <span class="attr">expand</span>: <span class="literal">true</span>,</div><div class="line">          <span class="attr">src</span>: <span class="string">'*.md'</span>,</div><div class="line">          <span class="attr">dest</span>: <span class="string">'docs/html/'</span>,</div><div class="line">          <span class="attr">ext</span>: <span class="string">'.html'</span></div><div class="line">        &#125;</div><div class="line">      ],</div><div class="line">      <span class="attr">options</span>: &#123;</div><div class="line">        <span class="attr">template</span>: <span class="string">'templates/index.html'</span>,</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;,</div></pre></td></tr></table></figure>
<p>上面代码指定将md后缀名的文件，转为docs/html/目录下的html文件。template属性指定转换时采用的模板，模板样式如下。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>Document<span class="tag">&lt;/<span class="name">title</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"> </div><div class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"main"</span> <span class="attr">class</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">%=content%</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"> </div><div class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Frederic Hemberger, <a href="http://frederic-hemberger.de/artikel/grunt-buildtool-for-frontend-projects/" target="_blank" rel="external">A build tool for front-end projects</a></li>
<li>Mária Jurčovičová, <a href="http://flippinawesome.org/2013/07/01/building-a-javascript-library-with-grunt-js/" target="_blank" rel="external">Building a JavaScript Library with Grunt.js</a></li>
<li>Ben Briggs，<a href="http://sixrevisions.com/javascript/grunt-tutorial-01/" target="_blank" rel="external">Speed Up Your Web Development Workflow with Grunt</a></li>
<li><a href="http://blog.grayghostvisuals.com/grunt/image-optimization/" target="_blank" rel="external">Optimizing Images With Grunt</a></li>
<li>Swapnil Mishra, <a href="http://howtonode.org/c4e0f8565942d5e6df45fb78b12d19435543c236/simplifying-chores-with-grunt" target="_blank" rel="external">Simplifying Chores with Grunt</a></li>
<li>AJ ONeal, <a href="http://blog.coolaj86.com/articles/moving-to-grunt.html" target="_blank" rel="external">Moving to GruntJS</a></li>
<li>Grunt Documentation, <a href="http://gruntjs.com/configuring-tasks" target="_blank" rel="external">Configuring tasks</a></li>
<li>Landon Schropp, <a href="http://www.sitepoint.com/writing-awesome-build-script-grunt/" target="_blank" rel="external">Writing an Awesome Build Script with Grunt</a></li>
<li>Mike Cunsolo, <a href="http://coding.smashingmagazine.com/2013/10/29/get-up-running-grunt/" target="_blank" rel="external">Get Up And Running With Grunt</a></li>
<li>Matt Bailey, <a href="http://www.gpmd.co.uk/blog/a-beginners-guide-to-using-grunt-with-magento/" target="_blank" rel="external">A Beginner’s Guide to Using Grunt With Magento</a></li>
<li>Paul Bakaus, <a href="http://www.html5rocks.com/en/tutorials/tooling/supercharging-your-gruntfile/" target="_blank" rel="external">Supercharging your Gruntfile</a></li>
</ul>

	
	</div>
  <a type="button" href="/2014/04/21/2014-04-11-grunt/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-04-10 </div>
			<div class="article-title"><a href="/2014/04/10/2014-04-10-cssInNote/" >细枝末节css</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="选择器解析"><a href="#选择器解析" class="headerlink" title="选择器解析"></a>选择器解析</h3><p>浏览器解析CSS 选择器是从右往左的。这意味着，如果它看到一个如“<code>nav ul li a</code> 的规则时，它首先必须获得所有匹配a 的元素列表，然后检查看 它是不是li 的后代，再按相同规则继续检查。后代选择器虽然看起来方便，但它的性能开销是最大的。</p>
<h2 id="元素的位置"><a href="#元素的位置" class="headerlink" title="元素的位置"></a>元素的位置</h2><p>元素的 x 和 y 坐标可以相对于文档的<code>左上角</code>或者相对于在其中<code>显示文档</code>的 <code>视口</code>的左上角。</p>
<blockquote>
<p>在顶级窗口和标签页中，视口只是实际显示文档内容的一部分； 它不包括浏览器的外壳，拖动浏览器的边框，大小会跟随改变。</p>
</blockquote>
<p>无论在何种情况下，当讨论元素的位置时，必须弄清楚所使用的坐标是文档坐标还是视口坐标。如果文档比视口要小，或者说它还未出现滚动，则文档的左上角就是视口的左上角,文档和视口坐标系统是同一个。</p>
<figure class="highlight fix"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attr">视口坐标+滚动的偏移量 </span>=<span class="string"> 文档的坐标</span></div></pre></td></tr></table></figure>
<p>文档坐标比视口坐标更加基础，并且在用户滚动时它们不会发生变化。</p>
<p>当为鼠标事件注册事件处理程序函数时，报告的鼠标指针的坐标是在<code>视口坐标系</code>中的。</p>
<h4 id="Window-innerHeight"><a href="#Window-innerHeight" class="headerlink" title="Window.innerHeight"></a>Window.innerHeight</h4><p>window.innerHeight 是为了兼容性的考虑，IE9才开始支持。 <strong>用于窗口元素的，不是用于普通元素的</strong></p>
<p>也就是浏览器窗口的视口（viewport）高度（以像素为单位），如果存在水平滚动条，则包括滚动条.  任何窗口对象，如 window、frame、frameset 或 secondary window 都支持 <code>innerHeight</code> 属性。</p>
<p>兼容性：</p>
<pre><code>Chrome       Firefox (Gecko)       Internet Explorer Opera  Safari
    1      1.0 (1.7 or earlier)           9            9       3
</code></pre><p>想获取窗口的外层高度（outer height），即整个浏览器窗口的高度，使用 <code>window.outerHeight</code>。</p>
<h4 id="document-height"><a href="#document-height" class="headerlink" title="document.height"></a>document.height</h4><p>已废弃 用什么替代该属性</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">document<span class="selector-class">.body</span><span class="selector-class">.clientHeight</span></div><div class="line">document<span class="selector-class">.documentElement</span><span class="selector-class">.clientHeight</span></div></pre></td></tr></table></figure>
<h4 id="element-clientHeight"><a href="#element-clientHeight" class="headerlink" title="element.clientHeight"></a>element.clientHeight</h4><p>返回元素内部的高度(单位像数), 包含 padding, 但<code>不包括水平滚动条,border 和 margin</code>.</p>
<p>clientHeight 是只读的.  不是属于W3C规格。 <strong>注意</strong></p>
<p><code>clientHeight</code> 是一个非标准属性, 它从 Internet Explorer 对象模型引入. 它是<code>HTML</code>的特有属性.</p>
<h4 id="Element-scrollHeight"><a href="#Element-scrollHeight" class="headerlink" title="Element.scrollHeight"></a>Element.scrollHeight</h4><p>Element.scrollHeight 是计量元素内容高度的只读属性，包括overflow样式属性导致的视图中不可见内容。<br>没有垂直滚动条的情况下，scrollHeight值与元素视图填充所有内容所需要的最小值clientHeight相同。 包括元素的padding，但不包括元素的margin.  </p>
<h4 id="判定元素是否滚动到底"><a href="#判定元素是否滚动到底" class="headerlink" title="判定元素是否滚动到底"></a>判定元素是否滚动到底</h4><p>如果元素滚动到底，下面等式返回true，没有则返回false.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">element.scrollHeight - element.scrollTop === element.clientHeight   <span class="comment">// element 已滚动到底</span></div></pre></td></tr></table></figure>
<p>浏览器兼容性</p>
<pre><code>Browser           Lowest version
Internet Explorer    8.0
</code></pre><h4 id="Element-getBoundingClientRect"><a href="#Element-getBoundingClientRect" class="headerlink" title="Element.getBoundingClientRect()"></a>Element.getBoundingClientRect()</h4><p>相对于 <code>视口</code>，而不是 <code>文档(dom)</code></p>
<blockquote>
<p>The returned value is a TextRectangle object, which contains read-only </p>
<ul>
<li>left, </li>
<li>top, </li>
<li>right and </li>
<li>bottom<br>properties describing the border-box in pixels. top and left are relative to the top-left of the viewport.</li>
</ul>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rect = obj.getBoundingClientRect();</div></pre></td></tr></table></figure>
<p>Browser compatibility</p>
<pre><code>Desktop 
Feature           Chrome    Firefox (Gecko) Internet Explorer    Opera    Safari
Basic support    1.0        3.0 (1.9)             4.0 [1]        (Yes)     4.0
width/height    (Yes)    3.5 (1.9.1)          9                (Yes)    (Yes)
</code></pre><h4 id="HTMLElement-offsetLeft"><a href="#HTMLElement-offsetLeft" class="headerlink" title="HTMLElement.offsetLeft"></a>HTMLElement.offsetLeft</h4><p>The HTMLElement.offsetLeft read-only method returns the number of pixels that the upper left corner of the current element is offset to the left within the <code>HTMLElement.offsetParent</code> node.</p>
<p>For block-level elements, offsetTop, offsetLeft, offsetWidth, and offsetHeight describe the border box of an element relative to the offsetParent<code>(containing box)</code>.</p>
<p>没有 OffsetRight，offsetBottom</p>
<h4 id="HTMLElement-offsetHeight"><a href="#HTMLElement-offsetHeight" class="headerlink" title="HTMLElement.offsetHeight"></a>HTMLElement.offsetHeight</h4><p>The HTMLElement.offsetHeight read-only property is the height of the element including（包括） vertical padding and borders, in pixels, as an integer.  </p>
<p>Typically, an element’s offsetHeight is a measurement which includes the element borders, the element vertical padding,<br>the element horizontal scrollbar (if present, if rendered) and the element CSS height.  (如果有滚动条，包括滚动条)</p>
<p>许多文章已经介绍了clientHeight和offsetHeight的区别，就是<code>clientHeight</code>的值不包括 scrollbar 的高度，而 <code>offsetHeight</code> 的值包括了scrollbar的高度。</p>
<p>判定一个元素的尺寸和位置最简单的方法是调用它的 <code>getBoundingClientRect()</code> 方法。该方法是在 <code>IE5</code> 中引入的，而现在当前的所有浏览器都实现了。 </p>
<p>在很多浏览器(和W3C标准)中， getBoundingClientRect() 返回的对象还包含width 和 height属性，但是在原始的IE中未实现。为了简便起见，可以这样计算元素的 width 和 height:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">var</span> <span class="built_in">box</span> = e.getBoundingClientRect();</div><div class="line"><span class="built_in">var</span> w = <span class="built_in">box</span>.<span class="built_in">width</span> || (<span class="built_in">box</span>.right - <span class="built_in">box</span>.left);</div><div class="line"><span class="built_in">var</span> h = <span class="built_in">box</span>.<span class="built_in">height</span> || (<span class="built_in">box</span>.bottom - <span class="built_in">box</span>.top);</div></pre></td></tr></table></figure>
<p>除了这些名字以 <code>offset</code> 开头的属性以外，所有的文档元素定义了同时其他两组属性，其名称一组以 <code>client</code> 开头，另一组以 <code>scroll</code> 开头。即，每个HTML元素都有以下这些属性:</p>
<pre><code>offsetWidth offsetHeight offsetLeft offsetTop offsetParent    // = css.height + border*2 + padding，不受滚动条影响 

clientWidth clientHeight clientLeft clientTop \                
                                                 —— &gt; 不滚动时(但可包括滚动条)数值一样; 滚动时，scroll 包括 全部高度，而 client 只含可见高度
scrollWidth scrollHeight scrollLeft scrollTop /
</code></pre><blockquote>
<p>为了理解这些 client 和 scroll 属性，你需要知道HTML元素的实际内容有可能比分配用来容纳内容的盒子更大，因此单个元素可能有海动条.</p>
</blockquote>
<p>内容区域是视口，就像浏览器的窗口，当实际内容比视口更大时，需要把元素的滚动条位置考虑进去。</p>
<p>clientWidth 和 clientHeight 类似 offsetWidth 和 offsetHeight. 不同的是它们不包含<code>边框</code>大小，只包含内容和它的内边距。同时，如果浏览器在内边距和边框之间添加了滚动条. clientWidth 和 clientHeight 在其返回值中也不包含滚动条。</p>
<p><strong> <code>code</code>和<code>span</code>这些内联元素. clientWidth 和 clientHeight 总是返回0。</strong><br>font-size: px<br>字体用像素设定</p>
<p>其他元素与浮动元素相邻，这些元素的外边距不会与浮动元素的外边距合并。即3+2 = 5，而不是3 + 2 = 3。</p>
<p><img src="codesnip_20150110204724.jpg" alt="格式计算图"></p>
<h4 id="图片定位的百分数用法："><a href="#图片定位的百分数用法：" class="headerlink" title="图片定位的百分数用法："></a>图片定位的百分数用法：</h4><p>图片的(99.9%,99%) 这个点与.container(所在容器)的(99.9%，99%)这个点对齐。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">background</span>-<span class="built_in">position</span>: <span class="number">99.9</span>% <span class="number">99</span>%;</div></pre></td></tr></table></figure></p>
<p>这样在使图片紧紧靠右，紧紧靠下就很简单。就使图片的（100%，100%）对准容器的（100%，100%）就可以了。</p>
<h4 id="选择器规则"><a href="#选择器规则" class="headerlink" title="选择器规则"></a>选择器规则</h4><p>浏览器解析 CSS 选择器是从右往左的。这意味着，如果它看到一个如“<code>nav ul li a</code> 的规则时，它首先必须获得所有匹配 a 的元素列表，然后检查看它是不是li 的后代，再按相同规则继续检查。后代选择器虽然看起来方便，但它的性能开销是最大的。</p>
<h2 id="盒"><a href="#盒" class="headerlink" title="盒"></a>盒</h2><p>这里的盒是个多元的概念,其中相关的有：</p>
<ul>
<li>block level boxes </li>
<li>containing block</li>
<li>block formatting context(BFC)</li>
</ul>
<p>想想浏览器怎么把一个元素”画”出来，至少要知道定位和尺寸。<strong>定位有三种 normal flow, floats 和 absolute</strong>，无论属于哪种首先要找所在的containing block(翻译为包含块)，相当于一个大箱子里摆很多小盒子，小盒子怎么摆取决于大箱子。</p>
<p>怎么确定一个元素的containing block，由position属性确定：</p>
<ol>
<li>static(默认的)/relative：简单说就是它的父元素的内容框（即去掉padding的部分）</li>
<li>absolute: 向上找最近的定位为absolute/relative的元素</li>
<li>fixed: 它的containing block一律为根元素(html/body)，根元素也是initial containing block</li>
</ol>
<p><code>block formatting context(块级格式化上下文)</code>是一种<strong>布局特性</strong>，还是往箱子里放东西，bfc可以理解为打了<strong>隔板</strong>把一组小盒子分离开。</p>
<p><code>block-level box</code>一定会产生’block formatting context’是错误的，block-level box须通过设置如overflow不为visible(IE6/7无效，可以设zoom)、float不为none等等来创建block formatting context。</p>
<p>触发了bfc的block level box，没有<strong>margin callapse</strong>的问题，并且边缘不会和<code>float</code>的box的边缘重叠，利用它可以清浮动。</p>
<blockquote>
<p>页面上任何一个元素都可以看成 box ,可分为 </p>
<ul>
<li>block-level(块级)，如  ‘block’, ‘list-item’, and ‘table’.</li>
<li>inline-level(行内)<br>和匿名的。</li>
</ul>
</blockquote>
<h3 id="关于行内框和行框的概念"><a href="#关于行内框和行框的概念" class="headerlink" title="关于行内框和行框的概念"></a>关于行内框和行框的概念</h3><p>文本行中的每个元素都会生成一个内容区。这个内容区则会生成一个行内框（inline box），当一行中的所有内容均已生成了行内框，那么接下来在行框的构造中就会考虑这些行内框，行框要包含住最高行内框的顶端和最低行内框的底端。</p>
<h2 id="元素居中"><a href="#元素居中" class="headerlink" title="元素居中"></a>元素居中</h2><p>元素居中分为固定宽度和非固定宽度</p>
<p>对于固定宽度:<br>    设定居中元素 margin: xxpx auto; // 同理适用于垂直居中</p>
<p>对于非固定宽度元素:<br>    在父元素上设定 text-align: center;<br>    在目标元素上设定  display: inline-block;</p>
<h2 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h2><p>也就是将元素从普通的布局排版中拿走，其他盒子在定位的时候，会当做脱离文档流的元素不存在而进行定位。需要注意的是，使用float脱离文档流时，其他盒子会无视这个元素，但其他盒子内的文本依然会为这个元素让出位置，环绕在周围。而对于使用absolute positioning脱离文档流的元素，其他盒子与其他盒子内的文本都会无视它。</p>

	
	</div>
  <a type="button" href="/2014/04/10/2014-04-10-cssInNote/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-04-02 </div>
			<div class="article-title"><a href="/2014/04/02/2014-04-02-如何在Array.forEach的循环里break/" >如何在Array.forEach的循环里break</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>前段时间团队里讨论了一个问题，如何在forEach里实现<code>break</code>，目前有几种方案</p>
<h2 id="throw法"><a href="#throw法" class="headerlink" title="throw法"></a>throw法</h2><p>抛出一个错误，但是需要注意的是要抛出一个可以与别的错误区别开的错误，这样不会干扰别的代码抛出的错误</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> BreakException = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="keyword">try</span> &#123;</div><div class="line">    [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(v); <span class="comment">//只输出1,2</span></div><div class="line">        <span class="keyword">if</span> (v === <span class="number">2</span>) <span class="keyword">throw</span> BreakException;</div><div class="line">    &#125;);</div><div class="line">&#125; <span class="keyword">catch</span> (e) &#123;</div><div class="line">    <span class="keyword">if</span> (e !== BreakException) <span class="keyword">throw</span> e;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>此法有点丑陋，加了不少代码</p>
<h2 id="空跑循环"><a href="#空跑循环" class="headerlink" title="空跑循环"></a>空跑循环</h2><p>在外层加一个标识，如果此标识为true，接下来的循环空跑，码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> breakFlag = <span class="literal">false</span>;</div><div class="line"></div><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (breakFlag === <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (v === <span class="number">2</span>) &#123;</div><div class="line">        breakFlag = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="built_in">console</span>.log(v) <span class="comment">//只输出1,2</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>这个在外层加了一个变量，为了不污染外层的环境，我们可以使用forEach的第二个参数context，把标识放在这里</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.breakFlag === <span class="literal">true</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</div><div class="line">    &#125;</div><div class="line"></div><div class="line">    <span class="keyword">if</span> (v === <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">this</span>.breakFlag = <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(v) <span class="comment">//只输出1,2</span></div><div class="line">&#125;, &#123;&#125;);</div></pre></td></tr></table></figure>
<p>这种方法不可避免的导致了不必要的运行,有点浪费cpu的感觉</p>
<h2 id="神奇改数组大法"><a href="#神奇改数组大法" class="headerlink" title="神奇改数组大法"></a>神奇改数组大法</h2><p>下面出场的这位选手，稍微有点技术含量</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> array = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</div><div class="line">array.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">item, index</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</div><div class="line">        array = array.concat(array.splice(index, array.length - index));</div><div class="line">    &#125;</div><div class="line">    <span class="built_in">console</span>.log(item); <span class="comment">//只输出1,2</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>这种方法相当于改变了array，不知道大伙看出来了没有</p>
<h2 id="最应该使用的every"><a href="#最应该使用的every" class="headerlink" title="最应该使用的every"></a>最应该使用的every</h2><p>前面啰嗦了这么多，真正的主角登场，最推荐的方式呢，就是这种需要<code>break</code>的场景下，直接使用<code>every</code>或者<code>some</code>吧</p>
<ul>
<li>every: 碰到<code>return false</code>的时候，循环中止</li>
<li>some: 碰到<code>return ture</code>的时候，循环中止</li>
</ul>
<p>两者的代码分别如下</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">a.every(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arry</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(item); <span class="comment">//返回1,2</span></div><div class="line">    <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</div><div class="line">a.some(<span class="function"><span class="keyword">function</span>(<span class="params">item, index, arry</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(item); <span class="comment">//返回1,2</span></div><div class="line">    <span class="keyword">if</span> (item === <span class="number">2</span>) &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">true</span></div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> <span class="literal">false</span></div><div class="line">    &#125;</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>当然如果你能使用forEach，却发现<code>every</code>没有，那么你可能需要<a href="https://github.com/es-shims/es5-shim" target="_blank" rel="external">es5-shim</a>，<code>forEach</code>、<code>every</code>、<code>some</code>都是属于<code>es5</code>规范下的，<a href="http://kangax.github.io/es5-compat-table/" target="_blank" rel="external">这里有一个兼容列表</a></p>
<h2 id="骚年用for吧"><a href="#骚年用for吧" class="headerlink" title="骚年用for吧"></a>骚年用for吧</h2><p>群里讨论的时候</p>
<ul>
<li><a href="http://jser.net" target="_blank" rel="external">冰姐</a>: 如果forEach 都用到break了，那肯定是比较复杂的场景，那干脆写个for就行了</li>
<li><a href="http://weibo.com/dotnil" target="_blank" rel="external">逸才</a>: 是啊</li>
</ul>
<p>目睹了这些的我也觉得有些认同。</p>
<h2 id="部分参考"><a href="#部分参考" class="headerlink" title="部分参考"></a>部分参考</h2><ul>
<li><a href="http://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break" target="_blank" rel="external">http://stackoverflow.com/questions/2641347/how-to-short-circuit-array-foreach-like-calling-break</a></li>
<li><a href="http://old.doctyper.com/archives/200807/breaking-out-of-a-foreach-loop/" target="_blank" rel="external">http://old.doctyper.com/archives/200807/breaking-out-of-a-foreach-loop/</a></li>
<li><a href="https://coderwall.com/p/_ggh2w" target="_blank" rel="external">https://coderwall.com/p/_ggh2w</a></li>
<li><a href="http://www.jsnoob.com/2013/11/26/how-to-break-the-foreach/" target="_blank" rel="external">http://www.jsnoob.com/2013/11/26/how-to-break-the-foreach/</a></li>
<li><a href="http://stackoverflow.com/questions/6260756/how-to-stop-javascript-foreach" target="_blank" rel="external">http://stackoverflow.com/questions/6260756/how-to-stop-javascript-foreach</a></li>
</ul>

	
	</div>
  <a type="button" href="/2014/04/02/2014-04-02-如何在Array.forEach的循环里break/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-03-22 </div>
			<div class="article-title"><a href="/2014/03/22/2014-03-22-DOM精粹/" >DOM精粹</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>The DOM originally was an application programming interface for XML documents that has been extended for use in HTML documents.</p>
</blockquote>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>常见常用的 DOM 节点类型</p>
<ul>
<li><p>DOCUMENT_NODE (e.g., window.document)</p>
</li>
<li><p>ELEMENT_NODE (e.g., body, a, p, script, style, html, h1)</p>
</li>
<li><p>ATTRIBUTE_NODE (e.g., class=”funEdges”)</p>
</li>
<li><p>TEXT_NODE (e.g., text characters in an HTML document including carriage returns<br>and whitespace)</p>
</li>
<li><p>DOCUMENT_FRAGMENT_NODE (e.g., document.createDocumentFragment())</p>
</li>
<li><p>DOCUMENT_TYPE_NODE (e.g., &lt;!DOCTYPE html&gt;)</p>
</li>
</ul>
<p>类型的数值表示:</p>
<ol>
<li>ELEMENT_NODE = 1</li>
<li>ATTRIBUTE_NODE = 2</li>
<li>TEXT_NODE = 3</li>
<li>CDATA_SECTION_NODE = 4</li>
<li>ENTITY_REFERENCE_NODE = 5</li>
<li>ENTITY_NODE = 6</li>
<li>PROCESSING_INSTRUCTION_NODE = 7</li>
<li>COMMENT_NODE = 8</li>
<li>DOCUMENT_NODE = 9</li>
<li>DOCUMENT_TYPE_NODE = 10</li>
<li>DOCUMENT_FRAGMENT_NODE = 11</li>
<li><p>NOTATION_NODE = 12</p>
</li>
<li><p>DOCUMENT_POSITION_DISCONNECTED = 1</p>
</li>
<li>DOCUMENT_POSITION_PRECEDING = 2</li>
<li>DOCUMENT_POSITION_FOLLOWING = 4</li>
<li>DOCUMENT_POSITION_CONTAINS = 8</li>
<li>DOCUMENT_POSITION_CONTAINED_BY = 16</li>
<li>DOCUMENT_POSITION_IMPLEMENTATION_SPECIFIC = 32</li>
</ol>

	
	</div>
  <a type="button" href="/2014/03/22/2014-03-22-DOM精粹/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-03-20 </div>
			<div class="article-title"><a href="/2014/03/20/2014-03-20-dom启蒙笔记/" >dom 启蒙笔记</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>文档对象模型(Document Object Model),是个由javascript 节点对象组成的层次结构。<br>HTML 文档被浏览器解析并转换为一个由节点对象组成的以体现当前文档的树状结构。<br>DOM 的目的是使用Javascritp操作,为当前文档提供一个变成接口。</p>
<h2 id="节点类型"><a href="#节点类型" class="headerlink" title="节点类型"></a>节点类型</h2><p>DOCUMENT_NODE (window.document)<br>ELEMENT_NODE (<body>,<p>)<br>ATTRIBUTE_NODE<br>TEXT_NODE<br>DOCUMENT_FRAGMENT_NODE<br>DOCUMENT_TYPE_NODE (!DOCTYPE HTML)</p>
<h2 id="Node常量"><a href="#Node常量" class="headerlink" title="Node常量"></a>Node常量</h2><p>ELEMENT_NODE<br>ATTRIBUTE_NODE<br>TEXT_NODE<br>CDATA_SECTION_NODE<br>ENTITY_REFERENCE_NODE<br>ENTITY_NODE<br>…..</p>
</body></p>
	
	</div>
  <a type="button" href="/2014/03/20/2014-03-20-dom启蒙笔记/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-03-11 </div>
			<div class="article-title"><a href="/2014/03/11/2014-03-11-通过例子对比grunt和gulp/" >通过例子对比grunt和gulp</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>Grunt出来之后，nodejs里的构建工具宝座长久以来就是它的，随着新星Gulp的出现，Grunt的地位明显被削弱了。因为打算换换口味，决定对比一下它们。</p>
<p>相应的代码在<a href="https://github.com/jserme/gruntvsgulp" target="_blank" rel="external">这里</a>，不想看文章的可以自己clone一下代码，然后对比一下。</p>
<h2 id="定一下我们的任务"><a href="#定一下我们的任务" class="headerlink" title="定一下我们的任务"></a>定一下我们的任务</h2><p>用两个工具分别实现一些常见的任务，对比性能、代码</p>
<ul>
<li>分别实现合并代码，压缩代码、压缩图片</li>
<li>性能对比，代码对比</li>
</ul>
<h2 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h2><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">.</div><div class="line">├── Gruntfile<span class="selector-class">.js</span></div><div class="line">├── dist</div><div class="line">├── grunt<span class="selector-class">.md</span></div><div class="line">├── gulp<span class="selector-class">.md</span></div><div class="line">├── gulpfile<span class="selector-class">.js</span></div><div class="line">├── node_modules</div><div class="line">├── package<span class="selector-class">.json</span></div><div class="line">├── readme<span class="selector-class">.md</span></div><div class="line">└── src</div><div class="line">    ├── images</div><div class="line">    │   └── test<span class="selector-class">.jpg</span></div><div class="line">    └── js</div><div class="line">        ├── jquery-<span class="number">1.11</span>.<span class="number">0</span><span class="selector-class">.js</span></div><div class="line">        └── underscore.js</div></pre></td></tr></table></figure>
<h2 id="使用Grunt"><a href="#使用Grunt" class="headerlink" title="使用Grunt"></a>使用Grunt</h2><h3 id="首先安装grunt"><a href="#首先安装grunt" class="headerlink" title="首先安装grunt"></a>首先安装grunt</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> grunt</div></pre></td></tr></table></figure>
<h3 id="安装我们需要的grunt的插件"><a href="#安装我们需要的grunt的插件" class="headerlink" title="安装我们需要的grunt的插件"></a>安装我们需要的grunt的插件</h3><ul>
<li>校验代码 jshint</li>
<li>移动代码 copy</li>
<li>合并代码 concat</li>
<li>压缩代码 uglify</li>
<li>压缩图片 imagemin</li>
<li>时间分析的插件 time-grunt</li>
</ul>
<figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> grunt-contrib-jshint</div><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> grunt-contrib-uglify</div><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> grunt-contrib-imagemin</div><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> grunt-contrib-concat</div><div class="line">npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> grunt-contrib-copy</div></pre></td></tr></table></figure>
<h3 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h3><p>然后我们来写代码，详细内容还是看<a href="https://github.com/jserme/gruntvsgulp/blob/master/Gruntfile.js" target="_blank" rel="external">Gruntfile.js</a>，下面是一张运行完后的截图</p>
<p><img src="https://raw.github.com/jserme/gruntvsgulp/master/images/grunt-result.png" alt=""></p>
<p>可以看出grunt运行时间为3.6s，相应的信息输出很详细</p>
<h2 id="使用Glup"><a href="#使用Glup" class="headerlink" title="使用Glup"></a>使用Glup</h2><h3 id="全局安装gulp"><a href="#全局安装gulp" class="headerlink" title="全局安装gulp"></a>全局安装gulp</h3><figure class="highlight q"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install -g --<span class="built_in">save</span>-<span class="built_in">dev</span> gulp</div></pre></td></tr></table></figure>
<h3 id="安装相关的gulp插件"><a href="#安装相关的gulp插件" class="headerlink" title="安装相关的gulp插件"></a>安装相关的<code>gulp</code>插件</h3><figure class="highlight maxima"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --<span class="built_in">save</span>-dev gulp-<span class="built_in">concat</span>  gulp-uglify  gulp-imagemin  gulp-jshint</div></pre></td></tr></table></figure>
<h3 id="结果-1"><a href="#结果-1" class="headerlink" title="结果"></a>结果</h3><p>按照<a href="https://github.com/gulpjs/gulp/blob/master/README.md#gulp---" target="_blank" rel="external">开始教程</a>里的内容创建一个<a href="https://github.com/jserme/gruntvsgulp/blob/master/gulpfile.js" target="_blank" rel="external">gulpfile.js</a></p>
<p>运行结果，如图：</p>
<p><img src="https://raw.github.com/jserme/gruntvsgulp/master/images/gulp-result.png" alt=""></p>
<p>可以看到<code>gulp</code>代码更短，输出更简洁</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>可能由于项目比较小的原因，<code>Gulp</code>在性能上并没有领先,但是在代码清晰度和可维护性上<code>Gulp</code>绝对是完胜，还是推荐<code>Gulp</code></p>

	
	</div>
  <a type="button" href="/2014/03/11/2014-03-11-通过例子对比grunt和gulp/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-01-01 </div>
			<div class="article-title"><a href="/2014/01/01/2014-11-10-客户端库管理工具-brower/" >Bower：客户端库管理工具</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>随着网页功能变得越来越复杂，同一张网页加载多个JavaScript函数库早已是家常便饭。开发者越来越需要一个工具，对浏览器端的各种库进行管理，比如搜索、自动安装\卸载、检查更新、确保依赖关系等等。Bower就是为了解决这个问题而诞生的针对浏览器端的库管理工具。</p>
<p>Bower基于node.js，所以安装之前，必须先确保已安装node.js。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install bower -global</div></pre></td></tr></table></figure>
<p>运行上面的命令以后，Bower就已经安装在你的系统中了。运行帮助命令，查看Bower是否安装成功。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower <span class="built_in">help</span></div></pre></td></tr></table></figure>
<p>下面的命令可以更新或卸载Bower。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">sudo npm update -g bower</div><div class="line">sudo npm uninstall -global bower</div></pre></td></tr></table></figure>
<h2 id="常用操作"><a href="#常用操作" class="headerlink" title="常用操作"></a>常用操作</h2><h3 id="库的安装"><a href="#库的安装" class="headerlink" title="库的安装"></a>库的安装</h3><p>bower install命令用于安装某个库，需要指明库的名字。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install backbone</div></pre></td></tr></table></figure>
<p>Bower会使用库的名字，去在线索引中搜索该库的网址。某些情况下，如果一个库很新（或者你不想使用默认网址），可能需要我们手动指定该库的网址。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">bower install git://github.com/documentcloud/backbone.git</div><div class="line"></div><div class="line">bower install http://cdnjs.cloudflare.com/ajax/libs/backbone.js/1.0.0/backbone-min.js</div><div class="line"></div><div class="line">bower install ./some/path/relative/to/this/directory/backbone.js</div></pre></td></tr></table></figure>
<p>上面的命令说明，指定的网址可以是github地址、http网址、本地文件。</p>
<p>默认情况下，会安装该库的最新版本，但是也可以手动指定版本号。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install jquery-ui<span class="comment">#1.10.1</span></div></pre></td></tr></table></figure>
<p>上面的命令指定安装jquery-ui的1.10.1版。</p>
<p>如果某个库依赖另一个库，安装时默认将所依赖的库一起安装。比如，jquery-ui依赖jquery，安装时会连jquery一起安装。</p>
<p>安装后的库默认存放在项目的bower_components子目录，如果要指定其他位置，可在.bowerrc文件的directory属性设置。</p>
<h3 id="库的搜索和查看"><a href="#库的搜索和查看" class="headerlink" title="库的搜索和查看"></a>库的搜索和查看</h3><p>bower search命令用于使用关键字，从在线索引中搜索相关库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower search jquery</div></pre></td></tr></table></figure>
<p>上面命令会得到下面这样的结果。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line">Search results:</div><div class="line"></div><div class="line">    jquery git://github.com/components/jquery.git</div><div class="line">    jquery-ui git://github.com/components/jqueryui</div><div class="line">    jquery.cookie git://github.com/carhartl/jquery-cookie.git</div><div class="line">    jquery-placeholder git://github.com/mathiasbynens/jquery-placeholder.git</div><div class="line">    jquery-file-upload git://github.com/blueimp/jQuery-File-Upload.git</div><div class="line">    jasmine-jquery git://github.com/velesin/jasmine-jquery</div><div class="line">    jquery.ui git://github.com/jquery/jquery-ui.git</div><div class="line">    ...</div></pre></td></tr></table></figure>
<p>bower info命令用于查看某个库的详细信息。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower info jquery-ui</div></pre></td></tr></table></figure>
<p>查看结果会列出该库的依赖关系（dependencies），以及可以得到的版本（Available versions）。</p>
<h3 id="库的更新和卸载"><a href="#库的更新和卸载" class="headerlink" title="库的更新和卸载"></a>库的更新和卸载</h3><p>bower update用于更新一个库，将其更新为最新版本。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower update jquery-ui</div></pre></td></tr></table></figure>
<p>如果不给出库名，则更新所有库。</p>
<p>bower uninstall命令用于卸载指定的库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower uninstall jquery-ui</div></pre></td></tr></table></figure>
<p>注意，默认情况下会连所依赖的库一起卸载。比如，jquery-ui依赖jquery，卸载时会连jquery一起卸载，除非还有别的库依赖jquery。</p>
<h3 id="列出所有库"><a href="#列出所有库" class="headerlink" title="列出所有库"></a>列出所有库</h3><p>bower list或bower ls命令，用于列出项目所使用的所有库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Bower list</div><div class="line">Bower ls</div></pre></td></tr></table></figure>
<h2 id="配置文件-bowerrc"><a href="#配置文件-bowerrc" class="headerlink" title="配置文件.bowerrc"></a>配置文件.bowerrc</h2><p>项目根目录下（也可以放在用户的主目录下）的.bowerrc文件是Bower的配置文件，它大概像下面这样。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"directory"</span> : <span class="string">"components"</span>,</div><div class="line">  <span class="string">"json"</span>      : <span class="string">"bower.json"</span>,</div><div class="line">  <span class="string">"endpoint"</span>  : <span class="string">"https://Bower.herokuapp.com"</span>,</div><div class="line">  <span class="string">"searchpath"</span>  : <span class="string">""</span>,</div><div class="line">  <span class="string">"shorthand_resolver"</span> : <span class="string">""</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>其中的属性含义如下。</p>
<ul>
<li>directory：存放库文件的子目录名。</li>
<li>json：描述各个库的json文件名。 </li>
<li>endpoint：在线索引的网址，用来搜索各种库。</li>
<li>searchpath：一个数组，储存备选的在线索引网址。如果某个库在endpoint中找不到，则继续搜索该属性指定的网址，通常用于放置某些不公开的库。</li>
<li>shorthand_resolver：定义各个库名称简写形式。</li>
</ul>
<h2 id="库信息文件bower-json"><a href="#库信息文件bower-json" class="headerlink" title="库信息文件bower.json"></a>库信息文件bower.json</h2><p>bower.json文件存放在库的根目录下，用于保存项目的库信息，供项目安装时使用，以及Bower的在线索引读取。</p>
<p>下面是一个典型的bower.json文件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="string">"name"</span>: <span class="string">"app-name"</span>,</div><div class="line">  <span class="string">"version"</span>: <span class="string">"0.1.0"</span>, </div><div class="line">  <span class="string">"main"</span>: [<span class="string">"path/to/app.html"</span>, <span class="string">"path/to/app.css"</span>, <span class="string">"path/to/app.js"</span>],</div><div class="line">  <span class="string">"ignore"</span>: [<span class="string">".jshintrc"</span>,<span class="string">"**/*.txt"</span>],</div><div class="line">  <span class="string">"dependencies"</span>: &#123;</div><div class="line">    <span class="string">"sass-bootstrap"</span>: <span class="string">"~3.0.0"</span>,</div><div class="line">    <span class="string">"modernizr"</span>: <span class="string">"~2.6.2"</span>,</div><div class="line">    <span class="string">"jquery"</span>: <span class="string">"latests"</span></div><div class="line">  &#125;,</div><div class="line">  <span class="string">"devDependencies"</span>: &#123;<span class="string">"qunit"</span>: <span class="string">"&gt;1.11.0"</span>&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在项目的根目录下，运行bower init命令，通过回答几个问题，就会自动生成bower.json文件。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower init</div></pre></td></tr></table></figure>
<p>有了bower.json文件以后，就可以用bower install命令，一下子安装所有库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">bower install</div></pre></td></tr></table></figure>
<p>根据bower.json文件，还可以向Bower的在线索引提交你的库。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">bower register &lt;my-package-name&gt; &lt;git-endpoint&gt;</div><div class="line"></div><div class="line">// 比如</div><div class="line">bower register jquery git://github.com/jquery/jquery</div></pre></td></tr></table></figure>
<p>注意，如果你的库与现有的库重名，就会提交失败。</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>Cody Lindley, <a href="http://tech.pro/tutorial/1190/package-managers-an-introductory-guide-for-the-uninitiated-front-end-developer" target="_blank" rel="external">Package Managers: An Introductory Guide For The Uninitiated Front-End Developer</a></li>
<li>Tyson Cadenhead, <a href="http://tysoncadenhead.com/blog/client-side-dependency-management-with-bower" target="_blank" rel="external">Client-Side Dependency Management with Bower</a></li>
<li>Matt West, <a href="http://blog.teamtreehouse.com/getting-started-bower" target="_blank" rel="external">Getting Started with Bower</a></li>
</ul>

	
	</div>
  <a type="button" href="/2014/01/01/2014-11-10-客户端库管理工具-brower/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-29 </div>
			<div class="article-title"><a href="/2013/12/29/2013-12-29-websocket/" >WebSocket</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>HTTP协议是一种无状态协议，服务器端本身不具有识别客户端的能力，必须借助外部机制，比如session和cookie，才能与特定客户端保持对话。这多多少少带来一些不便，尤其在服务器端与客户端需要持续交换数据的场合（比如网络聊天），更是如此。为了解决这个问题，HTML5提出了浏览器的<a href="http://dev.w3.org/html5/websockets/" target="_blank" rel="external">WebSocket API</a>。</p>
<p>WebSocket的主要作用是，允许服务器端与客户端进行全双工（full-duplex）的通信。举例来说，HTTP协议有点像发电子邮件，发出后必须等待对方回信；WebSocket则是像打电话，服务器端和客户端可以同时向对方发送数据，它们之间存着一条持续打开的数据通道。</p>
<p>WebSocket协议完全可以取代Ajax方法，用来向服务器端发送文本和二进制数据，而且还没有“同域限制”。</p>
<p>WebSocket不使用HTTP协议，而是使用自己的协议。浏览器发出的WebSocket请求类似于下面的样子：</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">GET</span> <span class="string">/</span> HTTP/1.1</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Host</span>: example.com</div><div class="line"><span class="attribute">Origin</span>: null</div><div class="line"><span class="attribute">Sec-WebSocket-Key</span>: sN9cRrP/n9NdMgdcy2VJFQ==</div><div class="line"><span class="attribute">Sec-WebSocket-Version</span>: 13</div></pre></td></tr></table></figure>
<p>上面的头信息显示，有一个HTTP头是Upgrade。HTTP1.1协议规定，Upgrade头信息表示将通信协议从HTTP/1.1转向该项所指定的协议。“Connection: Upgrade”就表示浏览器通知服务器，如果可以，就升级到webSocket协议。Origin用于验证浏览器域名是否在服务器许可的范围内。Sec-WebSocket-Key则是用于握手协议的密钥，是base64编码的16字节随机字符串。</p>
<p>服务器端的WebSocket回应则是</p>
<figure class="highlight http"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">HTTP/1.1 <span class="number">101</span> Switching Protocols</div><div class="line"><span class="attribute">Connection</span>: Upgrade</div><div class="line"><span class="attribute">Upgrade</span>: websocket</div><div class="line"><span class="attribute">Sec-WebSocket-Accept</span>: fFBooB7FAkLlXgRSz0BT3v4hq5s=</div><div class="line"><span class="attribute">Sec-WebSocket-Origin</span>: null</div><div class="line"><span class="attribute">Sec-WebSocket-Location</span>: ws://example.com/</div></pre></td></tr></table></figure>
<p>服务器端同样用“Connection: Upgrade”通知浏览器，需要改变协议。Sec-WebSocket-Accept是服务器在浏览器提供的Sec-WebSocket-Key字符串后面，添加“258EAFA5-E914-47DA-95CA-C5AB0DC85B11” 字符串，然后再取sha-1的hash值。浏览器将对这个值进行验证，以证明确实是目标服务器回应了webSocket请求。Sec-WebSocket-Location表示进行通信的WebSocket网址。</p>
<blockquote>
<p>请注意，WebSocket协议用ws表示。此外，还有wss协议，表示加密的WebSocket协议，对应HTTPs协议。</p>
</blockquote>
<p>完成握手以后，WebSocket协议就在TCP协议之上，开始传送数据。</p>
<p>WebSocket协议需要服务器支持，目前比较流行的实现是基于node.js的<a href="http://socket.io/" target="_blank" rel="external">socket.io</a>，更多的实现可参阅<a href="http://en.wikipedia.org/wiki/WebSocket#Server_side" target="_blank" rel="external">Wikipedia</a>。至于浏览器端，目前主流浏览器都支持WebSocket协议（包括IE 10+），仅有的例外是手机端的Opera Mini和Android Browser。</p>
<h2 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h2><p>浏览器端对WebSocket协议的处理，无非就是三件事：</p>
<ul>
<li>建立连接和断开连接</li>
<li>发送数据和接收数据</li>
<li>处理错误</li>
</ul>
<h3 id="建立连接和断开连接"><a href="#建立连接和断开连接" class="headerlink" title="建立连接和断开连接"></a>建立连接和断开连接</h3><p>首先，客户端要检查浏览器是否支持WebSocket，使用的方法是查看window对象是否具有WebSocket属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket != <span class="literal">undefined</span>) &#123;</div><div class="line">	<span class="comment">// WebSocket代码</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>然后，开始与服务器建立连接（这里假定服务器就是本机的1740端口，需要使用ws协议）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="built_in">window</span>.WebSocket != <span class="literal">undefined</span>) &#123;</div><div class="line">	<span class="keyword">var</span> connection = <span class="keyword">new</span> WebSocket(<span class="string">'ws://localhost:1740'</span>);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>建立连接以后的WebSocket实例对象（即上面代码中的connection），有一个readyState属性，表示目前的状态，可以取4个值：</p>
<ul>
<li><strong>0</strong>： 正在连接</li>
<li><strong>1</strong>： 连接成功</li>
<li><strong>2</strong>： 正在关闭</li>
<li><strong>3</strong>： 连接关闭</li>
</ul>
<p>握手协议成功以后，readyState就从0变为1，并触发open事件，这时就可以向服务器发送信息了。我们可以指定open事件的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.onopen = wsOpen;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsOpen</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">'Connected to: '</span> + event.currentTarget.URL);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>关闭WebSocket连接，会触发close事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.onclose = wsClose;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsClose</span> (<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Closed"</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">connection.close();</div></pre></td></tr></table></figure>
<h3 id="发送数据和接收数据"><a href="#发送数据和接收数据" class="headerlink" title="发送数据和接收数据"></a>发送数据和接收数据</h3><p>连接建立后，客户端通过send方法向服务器端发送数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.send(message);</div></pre></td></tr></table></figure>
<p>除了发送字符串，也可以使用 Blob 或 ArrayBuffer 对象发送二进制数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="comment">// 使用ArrayBuffer发送canvas图像数据</span></div><div class="line"><span class="keyword">var</span> img = canvas_context.getImageData(<span class="number">0</span>, <span class="number">0</span>, <span class="number">400</span>, <span class="number">320</span>);</div><div class="line"><span class="keyword">var</span> binary = <span class="keyword">new</span> <span class="built_in">Uint8Array</span>(img.data.length);</div><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; img.data.length; i++) &#123;</div><div class="line">	binary[i] = img.data[i];</div><div class="line">&#125;</div><div class="line">connection.send(binary.buffer);</div><div class="line"></div><div class="line"><span class="comment">// 使用Blob发送文件</span></div><div class="line"><span class="keyword">var</span> file = <span class="built_in">document</span>.querySelector(<span class="string">'input[type="file"]'</span>).files[<span class="number">0</span>];</div><div class="line">connection.send(file);</div></pre></td></tr></table></figure>
<p>客户端收到服务器发送的数据，会触发message事件。可以通过定义message事件的回调函数，来处理服务端返回的数据。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.onmessage = wsMessage;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsMessage</span> (<span class="params">event</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(event.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>上面代码的回调函数wsMessage的参数为事件对象event，该对象的data属性包含了服务器返回的数据。</p>
<p>如果接收的是二进制数据，需要将连接对象的格式设为blob或arraybuffer。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.binaryType = <span class="string">'arraybuffer'</span>;</div><div class="line"></div><div class="line">connection.onmessage = <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(e.data.byteLength); <span class="comment">// ArrayBuffer对象有byteLength属性</span></div><div class="line">&#125;;</div></pre></td></tr></table></figure>
<h3 id="处理错误"><a href="#处理错误" class="headerlink" title="处理错误"></a>处理错误</h3><p>如果出现错误，浏览器会触发WebSocket实例对象的error事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.onerror = wsError;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wsError</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"Error: "</span> + event.data);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="服务器端"><a href="#服务器端" class="headerlink" title="服务器端"></a>服务器端</h2><p>服务器端需要单独部署处理WebSocket的代码。下面用node.js搭建一个服务器环境。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"><span class="keyword">var</span> server = http.createServer(<span class="function"><span class="keyword">function</span>(<span class="params">request, response</span>) </span>&#123;&#125;);</div></pre></td></tr></table></figure>
<p>假设监听1740端口。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">server.listen(<span class="number">1740</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log((<span class="keyword">new</span> <span class="built_in">Date</span>()) + <span class="string">' Server is listening on port 1740'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>接着启动WebSocket服务器。这需要加载websocket库，如果没有安装，可以先使用npm命令安装。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> WebSocketServer = <span class="built_in">require</span>(<span class="string">'websocket'</span>).server;</div><div class="line"><span class="keyword">var</span> wsServer = <span class="keyword">new</span> WebSocketServer(&#123;</div><div class="line">    <span class="attr">httpServer</span>: server</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>WebSocket服务器建立request事件的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> connection;</div><div class="line"></div><div class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">req</span>)</span>&#123;</div><div class="line">    connection = req.accept(<span class="string">'echo-protocol'</span>, req.origin);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的回调函数接受一个参数req，表示request请求对象。然后，在回调函数内部，建立WebSocket连接connection。接着，就要对connection的message事件指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">wsServer.on(<span class="string">'request'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123;</div><div class="line">    connection = req.accept(<span class="string">'echo-protocol'</span>, req.origin);</div><div class="line"></div><div class="line">	connection.on(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> msgString = message.utf8Data;</div><div class="line">		connection.sendUTF(msgString);</div><div class="line">	&#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后，监听用户的disconnect事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">connection.on(<span class="string">'close'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">reasonCode, description</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(connection.remoteAddress + <span class="string">' disconnected.'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="Socket-io简介"><a href="#Socket-io简介" class="headerlink" title="Socket.io简介"></a>Socket.io简介</h2><p><a href="http://socket.io/" target="_blank" rel="external">Socket.io</a>是目前最流行的WebSocket实现，包括服务器和客户端两个部分。它不仅简化了接口，使得操作更容易，而且对于那些不支持WebSocket的浏览器，会自动降为Ajax连接，最大限度地保证了兼容性。</p>
<p>第一步，在服务器端的项目根目录下，安装socket.io模块。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">npm install socket.io</div></pre></td></tr></table></figure>
<p>第二步，在根目录下建立app.js，并写入以下代码（假定使用了Express框架）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> app = <span class="built_in">require</span>(<span class="string">'express'</span>)();</div><div class="line"><span class="keyword">var</span> server = <span class="built_in">require</span>(<span class="string">'http'</span>).createServer(app);</div><div class="line"><span class="keyword">var</span> io = <span class="built_in">require</span>(<span class="string">'socket.io'</span>).listen(server);</div><div class="line"></div><div class="line">server.listen(<span class="number">80</span>);</div><div class="line"></div><div class="line">app.get(<span class="string">'/'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">req, res</span>) </span>&#123;</div><div class="line">  res.sendfile(__dirname + <span class="string">'/index.html'</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码表示，先建立并运行HTTP服务器。Socket.io的运行建立在HTTP服务器之上。</p>
<p>第三步，将Socket.io插入客户端网页。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"/socket.io/socket.io.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，在客户端脚本中，建立WebSocket连接。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> socket = io.connect(<span class="string">'http://localhost'</span>);</div></pre></td></tr></table></figure>
<p>由于本例假定WebSocket主机与客户端是同一台机器，所以connect方法的参数是<code>http://localhost</code>。接着，指定news事件（即服务器端发送news）的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">socket.on(<span class="string">'news'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>)</span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(data);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>最后，用emit方法向服务器端发送信号，触发服务器端的anotherNews事件。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">socket.emit(<span class="string">'anotherNews'</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>请注意，emit方法可以取代Ajax请求，而on方法指定的回调函数，也等同于Ajax的回调函数。</p>
</blockquote>
<p>第四步，在服务器端的app.js，加入以下代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">io.sockets.on(<span class="string">'connection'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">socket</span>) </span>&#123;</div><div class="line">  socket.emit(<span class="string">'news'</span>, &#123; <span class="attr">hello</span>: <span class="string">'world'</span> &#125;);</div><div class="line">  socket.on(<span class="string">'anotherNews'</span>, <span class="function"><span class="keyword">function</span> (<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data);</div><div class="line">  &#125;);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的io.sockets.on方法指定connection事件（WebSocket连接建立）的回调函数。在回调函数中，用emit方法向客户端发送数据，触发客户端的news事件。然后，再用on方法指定服务器端anotherNews事件的回调函数。</p>

	
	</div>
  <a type="button" href="/2013/12/29/2013-12-29-websocket/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-26 </div>
			<div class="article-title"><a href="/2013/12/26/2013-12-26-angular入门/" >angular入门</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><p>作用域（scope）是构成AngularJS应用的核心基础，在整个框架中都被广泛使用，因此了解<br>它如何工作是非常重要的。</p>
<p><code>$scope</code> 对象是定义应用业务逻辑、控制器方法和视图属性的地方。</p>
<p>作用域是应用状态的基础。基于动态绑定，我们可以依赖视图在修改数据时立刻更新$scope，<br>也可以依赖$scope在其发生变化时立刻重新渲染视图。</p>
<p>AngularJS将$scope设计成和DOM类似的结构，因此$scope可以进行嵌套，也就是说我们可以引用父级$scope中的属性。</p>
<p>作用域提供了监视数据模型变化的能力。它允许开发者使用其中的apply机制，将数据模型的变化在整个应用范围内进行通知。我们在作用域的上下文中定义和执行表达式，同时它也是将事件通知给另一个控制器和应用其他部分的中介。</p>
<p>AngularJS启动并生成视图时，会将根ng-app元素同$rootScope进行绑定。$rootScope是所有$scope对象的最上层。</p>
<p>$rootScope是AngularJS中最接近全局作用域的对象。在$rootScope上附加太多业<br>务逻并不是好主意，这与污染JavaScript的全局作用域是一样的。</p>
<p>$scope对象在AngularJS中充当数据模型，但与传统的数据模型不一样，$scope并不负责处<br>理和操作数据，它只是视图和HTML之间的桥梁，它是视图和控制器之间的胶水。</p>
<p>$scope的所有属性，都可以自动被视图访问到。假设我们有如下的HTML：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">ng-app</span>=<span class="string">"myApp"</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello &#123;&#123; name &#125;&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果希望变量是本地$scope的一个属性:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">angular.module(<span class="string">'myApp'</span>, [])</div><div class="line">	.run(<span class="function"><span class="keyword">function</span>(<span class="params">$rootScope</span>) </span>&#123;</div><div class="line">		$rootScope.name = <span class="string">"World"</span>;</div><div class="line">	&#125;);</div></pre></td></tr></table></figure></p>
<p>因为把所有变量全部设置在 $rootScope 上容易产生命名冲突且不是那么优雅，可以</p>
<p>神奇的 $scope:</p>
<ol>
<li>$scope 是一个 POJO （Plain Old Javascript Object）</li>
<li>$scope 提供了一些工具方法 $watch(), $apply()</li>
<li>$scope 是表达式的执行环境（或者说是作用域）</li>
<li>$scope 是一个树形结构，与 DOM 标签平行</li>
<li>子 $scope 会继承父 $scope 上的属性和方法</li>
<li>每一个 angular 应用只有一个 根$scope 对象，一般位于 ng-app 上</li>
<li>$scope 可以传播事件，类似 dom事件，可以向上也可以向下</li>
<li>$scope 不仅是 MVC 的基础，也是实现双向数据绑定的基础</li>
</ol>
<h2 id="inbox"><a href="#inbox" class="headerlink" title="inbox"></a>inbox</h2><p>正如ng-app 声明所有被它包含的元素都属于AngularJS 应用一样，DOM元素上的 ng-controller声明所有被它包含的元素都属于某个控制器。</p>
<p>$rootScope , $scope 类似 javascript 中的原型查找， 在内层$scope 中查找不到，去外层查找$rootScope.</p>
<p>事件传播： emmit 向上传播，冒泡； broadcast： 向下传播，类似捕获。</p>

	
	</div>
  <a type="button" href="/2013/12/26/2013-12-26-angular入门/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2013-12-24 </div>
			<div class="article-title"><a href="/2013/12/24/2013-12-24-css核心概念/" >css核心概念</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="Visual-formatting-Context"><a href="#Visual-formatting-Context" class="headerlink" title="Visual formatting Context"></a>Visual formatting Context</h2><p>在常规流中的框（boxes，元素形成的矩形区域），都属于一个格式化的上下文中，可能是块(block)的，也可能是行内(inline)的，但不可能同时是行内的又是块的。块框(block box)参与块格式化上下文(formatting context)。行内框(inline box)参与行内格式化上下文。</p>
<h3 id="包含块-containing-block-简介"><a href="#包含块-containing-block-简介" class="headerlink" title="包含块(containing block)简介"></a>包含块(containing block)简介</h3><p>在CSS2.1中，很多box的定位和尺寸的计算，都取决于一个矩形的边界，这个矩形，就被称作是包含块(containing block)。一般来说，(元素)生成的box会扮演它子孙元素包含块的角色；我们称之为：一个(元素的)box为它的子孙节点建造了包含块。包含块是一个相对的概念。<br>比如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span></div><div class="line">	<span class="tag">&lt;<span class="name">table</span>&gt;</span></div><div class="line">		<span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>hi<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></div><div class="line">	<span class="tag">&lt;/<span class="name">table</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>
<p>div 和 table 都是包含块。div 是 table 的包含块，同时table又是 td 的包含块，不是绝对的。<br>“一个box的包含块”，指的是“该box所存在的那个包含块”，并不是它建造的包含块。比如，上述代码中，table 的包含块，说的是 div 建造的包含块，而不是table自身建造的包含块。table 建造的包含块，可以称作 td 的包含块。</p>
<p>每个box关于它的包含块都有一个位置，但是它不会被包含块限制；它可以溢出(包含块)。包含块上可以通过设置 overflow 特性达到处理溢出的子孙元素的目的。</p>
<h3 id="行内级别元素和行内框"><a href="#行内级别元素和行内框" class="headerlink" title="行内级别元素和行内框"></a>行内级别元素和行内框</h3><p>行内元素是源文档中那些不形成新的内容块的元素；内容在行内分布（如，段落内着重的文本，行内图形等等）。某些’display’特性的值形成行内元素：’inline’，’inline-table’，’run-in’。行内级别元素生成行内框。</p>
<h3 id="匿名行内框"><a href="#匿名行内框" class="headerlink" title="匿名行内框"></a>匿名行内框</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>Some <span class="tag">&lt;<span class="name">EM</span>&gt;</span>emphasized<span class="tag">&lt;/<span class="name">em</span>&gt;</span> text<span class="tag">&lt;/<span class="name">P</span>&gt;</span></div></pre></td></tr></table></figure>
<p>P元素生成一个块控制框，其内还有几个行内框。”emphasized”的框是一个行内元素（em）产生的行内框，而其它的框（”Some”和”text”）是块级元素（P）产生的行内框。后者就称为匿名行内控制框，因为它们没有与之相关的行内元素，所以，这些框被叫做匿名行内框。</p>
<h3 id="块格式化上下文-Block-formatting-contexts"><a href="#块格式化上下文-Block-formatting-contexts" class="headerlink" title="块格式化上下文(Block formatting contexts)"></a>块格式化上下文(Block formatting contexts)</h3><p>把context翻译成”上下文”，是因为，它强调框存在的环境。所谓上下文，有活动范围，有效区域的意思。</p>
<blockquote>
<p>The hasLayout property conflicts with a number of normative CSS rules, although it is similar in concept to block formatting contexts.</p>
</blockquote>
<h2 id="haslayout"><a href="#haslayout" class="headerlink" title="haslayout"></a>haslayout</h2><p>haslayout 是Windows Internet Explorer渲染引擎的一个内部组成部分。在Internet Explorer中，一个元素要么自己对自身的内容进行计算大小和组织，要么依赖于父元素来计算尺寸和组织内容。为了调节这两个不同的概念，渲染引擎采用了 hasLayout 的属性，属性值可以为true或false。当一个元素的 hasLayout 属性值为true时，我们说这个元素有一个布局（layout）.</p>
<p>hasLayout 属性与许多 css 的标准相冲突. 即使它在概念上与 BFC 很像.</p>
<p>In IE7 mode, only elements that have layout can be containing blocks, which conflicts with CSS2.1 normative definition (see 10.1). Not all block elements have layout by default, yet block elements should be the containing blocks of all their children that have relative or static positioning.</p>
<p>有 layout 的元素才能容纳块状元素, 这与 CSS2.1 标准相冲突. 不是所有的块状元素默认就拥有 layout, 而是块状元素应该作为所有具有相对或静态定位的子元素的包含块.</p>
<p>对于并非所有的元素都默认有布局，微软给出的主要原因是“性能和简洁”。如果所有的元素都默认有布局，会对性能和内存使用上产生有害的影响。</p>
<h3 id="如何激发-haslayout？"><a href="#如何激发-haslayout？" class="headerlink" title="如何激发 haslayout？"></a>如何激发 haslayout？</h3><p>大部分的 IE 显示错误，都可以通过激发元素的 haslayout 属性来修正。可以通过设置 css 尺寸属性(width/height)等来激发元素的 haslayout，使其“拥有布局”。如下所示，通过设置以下 css 属性即可。</p>
<ul>
<li>display: inline-block</li>
<li>height: (任何值除了auto)</li>
<li>float: (left 或 right)</li>
<li>position: absolute</li>
<li>width: (任何值除了auto)</li>
<li>writing-mode: tb-rl</li>
<li>zoom: (除 normal 外任意值)</li>
</ul>
<h2 id="Block-Formatting-Context-块格式化上下文"><a href="#Block-Formatting-Context-块格式化上下文" class="headerlink" title="Block Formatting Context (块格式化上下文)"></a>Block Formatting Context (块格式化上下文)</h2><p>块格式化上下文是 W3C css2.1 规范中的一个概念,它决定了元素如何<br>对其内容进行定位,以及与其他元素的关系和相互作用.</p>
<p>在创建了 Block Formatting Context 的元素中, 其子元素会一个接一个的放置<br>.垂直方向上它们的起点是一个包含块的顶部. 两个相邻元素之间的<br>距离取决于’margin’ 特性. </p>
<p>在 Block Formatting Context 中,相邻的块级元素的垂直边距会折叠.<br>(collapse).</p>
<p>在 BFC 中,每一个元素左外边与包含块的左边相接触,即使存在浮动也是如此<br>. 除非这个元素也创建了一个新的 BFC.</p>
<p>浮动元素,绝对定位元素, inline-block, table-cells, table-captions 以及<br><code>overflow</code> 值不是 <code>visible</code> 的元素, 会创建block formatting context.</p>
<p>hasLayout 和 block formatting context 是对同一类事物的不同理解.</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可视化结构的基础就是由大大小小的 box(盒) 组成的. 每个盒子有自己的盒模型 </p>
<p>在现实布局上,又分为块框(block box)和行内框(inline box).</p>
<p>盒子之间的关系就是涉及到了格式化上下文, Block Formatting Context 和 Inline Formatting Context&gt;</p>
<h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><p><a href="http://bbs.csdn.net/topics/340237864" target="_blank" rel="external">http://bbs.csdn.net/topics/340237864</a><br><a href="http://bbs.csdn.net/topics/340219127" target="_blank" rel="external">http://bbs.csdn.net/topics/340219127</a></p>

	
	</div>
  <a type="button" href="/2013/12/24/2013-12-24-css核心概念/#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/10/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/12/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			 

		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Sports/Baseball/">Baseball<span>2</span></a></li>
		
			<li><a href="/categories/Sports/">Sports<span>2</span></a></li>
		
			<li><a href="/categories/bom/">bom<span>1</span></a></li>
		
			<li><a href="/categories/collection/">collection<span>1</span></a></li>
		
			<li><a href="/categories/css/">css<span>1</span></a></li>
		
			<li><a href="/categories/http/">http<span>1</span></a></li>
		
			<li><a href="/categories/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/categories/javascript-test/">javascript test<span>1</span></a></li>
		
			<li><a href="/categories/jquery/">jquery<span>1</span></a></li>
		
			<li><a href="/categories/library/">library<span>2</span></a></li>
		
			<li><a href="/categories/note/">note<span>1</span></a></li>
		
			<li><a href="/categories/note-vim/">note vim<span>2</span></a></li>
		
			<li><a href="/categories/tool/">tool<span>3</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/git/">git<span>5</span></a></li>
		
			<li><a href="/tags/html/">html<span>2</span></a></li>
		
			<li><a href="/tags/css/">css<span>7</span></a></li>
		
			<li><a href="/tags/javascript/">javascript<span>9</span></a></li>
		
			<li><a href="/tags/document/">document<span>1</span></a></li>
		
			<li><a href="/tags/linux/">linux<span>6</span></a></li>
		
			<li><a href="/tags/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/tags/regexp/">regexp<span>6</span></a></li>
		
			<li><a href="/tags/w3c/">w3c<span>1</span></a></li>
		
			<li><a href="/tags/seajs/">seajs<span>1</span></a></li>
		
			<li><a href="/tags/think/">think<span>1</span></a></li>
		
			<li><a href="/tags/http/">http<span>2</span></a></li>
		
			<li><a href="/tags/Fight/">Fight<span>2</span></a></li>
		
			<li><a href="/tags/default/">default<span>1</span></a></li>
		
			<li><a href="/tags/html-优化/">html 优化<span>1</span></a></li>
		
			<li><a href="/tags/build/">build<span>2</span></a></li>
		
			<li><a href="/tags/dom-javascript/">dom,javascript<span>1</span></a></li>
		
			<li><a href="/tags/vim/">vim<span>3</span></a></li>
		
			<li><a href="/tags/demo/">demo<span>1</span></a></li>
		
			<li><a href="/tags/html5/">html5<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>39</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/02/01/2012-08-03-linux同步标准时间/" ><i class="fa fa-file-o"></i>linux同步标准时间</a>
      </li>
    
      <li>
        <a href="/2017/02/01/脚本的第一行/" ><i class="fa fa-file-o"></i></a>
      </li>
    
      <li>
        <a href="/2017/02/01/消除函数的术语歧义/" ><i class="fa fa-file-o"></i></a>
      </li>
    
      <li>
        <a href="/2017/02/01/设计模式简介/" ><i class="fa fa-file-o"></i></a>
      </li>
    
      <li>
        <a href="/2017/02/01/代码质量的分类/" ><i class="fa fa-file-o"></i></a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/chenyakun" title="My Github repository." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 yakun.cyk
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<!-- <script src="/js/search.js"></script>  -->

<!-- 
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>
 -->

<!-- 
   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>
 -->

<div class="cb-search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px;
        opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">

    <input type="text" class="cb-search-content" id="cb-search-content" style="position: fixed; top: 60px" placeholder="文章标题 日期 标签" />

    <div style="position: fixed; top: 16px; right: 16px;">
        <img src="/search/img/cb-close.png"  id="cb-close-btn"/>
    </div>
</div>

<!-- <div style="position: fixed; right: 16px; bottom: 20px;">
    <img src="/search/img/cb-search.png"  id="cb-search-btn"  title="双击ctrl试一下"/>
</div> -->

<link rel="stylesheet" href="/search/css/cb-search.css">
<script src="/search/js/bootstrap3-typeahead.min.js"></script>
<script src="/search/js/cb-search.js"></script>

</body>
   </html>
