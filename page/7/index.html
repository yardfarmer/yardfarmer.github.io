<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 7 页 | output stream</title>
  <meta name="author" content="yakun.cyk">
  
  <meta name="description" content="主要内容可能关于 web 技术，感慨心得...">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="output stream"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
    <div class="container">
      <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
		<span class="sr-only">Toggle navigation</span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
	  <a class="navbar-brand" href="/">output stream</a>
      <div class="collapse navbar-collapse nav-menu">
		<ul class="nav navbar-nav">
		  
		  <li>
			<a href="/archives" title="All the articles.">
			  <i class="fa fa-archive"></i>Archives
			</a>
		  </li>
		  
		  <li>
			<a href="/categories" title="All the categories.">
			  <i class="fa fa-folder"></i>Categories
			</a>
		  </li>
		  
		  <li>
			<a href="/tags" title="All the tags.">
			  <i class="fa fa-tags"></i>Tags
			</a>
		  </li>
		  
		  <li>
			<a href="/about" title="About me.">
			  <i class="fa fa-user"></i>About
			</a>
		  </li>
		  
		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <!--
        <i class="fa fa-heart"></i> 
      -->
      
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2015-01-03 </div>
			<div class="article-title"><a href="/2015/01/03/2015-01-3-polymer/" >polymer的使用</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="结构搭建"><a href="#结构搭建" class="headerlink" title="结构搭建"></a>结构搭建</h2><h3 id="加载引用文件"><a href="#加载引用文件" class="headerlink" title="加载引用文件"></a>加载引用文件</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span></span></div><div class="line">  <span class="attr">src</span>=<span class="string">"../components/platform/platform.js"</span>&gt;<span class="handlebars"><span class="xml"></span></span></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span></span></div><div class="line">  <span class="attr">href</span>=<span class="string">"../components/font-roboto/roboto.html"</span>&gt;</div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span></span></div><div class="line">  <span class="attr">href</span>=<span class="string">"../components/core-header-panel/core-header-panel.html"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span></span></div><div class="line">  <span class="attr">href</span>=<span class="string">"../components/core-toolbar/core-toolbar.html"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span></span></div><div class="line">  <span class="attr">href</span>=<span class="string">"../components/paper-tabs/paper-tabs.html"</span>&gt;</div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></div></pre></td></tr></table></figure>
<p>Polymer 使用 HTML imports 来加载 components. HTML imports 提供了依赖关系的管理，保证你的 elements 和它们的依赖都加载好了你再使用它们。</p>
<h3 id="预防-FOUC"><a href="#预防-FOUC" class="headerlink" title="预防 FOUC"></a>预防 FOUC</h3><p>在 custom elements 更新 之前可能显示错乱。 为了缓解 FOUC 问题, Polymer 提供了一个 polyfill 解决方案，配合 :unresolved 伪类 使用。 对于简单的 app，你可以为 body 添加 unresolved 属性。这将在页面初始化时隐藏页面直到所有的 elements 被更新才显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">unresolved</span>&gt;</span></div></pre></td></tr></table></figure>
<p>polymer-ready 触发前， Polymer 会执行以下的步骤：</p>
<ul>
<li>移除 elements 中 [unresolved] 属性</li>
<li>添加 [resolved] 属性</li>
<li>在 element 收到第一个  transitionend 时移除 [resolved]</li>
</ul>
<h3 id="声明式数据绑定"><a href="#声明式数据绑定" class="headerlink" title="声明式数据绑定"></a>声明式数据绑定</h3><p><code>胡子</code> 方式， mustache(有一款同名的模板引擎mustache.js)</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">polymer-element</span> <span class="attr">name</span>=<span class="string">"name-tag"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    This is <span class="tag">&lt;<span class="name">b</span>&gt;</span>&#123;&#123;owner&#125;&#125;<span class="tag">&lt;/<span class="name">b</span>&gt;</span>'s name-tag element.</div><div class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"></span></div><div class="line">    Polymer(<span class="string">'name-tag'</span>, &#123;</div><div class="line">      owner: <span class="string">'Daniel'</span></div><div class="line">    &#125;);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">polymer-element</span>&gt;</span></div></pre></td></tr></table></figure>
<h3 id="自动化定位结点"><a href="#自动化定位结点" class="headerlink" title="自动化定位结点"></a>自动化定位结点</h3><p>Polymer 另一个给力的功能是自动化定位结点。一个 component 的 shadow DOM 中标有 id 特性的结点可以被自动引用在该 component 的 this.$ 散列表中。</p>
<p>注意：通过数据绑定动态创建的结点<em>无法</em>被添加到 this.$ 散列表中。该散列表只包含<em>静态</em>创建的 shadow DOM 结点 (即定义在 element 外部的模板中的结点)。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">polymer-element</span> <span class="attr">name</span>=<span class="string">"x-form"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">"text"</span> <span class="attr">id</span>=<span class="string">"nameInput"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">    Polymer(<span class="string">'x-form'</span>, &#123;</div><div class="line">      <span class="attr">logNameValue</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.$.nameInput.value);</div><div class="line">      &#125;</div><div class="line">    &#125;);</div><div class="line">  <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">polymer-element</span>&gt;</span></div></pre></td></tr></table></figure>
<p>为了定位 element 的 shadow DOM 里的其它结点，你可以创建一个带有确定<code>id</code> 的容器 element，然后使用 querySelector 来获取子孙。举个例子，如果你的 element 的模板是下面这个样子：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"container"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span> <span class="attr">if</span>=<span class="string">"&#123;&#123;some_condition&#125;&#125;"</span>&gt;</span></div><div class="line">      <span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"inner"</span>&gt;</span></div><div class="line">        该内容通过数据绑定被创建</div><div class="line">      <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">div</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">template</span>&gt;</span></div></pre></td></tr></table></figure>
<p>你可以在容器内这样定位：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">this.$.container.querySelector('#inner');</div></pre></td></tr></table></figure>
<h3 id="触发自定义事件"><a href="#触发自定义事件" class="headerlink" title="触发自定义事件"></a>触发自定义事件</h3><p>Polymer core 提供了一个便捷的 fire() 方法传递自定义事件。实际上这是一个围绕标准的 node.dispatchEvent(new CustomEvent(…)) 包装出来的。当需要在一个微任务完成之后触发一个事件，请使用其异步的版本：asyncFire()。</p>
<p>例如：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span> <span class="attr">href</span>=<span class="string">"bower_components/polymer/polymer.html"</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">polymer-element</span> <span class="attr">name</span>=<span class="string">"ouch-button"</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">template</span>&gt;</span></div><div class="line">        <span class="tag">&lt;<span class="name">button</span> <span class="attr">on-click</span>=<span class="string">"&#123;&#123;onClick&#125;&#125;"</span>&gt;</span>GO<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line">    <span class="tag">&lt;/<span class="name">template</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript"></span></div><div class="line">        Polymer(<span class="string">'ouch-button'</span>, &#123;</div><div class="line">            onClick: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</div><div class="line">				<span class="comment">// fire(inType, inDetail, inToNode)</span></div><div class="line">                <span class="keyword">this</span>.fire(<span class="string">'ouch'</span>, &#123;</div><div class="line">                    msg: <span class="string">'hahaha'</span></div><div class="line">                &#125;);</div><div class="line">            &#125;</div><div class="line">        &#125;);</div><div class="line">    <span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">polymer-element</span>&gt;</span></div></pre></td></tr></table></figure>
<p>index.html</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"bower_components/platform/platform.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">    <span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"import"</span> <span class="attr">href</span>=<span class="string">"self_event_ref.html"</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">ouch-button</span>&gt;</span><span class="tag">&lt;/<span class="name">ouch-button</span>&gt;</span></div><div class="line"></div><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line">  <span class="built_in">document</span>.querySelector(<span class="string">'ouch-button'</span>).addEventListener(<span class="string">'ouch'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(e.type, e.detail.msg);</div><div class="line">  &#125;);</div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div><div class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></div></pre></td></tr></table></figure>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>中文站 <a href="http://docs.polymerchina.org/docs/start/getting-the-code.html" target="_blank" rel="external">polymerchina</a></li>
</ul>

	
	</div>
  <a type="button" href="/2015/01/03/2015-01-3-polymer/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-30 </div>
			<div class="article-title"><a href="/2014/12/30/2013-12-30-http学习札记/" >http学习札记</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动。所有报文的发送者都在接收者的上游。</p>
</blockquote>
<p>HTTP 报文是简单的格式化数据块。</p>
<p>报文块由三个部分组成：</p>
<pre><code>1. 对报文进行描述的起始行（start line）、 //  HTTP/1.0 200 OK
2. 包含属性的首部（header）块，{
    Content-type: text/plain
    Content-length: 100
}
3. 以及可选的、包含数据的主体（body）部分。(get 没有数据主体).
</code></pre><p>起始行和首部就是由行分隔的ASCII 文本。<br>每行都以一个由两个字符组成的行终止序列(CRLF, Carriage Return Line Feed)作为结束，其中包括一个回车符（ASCII 码13）和一个换行符（ASCII 码10）。</p>
<p>所有的HTTP 报文都可以分为两类： 请求报文（request message） 和响应报文（response message）。<code>本质就是 socket</code>。</p>
<ul>
<li>GET  从服务器获取一份文档        不包含主体</li>
<li>POST 向服务器发送需要处理的数据  包含主体 </li>
<li>HTTP 报文可以承载很多类型的数字数据：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等。</li>
<li>POST 方法起初是用来向服务器输入数据的.</li>
</ul>
<p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。<br>如果资源已被移动，可发送一个重定向状态码和一个可选的Location 首部来告知客户端资源已被移走，以及现在可以在哪里找到它。<br>浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了。(地址栏直接跳转).</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Remote</span> <span class="selector-tag">Address</span><span class="selector-pseudo">:128.121.66.211</span><span class="selector-pseudo">:80</span> (通过ip-&gt;dns查询来的)</div><div class="line"><span class="selector-tag">Request</span> <span class="selector-tag">URL</span><span class="selector-pseudo">:http</span>:<span class="comment">//www.joes-hardware.com/pet-products.txt</span></div><div class="line"><span class="selector-tag">Request</span> <span class="selector-tag">Method</span><span class="selector-pseudo">:GET</span></div><div class="line"><span class="selector-tag">Status</span> <span class="selector-tag">Code</span><span class="selector-pseudo">:301</span> <span class="selector-tag">Moved</span> <span class="selector-tag">Permanently</span></div><div class="line"><span class="selector-tag">RequestHeaders</span></div><div class="line"><span class="comment">// Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span></div><div class="line"><span class="comment">// Accept-Encoding:gzip,deflate,sdch</span></div><div class="line"><span class="comment">// Accept-Language:en,zh-CN;q=0.8,zh;q=0.6,ja;q=0.4</span></div><div class="line"><span class="comment">// Cache-Control:no-cache</span></div><div class="line"><span class="comment">// Connection:keep-alive</span></div><div class="line"><span class="comment">// DNT:1</span></div><div class="line"><span class="comment">// Host:www.joes-hardware.com</span></div><div class="line"><span class="comment">// Pragma:no-cache</span></div><div class="line"><span class="comment">// User-Agent:Mozilla/5.0</span></div><div class="line"></div><div class="line"><span class="selector-tag">ResonseHeaders</span></div><div class="line"><span class="comment">// Connection:Keep-Alive</span></div><div class="line"><span class="comment">// Content-Length:377</span></div><div class="line"><span class="comment">// Content-Type:text/html; charset=iso-8859-1</span></div><div class="line"><span class="comment">// Date:Wed, 01 Oct 2014 15:22:05 GMT</span></div><div class="line"><span class="comment">// Keep-Alive:timeout=15, max=98</span></div><div class="line"><span class="comment">// Location:http://www.gentle-grooming.com/</span></div><div class="line"><span class="comment">// Server:Apache/2.2.22 (Unix) DAV/2 FrontPage/5.0.2.2635 mod_ssl/2.2.22 OpenSSL/1.0.1h</span></div></pre></td></tr></table></figure>
<p>Location 用于跳转,在相应的 header 中直接提供了 Location 跳转的 url </p>
<p>301 Moved Permanently 在请求的URL 已被移除时使用。响应的Location 首部中应该包含资源现在所处的URL.</p>
<p>304 Not Modified 客户端可以通过所包含的请求首部，使其请求变成有条件的。<br>如果客户端发起了一个条件GET请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。<br>带有这个状态码的响应不应该包含实体的主体部分。</p>
<p>标识为no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。</p>
<p>HTTP/1.1 中提供Pragma: no-cache 首部是为了兼容于HTTP/1.0+。除了与只理解Pragma: no-cache 的HTTP/1.0 应用程序进行交互时，HTTP 1.1 应用程序都应该使用 Cache-Control: no-cache.</p>
<p>Cache-Control: max-age 首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数.</p>
<p>服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问的时候都进行刷新：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Cache</span><span class="params">-Control</span>: <span class="keyword">max</span><span class="params">-age</span>=<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>http-equiv 元信息告诉浏览器如何去做，等效于设置了HTTP 报头。<br>这让你可以向浏览器传达一些原本由服务器告诉它的内容。当你不能控制服务器时，它特别有用。 (这句话很有内容，请求网页使，服务器在响应头里是可以设置属性的，但是如果没有设置。同样也可以在 header 里设置上。效果一样。)</p>
<p>例如，如果你想设置一个缓存头，但又不能控制服务器，你可以使用http-equiv 属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"Wed, 05 August 2020 00:00:00 GMT"</span>&gt;</span>.</div></pre></td></tr></table></figure></p>
<p>http-equiv 属性是 http 协议的响应头报文，此属性出现在 meta 标签中。属性值用 content 属性描述当浏览器等设备接收服务器端传送的文件时，首先会接收文件的相关”(名称/值对)”，通常为多个。<br>所有服务器都至少要发送一个：<code>content-type:text/html</code>。这将告诉浏览器准备接受一个 HTML 文档。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5; url=http://www.a.com/"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>会产生：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Cache</span><span class="params">-Control</span>:<span class="keyword">max</span><span class="params">-age</span>=<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>no-store 在response 头中是为了声明不让浏览器 存储这次响应的信息。<br>max-age 这个声明过期时间的。单位为秒 0 肯定就是不缓存了。<br>两个选项对于Cache 系统来说。都是比较有用的。</p>
<p>关于 session，cookie，jsessionid 的关系。 session 就是 httpsession，服务器端的， cookie 就是浏览器端的。</p>
<p>在 servlet 里使用了</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpSession session</span> = request.getSession();</div><div class="line"><span class="attribute">String sessionid</span> = session.getId();</div></pre></td></tr></table></figure>
<p>获取了 session ，即使没有在 session 里设置数据，那么在响应里也会去设置 cookie。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">Server:</span>Apache-Coyote/<span class="number">1.1</span></div><div class="line">Set-<span class="string">Cookie:</span>JSESSIONID=<span class="number">3</span>B44FEAE6B662D94F4F23DD8EC2D2697; Path=<span class="regexp">/nodeA/</span>; HttpOnly</div></pre></td></tr></table></figure>
<p>并且有意思的是：如果在浏览器里把 cookie 删掉，那么下一次给服务器发请求，那么必然不会带着 cookie。所以服务器在没有 cookie 的请求中会在响应(因为没有把 cookie 中的 sessionid 带上，那么服务器认为这个客户端还没有对应的 session，于是发一个 session 给这个客户端，并且在返回响应的时候顺便设置在 cookie 上)的时候给带上 cookie（sessionid）。</p>
<p>如果客户端在请求的时候把 cookie(seessionid)带上了，那么服务器就不会在响应中设置 cookie 了。如果浏览器把 cookie 禁用了，那么新的 cookie 是存不到浏览器的，响应的时候带着 cookie 也不管用，存不上。  但是禁用cookie 后，浏览器中存储的囤积的还是可以发送出去的。 </p>
<p>那么问题来了，浏览器把 cookie 禁用了怎么办？ 请求的时候把 sessionid 存放到,貌似没有什么好办法，因为禁用 cookie，服务器的 sessionid 传不进来。在禁用 cookie 的情况下，taobao 登陆不上去，页面显示有问题。 amazon，jd 直接在登陆界面提示，不设置 cookie 登陆不进去。</p>
<p>首部 Referer 请求用户是从这个页面上依照链接跳转过来的. Referer 首部提供了用户来源页面的 URL。改动后包含了用户状态信息的URL 被称为胖URL（fat URL）。</p>
<p>可以笼统地将cookie 分为两类： 会话cookie 和持久cookie。会话cookie 是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。</p>
<p>持久cookie 的生存时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie 维护某个用户会周期性访问的站点的配置文件或登录名。</p>
<p>如果设置了Discard 参数，或者没有设置Expires 或Max-Age 参数来说明扩展的客户端识别与cookie机制过期时间，这个cookie 就是一个会话cookie。</p>
<p>浏览器会记住从服务器返回的Set-Cookie 或Set-Cookie2 首部中的cookie 内容，并将cookie 集存储在浏览器的 cookie 数据库中,将来用户返回同一站点时,浏览器会挑中那个服务器贴到用户上的那些cookie，并在一个cookie 请求首部中将其传回去。 </p>
<p>浏览器只向服务器发送服务器产生的那些cookie。(谁拿来的，再给谁拿回去)</p>
<p>版本 0 的Cookie首部客户端发送请求时，会将所有与域、路径和安全过滤器相匹配的未过期cookie 都发送给这个站点。<br>所有cookie 都被组合到一个Cookie 首部中：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: session-<span class="built_in">id</span>=<span class="number">002</span><span class="number">-1145265</span><span class="number">-8016838</span>; session-<span class="built_in">id</span>-<span class="built_in">time</span>=<span class="number">1007884800</span></div></pre></td></tr></table></figure>
<p>如果客户端既支持版本0 又支持版本1 的cookie，但从服务器获得的是版本0 的<br>Set-Cookie 首部，就应该带着版本0 的Cookie 首部发送cookie。</p>
<p>在绝大多数浏览器中，可以通过检测<br>navigator.cookieEnabled<br>这个属性实现。</p>
<p>但是为 false 也不代表不能用 cookie，只是表示不能使用持久化 cookie<br>“当前浏览会话生命周期” 的非持久化cookie仍然是启用的。</p>
<p>coookie 的作用域并不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。</p>
<p>一且设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p>
<p>默认情况下， cookie 和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。对其他目录的文件不可见，即使相同域名。如果把路径设置成”/“ , 那么该cookie对 ‘<a href="http://www.example.com`" target="_blank" rel="external">http://www.example.com`</a> 这台Web服务器上的页面都是可见的。</p>
<p>cookie的 path 属性不能被用做访问控制机制。如果一个Web页面想要读取同站点其他页面的cookie ，只要简单地将其他页面以隐藏<code>&lt;iframe&gt;</code>的形式加载进来，随后读取对应文档的cookie就可以了。同源策略限制了跨站的cookie窥探，但是对于同一站点的文档它是完全合法的。</p>
<p>有的大型网站想要子域之间能够互相共享 cookie. 比如， order.example.com 域下的服务器想要读取catalog.example.com域下设置的cookie值。这个时候就需要通过设置cookie的domain属性来达到目的.  比如设置 document.domain = “example.com”</p>
<p><strong> domain属性的默认值是当前Web服务器的主机名.</strong> 由于cookie的名/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用JavaScript核心的全局函数 encodeURIComponent() 对值进行编码。</p>
<p>处理 cookie 的技巧：</p>
<ul>
<li>要改变cookie的值，需要使用相同的名字、路径和域，再使新的值重新设置cookie 的值。</li>
<li>delete 将max-age属性指定为0 ，再次设置cookie 。</li>
<li>document.cookie // 返回所有作用在当前文档的所有 cookie ，多个 cookie 的集合的字符串形式。</li>
</ul>
<blockquote>
<p>  <code>RFC 2965</code> 规定 cookie 不超过300个，为每个Web服务器保存的cookie数不能超过20个,数据不能超过4KB, 现代浏览器允许 cookie 超过300个。</p>
</blockquote>
<p>要给当前文档设置 cookie 值，非常简单，只须将cookie属性设置为一个字符串形式的值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie=<span class="string">'name_self=abc'</span>;</div><div class="line"><span class="built_in">document</span>.cookie=<span class="string">'name_self=abc;max-age=10'</span>; <span class="comment">// 10秒后过期</span></div><div class="line"><span class="built_in">document</span>.cookie=<span class="string">"name_self=abc;max-age=10;path='/path';domain='http://.domain.com';"</span>; <span class="comment">// 10秒后过期,由于设置了 domain 不限于 domain.com/path/xx  path 目录及其子目录的访问，其他子域名也可访问 cookie。</span></div></pre></td></tr></table></figure>
<p>IE5 以及 IE5 以上版本的浏览器是通过在document元素后面附加一个专属的”DHTML行为”来实现客户端存储的。<br>如  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!--[<span class="keyword">if</span> IE]&gt;</div><div class="line"></div><div class="line">memory.style.behavior = <span class="string">"url('#default#userData')"</span> </div><div class="line"></div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
<p>附加userData行为。</p>
<h3 id="网络相关的长度问题"><a href="#网络相关的长度问题" class="headerlink" title="网络相关的长度问题"></a>网络相关的长度问题</h3><p>Http  Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。<br>IE     限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。<br>Firefox 对于Firefox浏览器URL的长度限制为 65536 个字符。<br>Safari  URL最大长度限制为 80000 个字符。<br>Opera   URL最大长度限制为 190000 个字符。<br>Google  URL最大长度限制为 8182 个字符。<br>Apache  能接受最大url长度为 8192 个字符。</p>
<p>Post 长度限制<br>在Tomcat下取消POST大小的限制（Tomcat默认2M）；<br>打开tomcat目录下的conf目录，打开server.xml 文件，修改maxPostSize</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- &lt;meta http-equiv="refresh" content="5" /&gt; --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"10;url=http://baidu.com"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 10表示10秒，0即为立即跳转 --&gt;</span></div></pre></td></tr></table></figure>
<h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><p>首先，浏览器需要知道该网站的IP 地址。它向DNS 服务器发送一个包含域名的请求， 然后DNS 服务器返回给<code>浏览器</code>对应的IP 地址。为了减少DNS 服务器上的负载，并提高性能，DNS 查找机制会被浏览器、设备或设备和服务器之间的路由器和代理服务器缓存。这就是为什么更改DNS 记录可能需要几天才能生效的原因。</p>
<h3 id="浏览器是如何显示页面的？"><a href="#浏览器是如何显示页面的？" class="headerlink" title="浏览器是如何显示页面的？"></a>浏览器是如何显示页面的？</h3><ol>
<li>发起请求 </li>
<li>ip地址 返回给浏览器。</li>
<li><p>然后，浏览器会向由DNS 查找得到的IP 地址的主机发起TCP 连接。然后发送请求。<code>Remote Address:106.38.179.49:80</code>, 请求中包含网址、浏览器信息、浏览器能接受的数据类型（编码和语言），以及所有相关的cookie，包括域和路径的cookie。</p>
</li>
<li><p>发起请求, 浏览器开始下载响应。随着响应流到达，浏览器解析HTML 并识别出更多的资源。然后浏览器开始获取这些资源。</p>
</li>
<li><p>渲染页面,最后浏览器会尽快开始渲染页面。如果页面中外链了CSS 或脚本文件时，浏览器会等到这些文件加载和解析（如果是JavaScript 代码，则还需要执行）完再渲染页面。</p>
</li>
</ol>
<h3 id="为什么页面加载缓慢？"><a href="#为什么页面加载缓慢？" class="headerlink" title="为什么页面加载缓慢？"></a>为什么页面加载缓慢？</h3><p>为什么页面加载缓慢？以下是可能的原因：</p>
<ul>
<li>HTTP 连接数</li>
<li>总的字节数</li>
<li>等待时的渲染阻塞</li>
<li>延迟</li>
<li>缓存能力差</li>
</ul>
<p>我们先把重点放在“网络”选项卡上，它有一个美丽的瀑布图，向我们展示了页面加载时的各种信息。<br>每一栏上的浅色代表的延迟，深色代表下载。</p>
<p>iOS 上的Safari 浏览器支持同一域下的最多 6 个资源并行下载。<br>虽然可以通过添加额外的域名（也许是通过设置别名或子域名）的方式来并行下载更多的文件，但每次请求还是需要承担HTTP 层面的开销。</p>
<p>对于图片，因为下载占到了请求时间的绝大部分，所以并行下载更好。出于这个原因（以及一些其他的原因），在网站上将图像与其他资源置于不同的域下是合理的。<br>(对图片设置 cookie 是完全没有必要的，所以最好给图片单独提供一个域名,可能放在专用的图片服务器上了)</p>
<p>雅虎的Steve Souders 和YSlow 团队发现，为当前域创建两个别名，能允许更多的下载并行，会使大文件下载的性能明显改善。</p>
<p>它的第一次加载必然比部署在多个域下的慢。不过由于每个域都需要进行DNS 查找， 添加太多的域反而会更慢。<br>使用至少两个，至多不超过五个域是YSlow 的经验法则。</p>
<p>如果一个 cookie 与请求的域名或路径相匹配，它会伴随着每次请求发送（即上传）。 所以，如果你在你的域名下的第一个请求中设置了几千字节的cookie，那么此后发送到这个域的每次请求都将把这些字节包含在请求头里，然后发送、解压缩。</p>
<p>服务器还必须在读取请求体之前读取这些cookie。cookie 可以把一个很小的请求变得很大。</p>
<p>高延迟使因请求量大而导致的问题激增，因为每次请求都因延迟增加了往返的时间。</p>
<p>对于低流量的网站 CDN 的帮助不大。 不过，把你的静态文件放在一个单独的没有 cookie 的域下总是有帮助的。<br>所以，如果有条件，务必做到这一点。 如果一个 cookie 与请求的域名或路径相匹配，它会伴随每次请求发送。 所以如果你在你的域名下的第一个请求。 （这里说第一个请求是有原因的，因正常情况下后续的服务器响应是不会再次设置 cookie 的。 没有必要在重新设置。 除非在每次服务器响应的时候强制在 response 里设置了 cookie， 这样才可能在每次的响应头中看到 set-cookie。 酱紫。）</p>
<p>设置了几千个字节的 cookie，那么此后发送到这个域的每次请求都会把这些 cookie 包含在请求头中带回去, 导致 cookie 很耗费资源。</p>
<p>另一个有价值的工具是 Charles proxy（Charlesproxy.com）。<br>Charles 是一个本地工具，能让你检查每一个请求，给请求添加断点，还可以模拟低带宽环境。<br>当开发工具没有给出关于HTTP 的更多信息时，Charles 可以帮助你。</p>
<p>pageSpeed 把规则划分为六类：</p>
<ul>
<li>缓存优化，使页面的应用逻辑实现和所需数据一并离线缓存。</li>
<li>往返时间最小化，减少请求响应的周期次数。</li>
<li>请求开销最小化，减少上传数据包大小，（数据包，cookie 在 header 里）</li>
<li>有效负载最小化，减少响应包，下载包和缓存页面的大小。(压缩,图像压缩)</li>
<li>浏览器渲染优化，改进浏览器的页面布局。</li>
<li>移动设备优化，为移动而优化。</li>
</ul>
<blockquote>
<p>对移动端建议：“”延迟 javasript 解析(不必要的 js 不要放在 header)”+“”使首页的重定向可缓存”</p>
</blockquote>
<p>link 标签上的关于媒体查询的css文件，即使查询的结果不合适，也还是会下载的。只不过是不用。</p>
<h2 id="XSS-的防御-输入框验证"><a href="#XSS-的防御-输入框验证" class="headerlink" title="XSS 的防御(输入框验证)"></a>XSS 的防御(输入框验证)</h2><h3 id="什么是-XSS-（cross-site-script）"><a href="#什么是-XSS-（cross-site-script）" class="headerlink" title="什么是 XSS （cross site script）"></a>什么是 XSS （cross site script）</h3><p>为了防止与层叠样式表css混淆，改为 xss； 通常表现为通过输入框插入非法脚本，获取其他用户安全信息。</p>
<p>HTTPOnly ，一个成熟的标准， 浏览器将禁止页面中的 js 访问带有 HTTPOnly 属性的 cookie。<br>IE 6 和 其他现代浏览器均已支持这个标准。所以，HttpOnly 不是用于对抗 XSS，它是用于在 XSS 攻击后，防护 cookie 被读取，从而使大部分 XSS 攻击失去了意义。</p>
<h3 id="一个-cookie-使用的过程大概是这样的："><a href="#一个-cookie-使用的过程大概是这样的：" class="headerlink" title="一个 cookie 使用的过程大概是这样的："></a>一个 cookie 使用的过程大概是这样的：</h3><ol>
<li>浏览器像服务器发起请求，这时没有设置 cookie。</li>
<li>服务器返回发送 Set-Cookie Header， 向客户端浏览器写入 Cookie。</li>
<li>在 cookie 到期前，浏览器发起的所有的请求(即使 ajax，图片)，都会在请求头里写入 cookie。</li>
</ol>
<p>HttpOnly的使用是十分灵活的，它可以只用在最核心的位置。 比如我们的应用中会设置多个 cookie，而 HttpOnly 可以有选择的加在关键 cookie上，实施关键目标重点保护。</p>
<p>给 Cookie 添加 HttpOnly 的代码：</p>
<p>java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Java:</div><div class="line">		Cookie coki1 = new Cookie("get_acookie_1", "acookieValue");</div><div class="line">		response.addCookie(coki1);</div><div class="line">		Cookie coki2 = new Cookie("get_acookie_2", "acookieValue");</div><div class="line">        // Cookie coki2 = new Cookie("get_acookie_2", "acookieValue;HTTPOnly"); // 这样不管用 </div><div class="line">		coki2.setHttpOnly(true); // ok</div><div class="line">		response.addCookie(coki2);</div><div class="line">C#:</div><div class="line">		HttpCookie ck = new HttpCookie('myCookie');</div><div class="line">		ck.HttpOnly = true;</div><div class="line">		Response.AppendCookie(ck);</div></pre></td></tr></table></figure>
<h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>XSS 攻击一般都是在输入框等输入位置输入一些由特殊字符组成的攻击脚本。</p>

	
	</div>
  <a type="button" href="/2014/12/30/2013-12-30-http学习札记/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-28 </div>
			<div class="article-title"><a href="/2014/12/28/2014-12-28-http协议相关知识整理/" >http协议相关知识整理</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>##连接</p>
<p>在HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP） 地址和端口号在客户端和服务器之间建立一条TCP/IP 连接。<br>HTTP 连接实际上就是TCP 连接及其使用规则。TCP 连接是因特网上的可靠连接。TCP 为HTTP 提供了一条可靠的比特传输管道。从TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。</p>
<p>浏览器访问服务器的过程：</p>
<ol>
<li>浏览器解析出主机名</li>
<li>浏览器查询这个主机名的IP地址（DNS）</li>
<li>浏览器获得端口号（80）</li>
<li>浏览器发起到 x.x.x.x 端口 xx 的连接</li>
<li>浏览器向服务器发送一条HTTP GET报文</li>
<li>浏览器从服务器读取HTTP响应报文</li>
</ol>
<p>HTTP 事务的时延有以下几种主要原因:</p>
<ol>
<li>客户端首先需要根据URI 确定Web 服务器的IP 地址和端口号。如果最近没有对 URI 中的主机名进行访问，通过DNS 解析系统将URI 中的主机名转换成一个IP 地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP 连接请求，并等待服务器回送一个请 求接受应答。每条新的TCP 连接都会有连接建立时延。这个值通常最多只有一 两秒钟，但如果有数百个HTTP 事务的话，这个值会快速地叠加上去。</li>
<li>一旦连接建立起来了，客户端就会通过新建立的TCP 管道来发送HTTP 请求。 数据到达时，Web 服务器会从TCP 连接中读取请求报文，并对请求进行处理</li>
</ol>
<p>大多数HTTP 客户端都有一个小的DNS 缓存，用来保存近期所访问站点的IP 地址。如果 已经在本地“缓存”（记录）了IP 地址，查询就可以立即完成。因为大多数Web 浏览器浏览的都是少数常用站点，所以通常都可以很快地将主机名解析出来。</p>

	
	</div>
  <a type="button" href="/2014/12/28/2014-12-28-http协议相关知识整理/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-27 </div>
			<div class="article-title"><a href="/2014/12/27/2014-12-27-brick/" >brick</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>先占坑。。<br><a href="https://mozbrick.github.io/blog/" target="_blank" rel="external">https://mozbrick.github.io/blog/</a></p>

	
	</div>
  <a type="button" href="/2014/12/27/2014-12-27-brick/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-25 </div>
			<div class="article-title"><a href="/2014/12/25/2014-12-25-git/" >git</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>#分布式版本管理的优点</p>
<p>最初的克隆时间较长,特别是历史记录很长的时候,但最终这个本地镜像备份会带来很多优势.一个显而易见的好处是,当产看一个旧版本时不需要和中心服务器通信.</p>
<h1 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h1><h2 id="git-文件的三种状态"><a href="#git-文件的三种状态" class="headerlink" title="git 文件的三种状态"></a>git 文件的三种状态</h2><ol>
<li>暂存 staged </li>
<li>修改 modify</li>
<li>已提交</li>
</ol>
<p>记录当前状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"my commit description"</span></div></pre></td></tr></table></figure></p>
<p>回退原来编辑的地方,会退到上次版本提交后的最初状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard</div></pre></td></tr></table></figure></p>
<p>操作是针对本地版本库中已存在文件的操作, 针对已存在本地版本的文件的修改会完全回退,不管是否已经 <code>git add</code>过,<br>针对新加入的文件, add 之前的文件不会删除掉(untracked file: 尚未加入版本控制), add 之后的文件会被抹掉.</p>
<p>git add 操作开始跟踪文件,但是还没有提交版本库, 类似 hibernate 中的持久态, 具有 id,具有 session 管理.<br>在 commit 之前还没有进入到托管的游离态(所以只有 commit 之前可以进行 git reset 操作).<br>add 之前的文件可以看作是 transient 瞬态, 通过 git add 便把无管理的文件进入到持久态, 受到 git 管控.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add NEWFILES</div></pre></td></tr></table></figure>
<p>删除, 将文件从本地目录，缓存区中删除,提交后才会在本地仓库中删除。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git</span> rm OLDFILES <span class="comment">#</span></div></pre></td></tr></table></figure>
<p>重命名, 不能进行无版本控制的文件,git 还管控不到</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">mv</span> OLDFILES NEWFILES</div></pre></td></tr></table></figure>
<p>看日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span></div></pre></td></tr></table></figure>
<p>彻底恢复到指定版本,并且从记录里永久删除掉所有的后续记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="comment">--hard SHA1_HASH</span></div></pre></td></tr></table></figure>
<p>简单的恢复到以前的某个状态,穿越回去还能回来:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git</span> checkout SHA1_HASH</div></pre></td></tr></table></figure>
<p>checkout 可以回到过去,并且可以保存在过去状态上的更改.但这会开辟新的分支.</p>
<p>回到现实</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="literal">master</span></div></pre></td></tr></table></figure>
<h2 id="处理分支"><a href="#处理分支" class="headerlink" title="处理分支"></a>处理分支</h2><p>查看分支<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git branch</span></div></pre></td></tr></table></figure></p>
<p>建立分支<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -<span class="selector-tag">b</span> branchName</div></pre></td></tr></table></figure></p>
<p>关于建立分支,实质上是 checkout 到一个某个状态后, git 自动把你放到一个新的,未命名的分支,<br>这个分支可以用<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -<span class="selector-tag">b</span> branchName</div></pre></td></tr></table></figure></p>
<p>进行对该分支命名.</p>
<p>回到主分支<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="literal">master</span></div></pre></td></tr></table></figure></p>
<p>切换到某分支<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git checkout someBranch</span></div></pre></td></tr></table></figure></p>
<p>使用分支工作</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git checkout -b draft  <span class="comment"># 建立分支</span></div><div class="line"><span class="built_in">do</span> some work <span class="keyword">in</span> <span class="keyword">the</span> branch: draft <span class="keyword">and</span> commmit  <span class="comment"># 在分支上工作</span></div><div class="line">git checkout master <span class="comment"># 回到分支 master</span></div><div class="line">git <span class="built_in">merge</span> draft <span class="comment"># 将 draft 分支所做更改合并到主分支</span></div><div class="line">git branch -d draft <span class="comment"># 不再需要这个分支</span></div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/12/25/2014-12-25-git/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-02 </div>
			<div class="article-title"><a href="/2014/12/02/2014-12-02-纯对象事件/" >js 纯对象事件</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>如果给单纯的对象加入事件,怎么做?</p>
</blockquote>
<p>我想到了 jQ, addEventListener, emmit …<br>惭愧！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PubSub = &#123;</div><div class="line">	<span class="attr">subscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">ev, callback</span>) </span>&#123;</div><div class="line">		<span class="comment">// 创建 _callbacks 对象,除非已有</span></div><div class="line">		<span class="keyword">var</span> calls = <span class="keyword">this</span>._callbacks || (<span class="keyword">this</span>._callbacks = &#123;&#125;);</div><div class="line">		(<span class="keyword">this</span>._callbacks[ev] || (<span class="keyword">this</span>._callbacks[ev] = [])).push(callback);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">publish</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">0</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 拿出第一个参数, 因为第一个参数用于事件名称</span></div><div class="line">		<span class="keyword">var</span> ev = args.shift();</div><div class="line"></div><div class="line">		<span class="keyword">var</span> list, calls, i, lst;</div><div class="line">		<span class="comment">// 不存在该事件,则返回</span></div><div class="line">		<span class="keyword">if</span> (!(calls = <span class="keyword">this</span>._callbacks)) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">if</span> (!(list = <span class="keyword">this</span>._callbacks[ev])) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"></div><div class="line">		<span class="keyword">for</span>( i = <span class="number">0</span>, lst = list.length; i &lt; lst; i++ ) &#123;</div><div class="line">			list[i].apply(<span class="keyword">this</span>, args);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/12/02/2014-12-02-纯对象事件/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-16 </div>
			<div class="article-title"><a href="/2014/11/16/2014-11-16-deferred/" >jQueryDeferred对象</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>deferred对象代表了将要完成的某种操作，并提供了一些方法，帮助用户使用。它是jQuery对Promises接口的实现。jQuery的所有Ajax操作函数，默认返回的就是一个deferred对象。</p>
<p>简单说，Promises是异步操作的通用接口，扮演代理人（proxy）的角色，将异步操作包装成具有同步操作特性的特殊对象。异步操作的典型例子就是Ajax操作、网页动画、web worker等等。</p>
<p>由于JavaScript单线程的特点，如果某个操作耗时很长，其他操作就必需排队等待。为了避免整个程序失去响应，通常的解决方法是将那些排在后面的操作，写成“回调函数”（callback）的形式。这样做虽然可以解决问题，但是有一些显著缺点：</p>
<ul>
<li>回调函数往往写成函数参数的形式，形成所谓的“持续传递风格”（即参数就是下一步操作，Continuation-passing style），导致函数的输入和输出非常混乱，整个程序的可阅读性差；</li>
<li>回调函数往往只能指定一个，如果有多个操作，就需要改写回调函数。</li>
<li>除了正常的报错机制，错误还可能通过回调函数的形式返回，增加了除错和调试的难度。</li>
<li>正常的函数输入和输出可以区分得很清楚，回调函数使得函数的输出不再重要。</li>
</ul>
<p>Promises就是为了解决这些问题而提出的，它的主要目的就是取代回调函数，成为非同步操作的解决方案。它的核心思想就是让非同步操作返回一个对象，其他操作都针对这个对象来完成。比如，假定ajax操作返回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> promise = get(<span class="string">'http://www.example.com'</span>);</div></pre></td></tr></table></figure>
<p>然后，Promise对象有一个then方法，可以用来指定回调函数。一旦非同步操作完成，就调用指定的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(content)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以将上面两段代码合并起来，这样程序的流程看得更清楚。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">get(<span class="string">'http://www.example.com'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(content)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在1.5版之前，jQuery的Ajax操作采用回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>:<span class="string">"/echo/json/"</span>,</div><div class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></div><div class="line">    &#123;</div><div class="line">       <span class="built_in">console</span>.info(response.name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>1.5版之后，Ajax操作直接返回Promise对象，这意味着可以用then方法指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">"/echo/json/"</span>,</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(response.name);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="deferred对象的方法"><a href="#deferred对象的方法" class="headerlink" title="deferred对象的方法"></a>deferred对象的方法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>（1）生成deferred对象</strong></p>
<p>第一步是通过$.Deferred()方法，生成一个deferred对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> deferred = $.Deferred();</div></pre></td></tr></table></figure>
<p><strong>（2）deferred对象的状态</strong></p>
<p>deferred对象有三种状态。</p>
<ul>
<li>pending：表示操作还没有完成。</li>
<li>resolved：表示操作成功。</li>
<li>rejected：表示操作失败。</li>
</ul>
<p>state方法用来返回deferred对象当前状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.Deferred().state() <span class="comment">// 'pending'</span></div><div class="line">$.Deferred().resolve().state() <span class="comment">// 'resolved'</span></div><div class="line">$.Deferred().reject().state() <span class="comment">// 'rejected'</span></div></pre></td></tr></table></figure>
<p><strong>（3）改变状态的方法</strong></p>
<p>resolve方法将deferred对象的状态从pending改为resolved，reject方法则将状态从pending改为rejected。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> deferred = $.Deferred();</div><div class="line"></div><div class="line">deferred.resolve(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure>
<p>resolve方法的参数，用来传递给回调函数。</p>
<p><strong>（4）绑定回调函数</strong></p>
<p>deferred对象在状态改变时，会触发回调函数。 </p>
<p>done方法指定状态变为resolved（操作成功）时的回调函数；fail方法指定状态变为rejected（操作失败）时的回调函数；always方法指定，不管状态变为resolved或rejected，都会触发的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> deferred = $.Deferred();</div><div class="line"></div><div class="line">deferred.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).resolve(<span class="string">'hello world'</span>);</div><div class="line"><span class="comment">// hello world</span></div></pre></td></tr></table></figure>
<p>上述三种方法都返回的原有的deferred对象，因此可以采用链式写法，在后面再链接别的方法（包括done和fail在内）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.Deferred().done(f1).fail(f2).always(f3);</div></pre></td></tr></table></figure>
<h3 id="notify-和-progress"><a href="#notify-和-progress" class="headerlink" title="notify() 和 progress()"></a>notify() 和 progress()</h3><p>progress()用来指定一个回调函数，当调用notify()方法时，该回调函数将执行。它的用意是提供一个接口，使得在非同步操作执行过程中，可以执行某些操作，比如定期返回进度条的进度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> userProgress = $.Deferred();</div><div class="line">   <span class="keyword">var</span> $profileFields = $(<span class="string">"input"</span>);</div><div class="line">   <span class="keyword">var</span> totalFields = $profileFields.length</div><div class="line">       </div><div class="line">   userProgress.progress(<span class="function"><span class="keyword">function</span> (<span class="params">filledFields</span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> pctComplete = (filledFields/totalFields)*<span class="number">100</span>;</div><div class="line">       $(<span class="string">"#progress"</span>).html(pctComplete.toFixed(<span class="number">0</span>));</div><div class="line">   &#125;); </div><div class="line"></div><div class="line">   userProgress.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       $(<span class="string">"#thanks"</span>).html(<span class="string">"Thanks for completing your profile!"</span>).show();</div><div class="line">   &#125;);</div><div class="line">   </div><div class="line">   $(<span class="string">"input"</span>).on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> filledFields = $profileFields.filter(<span class="string">"[value!='']"</span>).length;</div><div class="line">       userProgress.notify(filledFields);</div><div class="line">       <span class="keyword">if</span> (filledFields == totalFields) &#123;</div><div class="line">           userProgress.resolve();</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
<h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p><strong>（1）概述</strong></p>
<p>then方法的作用也是指定回调函数，它可以接受三个参数，也就是三个回调函数。第一个参数是resolve时调用的回调函数（相当于done方法），第二个参数是reject时调用的回调函数（相当于fail方法），第三个参数是progress()方法调用的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">deferred.then( doneFilter [, failFilter ] [, progressFilter ] )</div></pre></td></tr></table></figure>
<p><strong>（2）返回值</strong></p>
<p>在jQuery 1.8之前，then()只是.done().fail()写法的语法糖，两种写法是等价的。在jQuery 1.8之后，then()返回一个新的promise对象，而done()返回的是原有的deferred对象。如果then()指定的回调函数有返回值，该返回值会作为参数，传入后面的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> defer = jQuery.Deferred();</div><div class="line"></div><div class="line">defer.done(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> a * b;</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a * b;</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a * b;</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">defer.resolve( <span class="number">2</span>, <span class="number">3</span> );</div></pre></td></tr></table></figure>
<p>在jQuery 1.8版本之前，上面代码的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">result = <span class="number">2</span> </div><div class="line">result = <span class="number">2</span> </div><div class="line">result = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在jQuery 1.8版本之后，返回结果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">result = <span class="number">2</span> </div><div class="line">result = <span class="number">6</span> </div><div class="line">result = <span class="literal">NaN</span></div></pre></td></tr></table></figure>
<p>这一点需要特别引起注意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.ajax( url1, &#123; <span class="attr">dataType</span>: <span class="string">"json"</span> &#125; )</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $.ajax( url2, &#123; <span class="attr">data</span>: &#123; <span class="attr">user</span>: data.userId &#125; &#125; );</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">  <span class="comment">// 从url2获取的数据</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码最后那个done方法，处理的是从url2获取的数据，而不是从url1获取的数据。</p>
<p><strong>（3）对返回值的修改</strong></p>
<p>利用then()会修改返回值这个特性，我们可以在调用其他回调函数之前，对前一步操作返回的值进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> post = $.post(<span class="string">"/echo/json/"</span>)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> p.firstName;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">post.done(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123; <span class="built_in">console</span>.log(r); &#125;);</div></pre></td></tr></table></figure>
<p>上面代码先使用then()方法，从返回的数据中取出所需要的字段（firstName），所以后面的操作就可以只处理这个字段了。</p>
<p>有时，Ajax操作返回json字符串里面有一个error属性，表示发生错误。这个时候，传统的方法只能是通过done()来判断是否发生错误。通过then()方法，可以让deferred对象调用fail()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> myDeferred = $.post(<span class="string">'/echo/json/'</span>, &#123;<span class="attr">json</span>:<span class="built_in">JSON</span>.stringify(&#123;<span class="string">'error'</span>:<span class="literal">true</span>&#125;)&#125;)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (response.error) &#123;</div><div class="line">                <span class="keyword">return</span> $.Deferred().reject(response);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> response;</div><div class="line">        &#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> $.Deferred().reject(&#123;<span class="attr">error</span>:<span class="literal">true</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">myDeferred.done(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">        $(<span class="string">"#status"</span>).html(<span class="string">"Success!"</span>);</div><div class="line">    &#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">        $(<span class="string">"#status"</span>).html(<span class="string">"An error occurred"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，不管是通信出错，或者服务器返回一个错误，都会调用reject方法，返回一个新的deferred对象，状态为rejected，因此就会触发fail方法指定的回调函数。</p>
<p>关于error的处理，jQuery的deferred对象与其他实现Promises规范的函数库有一个重大不同。就是说，如果deferred对象执行过程中，抛出一个非Promises对象的错误，那么将不会被后继的then方法指定的rejected回调函数捕获，而会一直传播到应用程序层面。为了代码行为与Promises规范保持一致，建议出错时，总是使用reject方法返回错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">d = $.Deferred()  </div><div class="line">d.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>)</div><div class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fail'</span>)</div><div class="line">&#125;)</div><div class="line">d.resolve()</div><div class="line"><span class="comment">// Error: err</span></div></pre></td></tr></table></figure>
<p>上面代码中，then的回调函数抛出一个错误，按照Promises规范，应该被fail方法的回调函数捕获，但是jQuery的部署是上升到应用程序的层面。</p>
<p><strong>（4）回调函数的返回值</strong></p>
<p>如果回调函数返回deferred对象，则then方法的返回值将是对应这个返回值的promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> d1 = $.Deferred();</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = $.when(<span class="string">'Hello'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;  </div><div class="line">  <span class="keyword">return</span> $.when(h,d1);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">promise.done(<span class="function"><span class="keyword">function</span> (<span class="params">s1,s2</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(s1);</div><div class="line">	<span class="built_in">console</span>.log(s2);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">d1.resolve(<span class="string">'World'</span>)</div><div class="line"><span class="comment">// Hello</span></div><div class="line"><span class="comment">// World</span></div></pre></td></tr></table></figure>
<p>上面代码中，done方法的回调函数，正常情况下只能接受一个参数。但是由于then方法的回调函数，返回一个when方法生成的deferred对象，导致它可以接受两个参数。</p>
<h3 id="pipe方法"><a href="#pipe方法" class="headerlink" title="pipe方法"></a>pipe方法</h3><p>pipe方法接受一个函数作为参数，表示在调用then方法、done方法、fail方法、always方法指定的回调函数之前，先运行pipe方法指定的回调函数。它通常用来对服务器返回的数据做初步处理。</p>
<h3 id="与Promise-A-规格的差异"><a href="#与Promise-A-规格的差异" class="headerlink" title="与Promise A+规格的差异"></a>与Promise A+规格的差异</h3><p>Promise事实上的标准是社区提出的Promise A+规格，jQuery的实现并不完全符合Promise A+，主要是对错误的处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> promise2 = promise1.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码在回调函数中抛出一个错误，Promise A+规定此时Promise实例的状态变为reject，该错误被下一个catch方法指定的回调函数捕获。但是，jQuery的Deferred对象此时不会改变状态，亦不会触发回调函数，该错误一般情况下会被window.onerror捕获。换句话说，在Deferred对象中，总是必须使用reject方法来改变状态。</p>
<h2 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h2><p><strong>（1）概念</strong></p>
<p>一般情况下，从外部改变第三方完成的异步操作（比如Ajax）的状态是毫无意义的。为了防止用户这样做，可以在deferred对象的基础上，返回一个针对它的promise对象。</p>
<p>简单说，promise对象就是不能改变状态的deferred对象，也就是deferred的只读版。或者更通俗地理解成，promise是一个对将要完成的任务的承诺，排除了其他人破坏这个承诺的可能性，只能等待承诺方给出结果。</p>
<p>你可以通过promise对象，为原始的deferred对象添加回调函数，查询它的状态，但是无法改变它的状态，也就是说<strong>promise对象不允许你调用resolve和reject方法</strong>。</p>
<p><strong>（2）生成promise对象</strong></p>
<p>deferred对象的promise方法，用来生成对应的promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> $.Deferred().promise();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    getPromise().resolve(<span class="string">"a"</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">&#125;</div><div class="line"><span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<p>上面代码对promise对象，调用resolve方法，结果报错。</p>
<p>jQuery的ajax() 方法返回的就是一个promise对象。此外，Animation类操作也可以使用promise方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(<span class="string">'body'</span>).toggle(<span class="string">'blinds'</span>).promise().then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $(<span class="string">'body'</span>).toggle(<span class="string">'blinds'</span>)</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h2><p>deferred对象还有一系列辅助方法，使它更方便使用。</p>
<h3 id="when-方法"><a href="#when-方法" class="headerlink" title="$.when()方法"></a>$.when()方法</h3><p>$.when()接受多个deferred对象作为参数，当它们全部运行成功后，才调用resolved状态的回调函数，但只要其中有一个失败，就调用rejected状态的回调函数。它相当于将多个非同步操作，合并成一个。实质上，when方法为多个deferred对象，返回一个单一的promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.when(</div><div class="line">    $.ajax( <span class="string">"/main.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/modules.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/lists.php"</span> )</div><div class="line">).then(successFunc, failureFunc);</div></pre></td></tr></table></figure>
<p>上面代码表示，要等到三个ajax操作都结束以后，才执行then方法指定的回调函数。</p>
<p>when方法里面要执行多少个操作，回调函数就有多少个参数，对应前面每一个操作的返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.when(</div><div class="line">    $.ajax( <span class="string">"/main.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/modules.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/lists.php"</span> )</div><div class="line">).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp1, resp2, resp3</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(resp1);</div><div class="line">	<span class="built_in">console</span>.log(resp2);</div><div class="line">	<span class="built_in">console</span>.log(resp3);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的回调函数有三个参数，resp1、resp2和resp3，依次对应前面三个ajax操作的返回结果。</p>
<p>如果when方法的参数不是deferred或promise对象，则直接作为回调函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">d = $.Deferred()  </div><div class="line">$.when(d, <span class="string">'World'</span>).done(<span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(s1);</div><div class="line">	<span class="built_in">console</span>.log(s2);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">d.resolve(<span class="string">'Hello'</span>) </div><div class="line"><span class="comment">// Hello </span></div><div class="line"><span class="comment">// World</span></div></pre></td></tr></table></figure>
<p>上面代码中，when的第二个参数是一个字符串，则直接作为回调函数的第二个参数。</p>
<p>此外，如果when方法的参数都不是deferred或promise对象，那么when方法的回调函数将立即运行。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><p>我们可以用deferred对象写一个wait方法，表示等待多少毫秒后再执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.wait = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params">dfd</span>) </span>&#123;</div><div class="line">    setTimeout(dfd.resolve, time);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.wait(<span class="number">5000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello from the future!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="改写setTimeout"><a href="#改写setTimeout" class="headerlink" title="改写setTimeout"></a>改写setTimeout</h3><p>在上面的wait方法的基础上，还可以改写setTimeout方法，让其返回一个deferred对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingLater</span>(<span class="params">fn, time</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    dfd.resolve(fn());</div><div class="line">  &#125;, time || <span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> dfd.promise();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = doSomethingLater(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">'已经延迟执行'</span> );</div><div class="line">&#125;, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<h3 id="自定义操作使用deferred接口"><a href="#自定义操作使用deferred接口" class="headerlink" title="自定义操作使用deferred接口"></a>自定义操作使用deferred接口</h3><p>我们可以利用deferred接口，使得任意操作都可以用done()和fail()指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Twitter = &#123;</div><div class="line">  <span class="attr">search</span>:<span class="function"><span class="keyword">function</span>(<span class="params">query</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">    $.ajax(&#123;</div><div class="line">     <span class="attr">url</span>:<span class="string">"http://search.twitter.com/search.json"</span>,</div><div class="line">     <span class="attr">data</span>:&#123;<span class="attr">q</span>:query&#125;,</div><div class="line">     <span class="attr">dataType</span>:<span class="string">'jsonp'</span>,</div><div class="line">     <span class="attr">success</span>:dfd.resolve</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> dfd.promise();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Twitter.search(<span class="string">'javaScript'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  alert(data.results[<span class="number">0</span>].text);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>deferred对象的另一个优势是可以附加多个回调函数。下面的例子使用了上面所改写的setTimeout函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    dfd.reject(<span class="string">"Sorry, something went wrong."</span>);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dfd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">doSomething(<span class="string">"uh oh"</span>).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Won't happen, we're erroring here!"</span>);</div><div class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Matt Baker, <a href="http://eng.wealthfront.com/2012/12/jquerydeferred-is-most-important-client.html" target="_blank" rel="external">jQuery.Deferred is the most important client-side tool you have</a></li>
<li><a href="http://www.intridea.com/blog/2011/2/8/fun-with-jquery-deferred" target="_blank" rel="external">Fun With jQuery Deferred</a></li>
<li>Bryan Klimt, <a href="http://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/" target="_blank" rel="external">What’s so great about JavaScript Promises?</a></li>
<li>José F. Romaniello, <a href="http://joseoncode.com/2011/09/26/a-walkthrough-jquery-deferred-and-promise/" target="_blank" rel="external">Understanding JQuery.Deferred and Promise</a></li>
<li>Julian Aubourg, Addy Osmani, <a href="http://msdn.microsoft.com/en-us/magazine/gg723713.aspx" target="_blank" rel="external">Creating Responsive Applications Using jQuery Deferred and Promises</a></li>
<li>Graham Jenson, <a href="http://maori.geek.nz/post/i_promise_this_will_be_short" target="_blank" rel="external">JQuery Promises and Deferreds: I promise this will be short</a></li>
<li>Q module document, <a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery" target="_blank" rel="external">Coming from jQuery</a> </li>
</ul>

	
	</div>
  <a type="button" href="/2014/11/16/2014-11-16-deferred/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-12 </div>
			<div class="article-title"><a href="/2014/11/12/2014-11-22-无交互行为内容的闪烁FUBC/" >无交互行为内容的闪烁FOUC</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>#无交互行为内容的闪烁FOUC</p>
<p>今天了解了一个新的名词叫做 FOUC 浏览器样式闪烁，之前也听说过一些类似的东西，比如样式突变等等，但这东西竟然有学名的。</p>
<p>###什么是FOUC?</p>
<p>如果使用import方法对CSS进行导入,会导致某些页面在 Windows 下的<code>IE</code>出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。</p>
<p>出现的原因大致为：</p>
<ol>
<li>使用import方法导入样式表。</li>
<li>将样式表放在页面底部</li>
<li>有几个样式表，放在html结构的不同位置。</li>
</ol>
<p>其实原理很清楚：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
<p>一般的解决方法：<strong>使用LINK标签将样式表放在文档head中</strong>。</p>
<h3 id="在其他技术中，同样存在-FOUC："><a href="#在其他技术中，同样存在-FOUC：" class="headerlink" title="在其他技术中，同样存在 FOUC："></a>在其他技术中，同样存在 FOUC：</h3><h4 id="requirejs"><a href="#requirejs" class="headerlink" title="requirejs"></a>requirejs</h4><p>使用 requireJs,加载器来加载页面时，也会出现一部分没有交互行为的内容快速闪过（FOUC），比如在JavaScript 执行之前会有一部分无样式的页面原始内容闪烁一下。如果不依赖JavaScript 来修改初始页面的样式， 问题其实并不严重。但如果依赖JavaScript 来操作样式，则需要将样式提取出来放入初 始化CSS 之中，比如隐藏一些元素或展示一个加载指示器，提示页面正在加载中。 </p>
<h4 id="polymer"><a href="#polymer" class="headerlink" title="polymer"></a>polymer</h4><p>在 custom elements 更新 之前可能显示错乱。 为了缓解 FOUC 问题, Polymer 提供了一个 polyfill 解决方案，配合 :unresolved 伪类 使用。 对于简单的 app，你可以为 body 添加 unresolved 属性。这将在页面初始化时隐藏页面直到所有的 elements 被更新才显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">unresolved</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 或者,更具体些 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">unresolved</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/11/12/2014-11-22-无交互行为内容的闪烁FUBC/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-12 </div>
			<div class="article-title"><a href="/2014/11/12/2014-11-12-CSS代码段笔记/" >CSS代码段笔记</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="内层div充满外层div"><a href="#内层div充满外层div" class="headerlink" title="内层div充满外层div"></a>内层div充满外层div</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1.内层div充满外层div<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-tag">inner_div</span>&#123;</div><div class="line">		<span class="attribute">position</span>: absolute;</div><div class="line">		<span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">		<span class="attribute">right</span>:<span class="number">0</span>;</div><div class="line">		<span class="attribute">bottom</span>:<span class="number">0</span>;</div><div class="line">		<span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果单纯充满外层，淡出 with/height: 100%也可做到，但是这其它元素就不可以覆盖到上面了，absolute 不在正常的瀑布流中.</p>
<h3 id="渐变的用法"><a href="#渐变的用法" class="headerlink" title="渐变的用法"></a>渐变的用法</h3><pre><code>linear-gradient {color startAt,color endAt},{color startAt,color endAt},{...}, 


&lt;style&gt;
    elemnt{
        background-image:-webkit-linear-gradient(
            45deg, 
            red 25%,
            transparent 25%, transparent 50%,
            red 50%, red 75%,
            transparent 75%, transparent 100%
            );
    }
&lt;/style&gt;
</code></pre><h3 id="图片防下载，在图片上做个遮罩"><a href="#图片防下载，在图片上做个遮罩" class="headerlink" title="图片防下载，在图片上做个遮罩"></a>图片防下载，在图片上做个遮罩</h3><pre><code>&lt;div&gt;
    &lt;div class=&apos;cover&apos;&gt;&lt;/div&gt;
    &lt;img&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;style&gt;
    .cover {
        position: absolute;
        width:100%;
        height:100%;

        /*
        positon:absolute;
        top:0;
        right:0;
        bottom:0;
        left:0;
        */
    }    
&lt;/style&gt;
</code></pre><h3 id="div-style"><a href="#div-style" class="headerlink" title="div.style"></a>div.style</h3><pre><code>&lt;script&gt;
    div.style =&gt; CSSStyleDeclaration{}
    div.classList =&gt; [&quot;a&quot;,&quot;b&quot;];  //元素应用的class
    div.className =&gt; &quot;a b&quot;;      //应用的类名
&lt;/script&gt;
</code></pre><h3 id="border-的颜色"><a href="#border-的颜色" class="headerlink" title="border 的颜色"></a>border 的颜色</h3><pre><code>&lt;p&gt;
    如果没有在 border 属性中指定，则默认采用前景色，
    同字体一个颜色，字体默认黑色，
    可通过color指定，所以这个color也适用于border;
&lt;/p&gt;
</code></pre><h3 id="clip-图片剪切显示"><a href="#clip-图片剪切显示" class="headerlink" title="clip 图片剪切显示"></a>clip 图片剪切显示</h3><pre><code>&lt;style&gt;
img {
    position: absolute; left:526px;
    clip: rect(40px  200px  150px  30px);
    /* non-standard syntax, but supported by all major browsers including Firefox and IE */
}
&lt;/style&gt;
</code></pre><p>window.innerHeight 有用的显示区域，视口的高度<br>window.outerHeight 浏览器窗口的高度，包括标题栏菜单栏等等。</p>
<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><pre><code>过度 transition: 
        transition-property: 指定过度的 css 属性,
        transition-duration: 指定完成过渡所需时间,
        transition-timing-function: 指定过渡函数,
        transition-delay: 指定过渡开始出现的延迟时间
</code></pre><h2 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h2><p>:nth-of-type 和 :nth-child 类似, 不同的是它只计算父元素中指定的某种类型的子元素.</p>
<pre><code>ul&gt;li:nth-of-type(3) {
    background-color: orange;
}
</code></pre>
	
	</div>
  <a type="button" href="/2014/11/12/2014-11-12-CSS代码段笔记/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-12 </div>
			<div class="article-title"><a href="/2014/11/12/2014-11-12-Hammerjs的使用/" >移动端技术积累</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>先占位置。</p>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> hammer = <span class="keyword">new</span> Hammer(<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>));</div><div class="line"></div><div class="line">hammer.on(<span class="string">'pan'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"pan"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hammer.on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"tap-单击"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hammer.on(<span class="string">"doubletap"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"onhold-双击"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hammer.on(<span class="string">'press'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"press-长按"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>hammer.js <a href="http://hammerjs.github.io/" target="_blank" rel="external">跨中断的事件解决方案</a></p>

	
	</div>
  <a type="button" href="/2014/11/12/2014-11-12-Hammerjs的使用/#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/6/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/8/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			
  <div class="form-group has-success has-feedback" id="site_search">
    <form class="site-search-form">
        <input type="text" id="st-search-input" name="q" results="0" placeholder="搜索" class="st-search-input st-default-search-input form-control" />
    </form>
  </div>  


		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Sports/Baseball/">Baseball<span>2</span></a></li>
		
			<li><a href="/categories/Sports/">Sports<span>2</span></a></li>
		
			<li><a href="/categories/bom/">bom<span>1</span></a></li>
		
			<li><a href="/categories/collection/">collection<span>1</span></a></li>
		
			<li><a href="/categories/css/">css<span>1</span></a></li>
		
			<li><a href="/categories/http/">http<span>1</span></a></li>
		
			<li><a href="/categories/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/categories/javascript-test/">javascript test<span>1</span></a></li>
		
			<li><a href="/categories/jquery/">jquery<span>1</span></a></li>
		
			<li><a href="/categories/library/">library<span>2</span></a></li>
		
			<li><a href="/categories/note/">note<span>1</span></a></li>
		
			<li><a href="/categories/note-vim/">note vim<span>2</span></a></li>
		
			<li><a href="/categories/tool/">tool<span>3</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/jquery/">jquery<span>3</span></a></li>
		
			<li><a href="/tags/database-linux/">database linux<span>1</span></a></li>
		
			<li><a href="/tags/test/">test<span>2</span></a></li>
		
			<li><a href="/tags/vim/">vim<span>3</span></a></li>
		
			<li><a href="/tags/http/">http<span>2</span></a></li>
		
			<li><a href="/tags/think/">think<span>1</span></a></li>
		
			<li><a href="/tags/regexp/">regexp<span>6</span></a></li>
		
			<li><a href="/tags/default/">default<span>1</span></a></li>
		
			<li><a href="/tags/build/">build<span>2</span></a></li>
		
			<li><a href="/tags/linux/">linux<span>6</span></a></li>
		
			<li><a href="/tags/javascript-test/">javascript test<span>1</span></a></li>
		
			<li><a href="/tags/dom-javascript/">dom,javascript<span>1</span></a></li>
		
			<li><a href="/tags/webponent/">webponent<span>1</span></a></li>
		
			<li><a href="/tags/mobile/">mobile<span>1</span></a></li>
		
			<li><a href="/tags/css/">css<span>7</span></a></li>
		
			<li><a href="/tags/hg/">hg<span>1</span></a></li>
		
			<li><a href="/tags/javascript-regexp/">javascript regexp<span>1</span></a></li>
		
			<li><a href="/tags/mac/">mac<span>1</span></a></li>
		
			<li><a href="/tags/Fight/">Fight<span>2</span></a></li>
		
			<li><a href="/tags/module/">module<span>2</span></a></li>
		
		
		   <li><a href="/tags">...<span>38</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/01/02/新的一年-2017/" ><i class="fa fa-file-o"></i>新的一年, 2017</a>
      </li>
    
      <li>
        <a href="/2015/10/27/what_is_true/" ><i class="fa fa-file-o"></i>实际情况是什么样的</a>
      </li>
    
      <li>
        <a href="/2015/10/23/软件设计原则/" ><i class="fa fa-file-o"></i>软件设计原则</a>
      </li>
    
      <li>
        <a href="/2015/10/23/测试工具-Mock-的使用-资料整理中/" ><i class="fa fa-file-o"></i>测试工具 Mock 的使用(资料整理中)</a>
      </li>
    
      <li>
        <a href="/2015/10/23/怎么写出好代码/" ><i class="fa fa-file-o"></i>怎么写出好代码</a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/chenyakun" title="My Github repository." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 yakun.cyk
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
  <script type="text/javascript">
  (function(w,d,t,u,n,s,e){w['SwiftypeObject']=n;w[n]=w[n]||function(){
    (w[n].q=w[n].q||[]).push(arguments);};s=d.createElement(t);
    e=d.getElementsByTagName(t)[0];s.async=1;s.src=u;e.parentNode.insertBefore(s,e);
  })(window,document,'script','//s.swiftypecdn.com/install/v2/st.js','_st');

  _st('install', 'ZP2ZSuHgipSZfRyU8uTR','2.0.0');
  </script>



  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<script src="/js/search.js"></script> 


<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>



   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>

</body>
   </html>
