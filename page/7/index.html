<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 7 页 | output stream</title>
  <meta name="author" content="yakun.cyk">
  
  <meta name="description" content="主要内容可能关于 web 技术，感慨心得...">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="output stream"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	    <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
	  <a class="navbar-brand" href="/">output stream</a>
      <div class="collapse navbar-collapse nav-menu">
		    <ul class="nav navbar-nav">
    		  
    		  <li>
    			 <a href="/demos" title="Demos.">
            <i class="fa fa-flask"></i>Demos
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/archives" title="All the articles.">
            <i class="fa fa-archive"></i>归档
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/about" title="About me.">
            <i class="fa fa-user"></i>关于我
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/#" title="Search Posts.">
            <i class="fa fa-search"></i>搜索
    			 </a>
    		  </li>
    		  
    		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <!--
        <i class="fa fa-heart"></i> 
      -->
      
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-02 </div>
			<div class="article-title"><a href="/2014/11/02/2014-11-02-css 中的度量/" >css中的单位</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="angle"><a href="#angle" class="headerlink" title="angle"></a>angle</h2><p>angle 者，角也。<br>积极的角度代表(right angles)，负角度代表(left angles)。</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">background</span><span class="selector-pseudo">:-moz-linear-gradient(10deg</span>,<span class="selector-tag">red</span>,<span class="selector-tag">green</span>,<span class="selector-tag">yellow</span>);</div></pre></td></tr></table></figure>
<p>角度为水平方向逆时针向上旋转10°</p>
<p>当指定的角度，请记住，它是一个由水平线与渐变线产生的的角度，逆时针方向。因此，使用0deg将产生一个左到右横向梯度，而90度将创建一个从底部到顶部的垂直渐变。</p>
<h2 id="webkit-gradient"><a href="#webkit-gradient" class="headerlink" title="webkit-gradient"></a>webkit-gradient</h2><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">webkit核心浏览器下的的基本语法如下：</div><div class="line">-webkit-gradient(type, start_point, end_point, / stop...) </div><div class="line">-webkit-gradient(type, inner_center, inner_radius, outer_center, outer_radius, / stop...)</div><div class="line"></div><div class="line"></div><div class="line">参数</div><div class="line">参数类型	简要说明</div><div class="line">type	渐变的类型，可以是线性渐变(linear)或是径向渐变(radial)</div><div class="line">start_point	渐变图像中渐变的起始点</div><div class="line">end_point	渐变图像中渐变的结束点</div><div class="line">stop	color-stop()方法，指定渐变进程中特定的颜色</div><div class="line">inner_center	内部中心点，径向渐变起始圆环</div><div class="line">inner_radius	内部半径，径向渐变起始圆</div><div class="line">outer_center	外部渐变结束圆的中心点</div><div class="line">outer_radius	外部渐变结束圆的半径</div></pre></td></tr></table></figure>
<p>关于参数的具体说明</p>
<ol>
<li>start_point 和 end_point</li>
<li>划一条渐变线，会有起始点和结束点，这个起始点和结束点就对应这里的start_point和end_point参数</li>
</ol>
<p>start_point(x1,x2)，end_point(x2,y2)，这里的 x,y 对应左上角为起点的坐标，<br>此处的x,y参数表示与CSS中的background-position是一致的，可以使像素值，或是百分比值或是left,top,right,bottom。</p>
<p>当x1等于x2，y1不等于y2，实现垂直渐变，调整y1，y2的值可以调整渐变半径大小；<br>当y1等于y2，x1不等于x2，实现水平渐变，调整x1，x2的值可以调整渐变半径大小；<br>当y1不等于y2，x1不等于x2，实现角度渐变，当x1,x2,y1,y2取值为极值的时候接近垂直渐变或水平渐变；<br>当x1等于x2，y1等于y2，实现没有渐变，取from色，即 <strong>from(颜色值)</strong> ；</p>

	
	</div>
  <a type="button" href="/2014/11/02/2014-11-02-css 中的度量/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-08-21-jquery基本用法/" >jquery 基础用法</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>整理了这些作为下阶段读源码前的知识储备，同时分享给大家。共勉。</p>
<h2 id="总述"><a href="#总述" class="headerlink" title="总述"></a>总述</h2><p>jQuery 框架提供了很多方法，但大致上可以分为3 大类：</p>
<ol>
<li>获取jQuery 对象的方法</li>
<li>在jQuery 对象间跳转的方法</li>
<li>获取jQuery 对象后调用的方法</li>
</ol>
<h3 id="获取-jQuery-对象"><a href="#获取-jQuery-对象" class="headerlink" title="获取 jQuery 对象"></a>获取 jQuery 对象</h3><p>是怎样获取jQuery 对象。大致来说，是通过最核心的<code>$()</code>方法，将页面上的元素（或者在页面上不存在的 html 片段）包装成 jQuery 对象。<br><code>$()方法</code>里面支持的语法又包括：</p>
<ol>
<li>分别是表达式（包括类表达式.，id 表达式#，元素表达式等）</li>
<li>符号（包括后代符号space，next 符号+等)</li>
<li>过滤器（包括:过滤器和[]过滤器）</li>
<li>现在显然还有更多</li>
</ol>
<p>通过以上组合，通过选择器 <code>$()</code> 可”查询“得到 jQuery 对象（或者jQuery 对象的集合）。</p>
<h3 id="对象跳转"><a href="#对象跳转" class="headerlink" title="对象跳转"></a>对象跳转</h3><p>是在jQuery 对象间的跳转。也就是说，已经得到了一个jQuery 对象，但并不是想要的，那么可以通过一系列的跳转方法，比如<em>parent()、next()、children()、find()</em>等，或者过滤筛选的方法，比如<em>eq、filter()、not()</em>等，来得到最终想要操作的jQuery 对象。</p>
<p>用跳转和过滤方式得到的jQuery 结果，往往通过比较复杂的表达式组合，可以达到同样的目的。<br>比如说 <code>$(&quot;div&quot;).eq(3)</code>，也可以用<code>$(&quot;div:eq(3)&quot;)</code> 达到同样的目的。<br>又比如说<code>$(&quot;div&quot;).find(&quot;span&quot;)</code>，可以用<code>$(&quot;div span&quot;)</code>取到同样的元素。</p>
<p>方法是很灵活的，要根据具体的情况来选择。根据经验来说，HTML 页面写得越规范，使用 jQuery 就越简单。</p>
<p>还有一种情况，在得到了jQuery()对象之后，想要判断其是否满足条件，那么可以调用 ==is()、hasClass()==等方法，返回一个boolean 值，进行后续的判断。这类方法也可以归到这类。</p>
<h3 id="方法调用"><a href="#方法调用" class="headerlink" title="方法调用"></a>方法调用</h3><p>在获取准确的 jQuery 对象之后，调用其上的各种方法，来进行操作。这一步反而是比较简单的了。<br>后面就是对 jQuery 框架各种方法的简要介绍。</p>
<h3 id="常用API"><a href="#常用API" class="headerlink" title="常用API"></a>常用API</h3><p>####$(…);</p>
<pre><code>/**
 *  一切的核心，可以跟4 种参数。
 */
$();

/**
 *  返回jQuery 对象或者jQuery 对象的集合
 *  比如$(&quot;#id&quot;)、$(&quot;.class&quot;)
 */
$(expression);

/**
 *  返回jQuery 对象，或者jQuery 对象的集合
 *  比如$(&quot;&lt;span&gt;hello world&lt;/span&gt;&quot;)
 */
$(html)

/**
 *  返回jQuery 对象，或者jQuery 对象的集合
 *  比如$(document.body)
 */
$(element)

/**
 *  所有元素
 */
$(*)
```
</code></pre><h4 id="jQuery-对象获取"><a href="#jQuery-对象获取" class="headerlink" title="jQuery 对象获取"></a>jQuery 对象获取</h4><pre><code>```javascript

/**
 *  返回该jQuery 对象在集合中的索引
 */
jQuery.index(element);

/**
 *  遍历jQuery 对象集合，在每个对象上执行 callback 函数，
 *  function callback(index, domElement){
 *    this //DOMElement
 *  };
 */
jQuery.each(function);

/**
 *  返回 jQuery 对象集合的大小
 */
jQuery.size();

/**
 *  相当于size()方法
 */
jQuery.length

/**
 *  获取原生 DomElement 对象的 Array,
 *  即将 jQuery 对象转成 数组对象，
 *  虽然 jQuery 对象也有 length 属性，且可用下标读写
 *  但并非是数组对象。
 */
jQuery.get()

/**
 *  获取原生 DomElement 对象
 */
jQuery.get(index)

/**
 *  获取 jQuery 对象集合中的一个 jQuery 对象
 */
jQuery.eq(position)
</code></pre><h4 id="Data-相关方法"><a href="#Data-相关方法" class="headerlink" title="Data 相关方法"></a>Data 相关方法</h4><p>在匹配的元素身上存值(store data)， <code>.data()</code> 方法允许在我们以一种安全的方式附加数据到 dom 元素，不会产生循环引用和内存泄露。</p>
<pre><code>jQuery.data(name)        // 取值
jQuery.data(name, value) // 赋值
jQuery.removeData(name)  // 清理

$( &quot;body&quot; ).data( &quot;foo&quot;, 52 );
$( &quot;body&quot; ).data( &quot;bar&quot;, { myType: &quot;test&quot;, count: 40 } );
$( &quot;body&quot; ).data( { baz: [ 1, 2, 3 ] } );
$( &quot;body&quot; ).data( &quot;foo&quot; ); // 52
$( &quot;body&quot; ).data(); // { foo: 52, bar: { myType: &quot;test&quot;, count: 40 }, baz: [ 1, 2, 3 ] }
</code></pre><h4 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h4><pre><code>/**
 *  多目标选择器
 *  可以选择多个元素或者表达式，
 *  包装成 jQuery 对象的集合
 *  例子：$(&quot;div,span&quot;)
 */

$(&quot;table tr td&quot;); //multiple(selector1, selector2)

$(&quot;#id &gt; span&quot;); //直接节点

$(&quot;label + input&quot;) //next(prev, next) 同级的紧挨着的下一个

$(&quot;#prev ~ div&quot;) // siblings(prev, siblings),同样要求是同级
</code></pre><h4 id="基本的过滤器"><a href="#基本的过滤器" class="headerlink" title="基本的过滤器"></a>基本的过滤器</h4><pre><code>$(&quot;:header&quot;);     // 所有 header, &lt;h1&gt;~&lt;h6&gt;
$(&quot;tr:odd&quot;);      // 选中所有奇数行
$(&quot;tr:even&quot;);     // 选中所有偶数行
$(&quot;:animated&quot;);   // 选中所有当前有特效的素
$(&quot;div:animated&quot;);// 选中运行动画的
$(&quot;tr:first&quot;);    // 选中第一行
$(&quot;tr:last&quot;);     // 选中最后一行
$(&quot;input:not(:checked)&quot;);  //选中所有没有“checked”
$(&quot;td:gt(4)&quot;);    // 选中所有index 是4 之后的td
$(&quot;td:lt(4)&quot;);    // 选中所有index 是4 之前的td

$(&quot;td:eq(4)&quot;);    // 选中index 是 4 的td
$(&quot;td&quot;).eq(4);    // 选中index 是 4 的td
</code></pre><h4 id="内容过滤选择器"><a href="#内容过滤选择器" class="headerlink" title="内容过滤选择器"></a>内容过滤选择器</h4><pre><code>$(&quot;div:contains(&apos;John&apos;)&quot;); // 选中所有包含&quot;John&quot;的div
$(&quot;td:empty&quot;);    // 选中所有内容为空的td
$(&quot;div:has(p)&quot;);  // 选中包含有&lt;p&gt;元素的&lt;div&gt;元素，返回jQuery 对象集合

$(&quot;td:parent&quot;);   //选中所有包含子节点的元素，包括文本也可以算是子节点
</code></pre><h4 id="可见性过滤器"><a href="#可见性过滤器" class="headerlink" title="可见性过滤器"></a>可见性过滤器</h4><pre><code>$(&quot;span:hidden&quot;);  // 选中所有隐藏的&lt;span&gt;
$(&quot;span:visible&quot;); // 选中所有可见的&lt;span&gt;
</code></pre><p>关于可见性，这里需要额外说明的。在老版本的 jQuery 中 ==<code>visibility:hidden;</code>是认为不可见的==，我有证据，</p>
<pre><code>Sizzle.selectors.filters.hidden = function(elem){
    return &quot;hidden&quot; === elem.type ||
        jQuery.css(elem, &quot;display&quot;) === &quot;none&quot; ||
        jQuery.css(elem, &quot;visibility&quot;) === &quot;hidden&quot;;
};
`
</code></pre><p>这段代码出自 <code>jquery-1.3.1.js</code>,然而到近代的版本中(在1.3.2就改了)</p>
<pre><code>jQuery.expr.filters.hidden = function( elem ) {
          var width = elem.offsetWidth,
              height = elem.offsetHeight;
          // 没有 visibility 什么事
          return ( width === 0 &amp;&amp; height === 0 ) || (!jQuery.support.reliableHiddenOffsets &amp;&amp; ((elem.style &amp;&amp; elem.style.display) || jQuery.css( elem, &quot;display&quot; )) === &quot;none&quot;);
      };
</code></pre><p>简单的说就是：==如果元素占用空间了，就认为是可见的。==只要不是0的都算可见的。 </p>
<p>所以，<code>visibility：hidden;</code> 或者 <code>opacity:0;</code> 由于占有空间，它们算事“可见”的。</p>
<h4 id="属性过滤器"><a href="#属性过滤器" class="headerlink" title="属性过滤器"></a>属性过滤器</h4><pre><code>$(&quot;div[id]&quot;);   // 选中包含 id 属性的div
$(&quot;input[name$=&apos;bc&apos;]&quot;);  // 选中 name 属性以 &apos;bc&apos; 结尾的 input
$(&quot;input[name^=&apos;letter&apos;]&quot;); // 选中属性 name 是以&apos;letter&apos;开头的 input
$(&quot;input[tag*=&apos;man&apos;]&quot;); // 属性tag里包含&apos;man&apos;
$(&quot;input[abc=&apos;def&apos;]&quot;); // 属性 abc 的值为 &apos;def&apos;

$(&quot;input[title!=&apos;722&apos;]&quot;);  // 选中属性 title 不包含&apos;722&apos;的
$(&quot;input[id][gender$=&apos;man&apos;]&quot;); // 选中包含id 属性，和以&apos;man&apos;结尾的属性 gender 的&lt;input&gt;元素
</code></pre><h4 id="孩子过滤器"><a href="#孩子过滤器" class="headerlink" title="孩子过滤器"></a>孩子过滤器</h4><pre><code>$(&quot;ul li:nth-child(2)&quot;); // 选中自身是&lt;ul&gt;元素的第二个子节点的&lt;li&gt;元素，注意这个计算是从 1 开始的，不是从0 开始
$(&quot;div span:firstChild&quot;); // 选中自身是&lt;div&gt;元素的第一个子节点的&lt;span&gt;元素
$(&quot;div span:lastChild&quot;); // 选中自身是&lt;div&gt;元素的最后一个子节点的&lt;span&gt;元素
</code></pre><h4 id="表单过滤器"><a href="#表单过滤器" class="headerlink" title="表单过滤器"></a>表单过滤器</h4><pre><code>$(&quot;:button&quot;);   //所有 &lt;button&gt; 和 &lt;input type=&quot;button&quot;&gt; 元素
$(&quot;form :checkbox&quot;)； // 选中所有&lt;form&gt;标签下的&lt;input type=&quot;checkbox&quot;&gt; 不过这样会比较慢

$(&quot;input:checkbox&quot;)； // 推荐

$(&quot;:file&quot;)； // 选中所有&lt;input type=&quot;file&quot;&gt;
$(&quot;:hidden&quot;); // 选中所有隐藏元素，以及&lt;input type=&quot;hidden&quot;&gt;
$(&quot;:input&quot;); // 选中所有&lt;input&gt;
$(&quot;:text&quot;);  // 选中所有&lt;input type=&quot;text&quot;&gt;
$(&quot;:password&quot;); // 选中所有&lt;input type=&quot;password&quot;&gt;
$(&quot;:radio&quot;);    // 选中所有&lt;input type=&quot;radio&quot;&gt;
$(&quot;input:radio&quot;);  // 最佳实践是这样

$(&quot;:image&quot;)； // 选中所有&lt;input type=&quot;image&quot;&gt;
$(&quot;:reset&quot;);  // 选中所有&lt;input type=&quot;reset&quot;&gt;
$(&quot;:submit&quot;); // 选中所有&lt;input type=&quot;submit&quot;&gt;

$(&quot;input:enabled&quot;); // 选中所有enabled 的&lt;input&gt;元素
$(&quot;input:disabled&quot;); // 选中所有disabled 的&lt;input&gt;元素
$(&quot;input:checked&quot;); // 选中所有 checked 的 checkbox
$(&quot;input:selected&quot;); // 选中所有 selected 的&lt;option&gt;元素
</code></pre><h4 id="属性相关的方法"><a href="#属性相关的方法" class="headerlink" title="属性相关的方法"></a>属性相关的方法</h4><pre><code>jQuery.removeAttr(name);
jQuery.attr(name); // 返回属性的值，比如$(&quot;img&quot;).attr(&quot;src&quot;)
jQuery.attr(key,value); // 这是设置属性的值
jQuery.attr(properties); // 也是设置属性的值

$(&quot;img&quot;).attr({
    src: &quot;/images/hat.gif&quot;,
    title: &quot;jQuery&quot;,
    alt: &quot;jQuery Logo&quot;
});

jQuery.attr(key,function); // function 计算出的结果，赋给key

// 在回调函数中
function callback(index) {
 // index == position in the jQuery object
 // this means DOM Element
}
</code></pre><h4 id="类相关的操作"><a href="#类相关的操作" class="headerlink" title="类相关的操作"></a>类相关的操作</h4><pre><code>jQuery.toggleClass(class); // 反复加减 class
jQuery.toggleClass(class,switch); // 增加一个 switch 表达式

// 表达式计算后返回 class 名称
$( &quot;div.foo&quot; ).toggleClass(function() {
  if ( $( this ).parent().is( &quot;.bar&quot; ) ) {
    return &quot;happy&quot;;
  } else {
    return &quot;sad&quot;;
  }
});

jQuery.hasClass(class)； // 返回boolean
jQuery.removeClass(class); // 去掉挂载的 class
jQueyr.addClass(class)； // 加载 class
</code></pre><h4 id="html相关的操作"><a href="#html相关的操作" class="headerlink" title="html相关的操作"></a>html相关的操作</h4><pre><code>jQuery.html()； // 返回包含的html 文本
jQuery.html(val); // 用val 替换包含的 html 文本,输入的代码会被执行
</code></pre><h4 id="文本相关的方法"><a href="#文本相关的方法" class="headerlink" title="文本相关的方法"></a>文本相关的方法</h4><pre><code>jQuery.text();  // 返回包含的纯文本，不会包括html 标签，比如&lt;span&gt;abcd&lt;/span&gt;，调用 .text() 方法，只会返回abcd，不会返回&lt;span&gt;abcd&lt;/span&gt;

jQuery.text(val); // 用 val 替换包含的纯文本，和html(val)方法的区别在于，所有的内容会被看作是纯文本，不会作为html 标签进行处理，比如调用.text(&quot;&lt;span&gt;abcd&lt;/span&gt;&quot;)，&lt;span&gt; 和 &lt;/span&gt;不会被认为是html 标签，而是作为纯文本显示了。
</code></pre><h4 id="值相关的操作"><a href="#值相关的操作" class="headerlink" title="值相关的操作"></a>值相关的操作</h4><pre><code>jQuery.val(); // 返回 string 或者array
jQuery.val(val); // 设置 string 值
jQuery.val(array); // 设置多个值，以上 3 个方法，主要都是用在表单标签里，如&lt;input type=&quot;text&quot;&gt;，&lt;input type=&quot;checkbox&quot;&gt;等
</code></pre><h4 id="在jQuery-对象之间查找"><a href="#在jQuery-对象之间查找" class="headerlink" title="在jQuery 对象之间查找"></a>在jQuery 对象之间查找</h4><p>需要弄清： ==文本和节点是两回事，在 DOM 里就分开了。==<br>    jQuery.parent(expr); // 找父亲节点，可以传入expr 进行过滤,比如</p>
<pre><code>$(&quot;span&quot;).parent();
$(&quot;span&quot;).parent(&quot;. class&quot;); // 用表达式过滤

jQuery.parents(expr); // 祖先元素，不限于父元素
jQuery.children(expr); // 返回所有子节点(不包括文本)，和 parents()方法不一样的是，这个方法只会返回直接的孩子节点，不会返回所有的子孙节点

jQuery.contents(); // 返回下面的所有内容，包括节点和文本。这个方法和 children()的区别就在于，包括空白文本，也会被作为一个jQuery 对象返回，children()则只会返回节点

jQuery.prev(); // 返回上一个兄弟节点，不是所有的兄弟节点
jQuery.prevAll(); // 返回所有之前的兄弟节点
jQuery.next(); // 返回下一个兄弟节点，不是所有的兄弟节点 (+)
jQuery.nextAll(); // 返回所有之后的兄弟节点(~)
jQuery.siblings(); // 返回兄弟姐妹节点，不分前后
jQuery.add(expr); // 往既有的jQuery 对象集合中增加新的jQuery 对象，例子：
$(&quot;div&quot;).add(&quot;p&quot;);

jQuery.find(expr); // 从当前的初始集合下去找,不会返回初始集合内容：
$(&quot;body&quot;).find(&quot;div&quot;);
// 等同于：
jQuery.find(&quot;body div&quot;);


jQuery.filter(expr); // 从初始的jQuery 对象集合中筛选出一部分
</code></pre><p>####串联方法</p>
<pre><code>jQuery.andSelf();  // 把最后一次查询前一次的集合,也增加到最终结果集中,比如:

$(&quot;div&quot;).find(&quot;p&quot;).andSelf(); 这样结果集中包括所有的&lt;p&gt;和&lt;div&gt;。如果是$(&quot;div&quot;).find(&quot;p&quot;),那就只有&lt;p&gt;，没有&lt;div&gt;

jQuery.end(); // 把最后一次查询前一次的集合，作为最终结果集，比如
$(&quot;p&quot;).find(&quot;span&quot;).end(); // 所有的&lt;p&gt;，没有&lt;span&gt;
</code></pre><h4 id="DOM-文档操作方法"><a href="#DOM-文档操作方法" class="headerlink" title="DOM 文档操作方法"></a>DOM 文档操作方法</h4><pre><code>a.append(b); // b 加到 a 上
$(&quot;div&quot;).append(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;);

a.appendTo(b); // a 加到 b 上
$(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;).appendTo(&quot;#div&quot;)； 

$(&quot;span&quot;).appendTo(&quot;div&quot;); //隐藏的 move，移动元素

/* 比如在：

 &lt;div id=&apos;a&apos;&gt;a: &lt;span&gt; hello &lt;/span&gt; &lt;/div&gt;
 &lt;div id=&apos;b&apos;&gt;b: &lt;/div&gt;

 经过

 $(&apos;span&apos;).appendTo(&quot;#b&quot;);
</code></pre><p> 结果会是正样：</p>
<pre><code>a:
b: hello
</code></pre><p> 接下来，</p>
<pre><code>jQuery.prepend(content); // 在选择元素的内部第一个位置插入


a.prependTo(b); // a 插到 b 内部的排头位置

jQuery.after(content); 注意是 content，在外部插入，插入到后面，比如
$(&quot;#foo&quot;).after(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;); // 参数是内容，不能是选择器

jQuery.insertAfter(selector)；// 允许是选择器
$(&quot;&lt;span&gt;hello&lt;/span&gt;&quot;).insertAfter(&quot;#foo&quot;);

jQuery.before(content); // 在外部插入，插入到前面, 参数不是选择器

jQuery.insertBefore(selector); // 外面插入

jQuery.wrapInner(html); // 在内部插入标签，比如
$(&quot;p&quot;).wrapInner(&quot;&lt;span&gt;&lt;/span&gt;&quot;);

jQuery.wrap(html); // 在外部插入标签，比如
$(&quot;p&quot;).wrap(&quot;&lt;div&gt;&lt;/div&gt;&quot;); // 所有的 p 都会被各自的div 包裹

jQuery.wrapAll(html); // 所选元素会被同一个大的 html 整个的全部包裹

jQuery.replaceWith(content); 比如
$(this).replaceWith(&quot;&lt;div&gt;&quot;+$(this).text()+&quot;&lt;/div&gt;&quot;);

jQuery.replaceAll(selector);
$(&quot;&lt;div&gt;hello&lt;/div&gt;&quot;).replaceAll(&quot;p&quot;);

jQuery.empty();
$(&quot;p&quot;).empty(); // 从娃娃做起，会把&lt;p&gt;下面的所有子节点清空,但不清理 p

jQuery.remove(expr);
$(&quot;p&quot;).remove(); // 从自身做起，会把所有&lt;p&gt;移除，可以用表达式做参数，进行过滤
</code></pre><p>// 表面看跟 remove 做的一样，删除元素；<br>// 但是保留了元素中的数据或事件, 通过返回值返回，留存后用，<br>// 需要时候随时能补上去，绑定的数据事件不受影响。<br>    jQuery.detach();</p>
<pre><code>jQuery.clone([withDataAndEvents ] ));
</code></pre><p>使用案例</p>
<p>在使用 append 的时候，隐约的我们发现了它具有移动的功效：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;hello&quot;&gt;Hello&lt;/div&gt;
  &lt;div class=&quot;goodbye&quot;&gt;Goodbye&lt;/div&gt;
&lt;/div&gt;

$( &quot;.hello&quot; ).appendTo( &quot;.goodbye&quot; );
</code></pre><p>结果变成了这样：</p>
<pre><code>&lt;div class=&quot;container&quot;&gt;
  &lt;div class=&quot;goodbye&quot;&gt;
    Goodbye
    &lt;div class=&quot;hello&quot;&gt;Hello&lt;/div&gt;
  &lt;/div&gt;
&lt;/div&gt;
</code></pre><p>如果我们的需求是额外的拷贝一份元素到目的地：</p>
<pre><code>$( &quot;.hello&quot; ).clone().appendTo( &quot;.goodbye&quot; );

这样会更方便，结果会是这样：

    &lt;div class=&quot;container&quot;&gt;
      &lt;div class=&quot;hello&quot;&gt;Hello&lt;/div&gt;
      &lt;div class=&quot;goodbye&quot;&gt; 
        Goodbye 
        &lt;div class=&quot;hello&quot;&gt;Hello&lt;/div&gt;
      &lt;/div&gt;
    &lt;/div&gt;
</code></pre><p>clone 的用法也分两种：</p>
<pre><code>clone(true);  // 克隆，并且连带数据和绑定的事件
clone()/clone(false); // 克隆，表面结构
</code></pre><h4 id="CSS-相关方法"><a href="#CSS-相关方法" class="headerlink" title="CSS 相关方法"></a>CSS 相关方法</h4><pre><code>jQuery.css(name); // 获取一个 css 属性的值，比如
$(&quot;p&quot;).css(&quot;color&quot;)

jQuery.css(object); // 设置css 属性的值，比如
$(&quot;p&quot;).css({
     &quot;color&quot;:&quot;red&quot;,
     &quot;border&quot;:&quot;1px red solid&quot;
  });

jQuery.css(name,value);
$(&quot;p&quot;).css(&quot;color&quot;,&quot;red&quot;);
</code></pre><h4 id="位置计算相关方法"><a href="#位置计算相关方法" class="headerlink" title="位置计算相关方法"></a>位置计算相关方法</h4><pre><code>jQuery.scrollLeft(); // 设置滚动条偏移，这个方法对可见元素或不可见元素都生效
jQuery.scrollTop();  // 设置滚动条偏移，这个方法对可见元素或不可见元素都生效

jQuery.offset();     // 计算偏移量，返回值有 2 个属性，分别是 top 和left

jQuery.position();  // 计算位置，返回值也有2 个属性，top 和 left,返回：

[object Object] {
  left: 34.546875,
  top: 11
}
</code></pre><p>这里需要额外补充：</p>
<blockquote>
<p>The .offset() method allows us to retrieve the current position of an element relative to the document. Contrast this with .position(), which retrieves the current position relative to the offset parent.</p>
</blockquote>
<p>简单来说就是：==offset 是相对于 document，而 position 相对于父元素。==</p>
<h4 id="宽度和高度计算相关方法"><a href="#宽度和高度计算相关方法" class="headerlink" title="宽度和高度计算相关方法"></a>宽度和高度计算相关方法</h4><p>这组方法需要结合CSS 的盒子模型来理解，margin 始终不参与计算</p>
<pre><code>jQuery.height();     // 计算的是 content
jQuery.innerHeight();  // 计算的是 content+padding
jQuery.outerHeight(); // 计算的是content+padding+border

jQuery.width();
jQuery.innerWidth();
jQuery.outerWidth();
</code></pre><h4 id="浏览器及特性检测"><a href="#浏览器及特性检测" class="headerlink" title="浏览器及特性检测"></a>浏览器及特性检测</h4><pre><code>$.support，可以检测当前浏览器是否支持下列属性，返回boolean。包括boxModel、cssFloat、
opacity、tbody 等
$.browser，检测当前浏览器类型，返回一个map，其中可能的值有safari、opera、msie、mozilla
</code></pre><h4 id="数据缓存方法"><a href="#数据缓存方法" class="headerlink" title="数据缓存方法"></a>数据缓存方法</h4><p>// 该类方法是jQuery.data()方法和jQuery.removeData()的另一种形式，增加的elem 参数是DOM Element</p>
<pre><code>$.data(elem, name);// 取出elem 上name 的值
$.data(elem, name, value); // 设置elem,name为 value
$.removeData(elem, name); //删除 elem 上的 name
$.removeData(elem); // 删除elem 上的所有缓存数据
</code></pre><h4 id="工具方法"><a href="#工具方法" class="headerlink" title="工具方法"></a>工具方法</h4><pre><code>$.isArray(obj); // 检测一个对象是否是数组
$.isFunction(obj); // 检测一个对象是否是函数
$.trim(str); // 去除string 的空格

$.( value, array [, fromIndex ] )
$.inArray(value, array); // 返回value 在array 中的下标， 如果没有找到则返回-1

$.inArray(123, [&quot;john&quot;,1,123,&quot;f&quot;]); // return2

$.unique(array); // 去除array 中的重复元素，该方法只对DOM Element 有效，对string 和 number 无效
</code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>最后，由于篇幅限制，把最重要的 <code>事件绑定</code> 和 <code>ajax</code> 独立出来，并且也还没写完呢，先到这里。</p>

	
	</div>
  <a type="button" href="/2014/10/31/2014-08-21-jquery基本用法/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2013-11-15-尝试山寨Backbone/" >mvc-backbone</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>学习了 BackBone.js, 为了更加深刻的理解，尝试山寨之。</p>

	
	</div>
  <a type="button" href="/2014/10/31/2013-11-15-尝试山寨Backbone/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-10-31-mvc/" >mvc之投石问路</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="什么是MVC"><a href="#什么是MVC" class="headerlink" title="什么是MVC"></a>什么是MVC</h2><p>MVC 是一种设计模式，它将应用划分为3 个部分：数据（模型）、展现层（视图）和用户交互层（控制器）。换句话说，一个事件的发生是这样的过程：<br>1． 用户和应用产生交互。<br>2． 控制器的事件处理器被触发。<br>3． 控制器从模型中请求数据，并将其交给视图。<br>4． 视图将数据呈现给用户。</p>
<p>现在来看一个真实的例子</p>
<p>1． 用户提交一个新的聊天消息。<br>2． 控制器的事件处理器被触发。<br>3． 控制器创建了一个新的聊天模型（Chat Model）记录。<br>4． 然后控制器更新视图。<br>5． 用户在聊天窗口看到新的聊天消息。</p>
<h2 id="模型"><a href="#模型" class="headerlink" title="模型"></a>模型</h2><p>模型用来存放应用的所有数据对象。比如，可能有一个User 模型，用以存放用户列表、他们的属性及所有与模型有关的逻辑。<br>模型不必知晓视图和控制器的细节，模型只需包含数据及直接和这些数据相关的逻辑。任何事件处理代码、视图模板，以及那些和模型无关的逻辑都应当隔离在模型之外。</p>
<blockquote>
<p>将模型和视图的代码混在一起，是违反MVC 架构原则的。模型是最应该从你的应用中解<br>耦出来的部分。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> user = User.find(<span class="string">'foo'</span>);</div><div class="line">user.destroy();</div></pre></td></tr></table></figure>
<p>当控制器从服务器抓取数据或创建新的记录时，它就将数据包装成模型实例。</p>
<h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图层是呈现给用户的，用户与之产生交互。在JavaScript 应用中，视图大都是由HTML、CSS 和JavaScript 模板组成的。</p>
<p>实际上，和模型类似，视图也应当从应用的其他部分中解耦出来。视图不必知晓模型和控制器中的细节，它们是相互独立的。</p>
<blockquote>
<p>将逻辑混入视图之中是编程的大忌。</p>
</blockquote>
<p>##控制器<br>控制器是模型和视图之间的纽带。控制器从视图获得事件和输入，对它们进行处理（很可能包含模型），并相应地更新视图。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Controller = &#123;&#125;;</div><div class="line"></div><div class="line"><span class="comment">// 使用匿名函数来封装一个作用域</span></div><div class="line">(Controller.users = <span class="function"><span class="keyword">function</span>(<span class="params">$</span>)</span>&#123;</div><div class="line"></div><div class="line">	<span class="keyword">var</span> nameClick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="comment">/* ... */</span></div><div class="line">	&#125;;</div><div class="line"></div><div class="line">	<span class="comment">// 在页面加载时绑定事件监听</span></div><div class="line">	$(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		$(<span class="string">"#view .name"</span>).click(nameClick);</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/10/31/2014-10-31-mvc/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-11-03-mvc-backbone/" >尝试山寨Backbone</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>前几天梳理了下 MVC 的知识,准备好基础,现在开始学习 BackBone.js 。</p>

	
	</div>
  <a type="button" href="/2014/10/31/2014-11-03-mvc-backbone/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-10-31-ajax_deferred_promise/" >ajax</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>最本质的 ajax 其实是这样的：</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/codinglion/Lnbvv/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<p>jQuery 出现后，在发出Ajax请求时，jQuery会帮我们确定取得数据的最佳方式。可用的方式包括标准的XMLHttpRequest对象、ms的ActiveX对象XMLHTTP 或 script 标签。</p>
<p>由于不同请求使用的数据传输方式可能不一样，那我们就需要一个公共的接口与这些通信交互。为此，jqXHR对象提供了这种接口在 XMLHttpRequest对象可用的情况下，封装该对象的行为；在XMLHttpRequest对象不可用的情况下，则尽可能模拟它。这个对象提供给我们的属性和方法包括：</p>
<ul>
<li>包含返回数据的 .responseText或.responseXML；</li>
<li>包含状态码和状态描述的 .status和.statusText；</li>
<li>操作与请求一起发送的HTTP头部的.setRequestHeader()；</li>
<li>提早中断通信的.abort()</li>
</ul>
<p>jQuery的所有 Ajax 方法都会返回jqXHR对象，只要把这个对象保存起来，随后就可以方便地使用这些属性和方法。</p>
<p>乍一看，调用.done()和.fail()与之前的写法相比并没有明显的好处。可是，这两个承诺方法的确是有好处的。第一，可以多次调用这两个方法，根据需要添加多个处理程序。</p>
<p>第二，如果把调用$.ajax()的结果保存在一个变量中，那么就可以考虑代码的可读性，在后面再添加处理程序。</p>
<p>第三，如果在添加处理程序的时候Ajax操作已经完成，就会立即调用该处理程序。</p>
<p>第四，我们最好采用与jQuery库中其他代码一致的语法，这带来的好处不言而喻。</p>
<hr>
<h2 id="Promise-对象和Deferred-对象"><a href="#Promise-对象和Deferred-对象" class="headerlink" title="Promise 对象和Deferred 对象"></a>Promise 对象和Deferred 对象</h2><pre><code>// jQuery 1.4 
// &quot;马上就要&quot;
$.get(&apos;/mydata&apos;, {
    success: onSuccess,
    failure: onFailure,
    always: onAlways
});

// jQuery 1.5
// 分期交付
var promise = $.get(&apos;/mydata&apos;);
    promise.done(onSuccess);
    promise.fail(onFailure);
    promise.always(onAlways);
</code></pre><p>jQuery 1.5 改变了 Ajax 那种“马上就要”的态度。我们喜爱的所有 Ajax 函数（$.ajax、$.get 及$.post）现在都会返回Promise（承诺）对象。</p>
<p>Promise 对象代表一项有两种可能结果（成功或失败）的任务，它还持有多个回调，出现不同结果时会分别触发相应的回调。</p>
<p>进度通知的存在并没有改变每个Promise 对象的最终状态为已执行或<br>已拒绝这一事实。（否则，Promise 对象将永远保持挂起状态。）但为<br>什么要这样呢？为什么不让Promise 对象随时变化成任意的状态，而<br>偏偏只有这两种状态呢？</p>
<iframe width="100%" height="300" src="http://jsfiddle.net/codinglion/826p0n62/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<iframe width="100%" height="300" src="http://jsfiddle.net/codinglion/zpnpzga2/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<iframe width="100%" height="300" src="http://jsfiddle.net/codinglion/toLdwsjv/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>

<iframe width="100%" height="300" src="http://jsfiddle.net/codinglion/1qmmro5o/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


<iframe width="100%" height="300" src="http://jsfiddle.net/codinglion/bfdpnnen/embedded/" allowfullscreen="allowfullscreen" frameborder="0"></iframe>


	
	</div>
  <a type="button" href="/2014/10/31/2014-10-31-ajax_deferred_promise/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-10-31-linux_user_manage/" >linux 用户管理</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>创建一个用户 foo 这个用户只能在/home/foo 上面增加删除文件， foo 不能在其他目录加减文件</p>
<pre><code>useradd -d /home/foo  -m foo
[root@] # passwd jc

chown foo -R /home/foo
</code></pre><p>Linux 系统是一个多用户多任务的分时操作系统，用户在登录时键入正确的用户名和口令后，就能够进入系统和自己的主目录。</p>
<p>用户账号的管理工作主要涉及到用户账号的添加、修改和删除。<br>添加用户账号就是在系统中创建一个新账号，然后为新账号分配用户号、用户组、主目录和登录Shell等资源。刚添加的账号是被锁定的，无法使用。</p>
<h2 id="添加新的用户账号"><a href="#添加新的用户账号" class="headerlink" title="添加新的用户账号"></a>添加新的用户账号</h2><p>使用useradd命令，其语法如下：</p>
<p>代码:<br>useradd 选项 用户名</p>
<p>-c comment 指定一段注释性描述。<br>-d 目录 指定用户主目录，如果此目录不存在，则同时使用 ==-m ==选项，可以创建主目录。<br>-g 用户组 指定用户所属的用户组。<br>-G 用户组，用户组 指定用户所属的附加组。<br>-s Shell文件 指定用户的登录Shell。<br>-u 用户号 指定用户的用户号，如果同时有-o选项，则可以重复使用其他用户的标识号。</p>
<pre><code># useradd –d /usr /sam -m sam
</code></pre><p>此命令创建了一个用户sam，其中-d和-m选项用来为登录名sam产生一个主目录/usr/sam（/usr为默认的用户主目录所在的父目录）。</p>
<pre><code># useradd -s /bin/sh  -g group –G adm,root gem
</code></pre><p>此命令新建了一个用户gem，该用户的登录Shell是/bin/sh，它属于group用户组，同时又属于adm和root用户组，其中group用户组是其主组。</p>
<h2 id="删除帐号"><a href="#删除帐号" class="headerlink" title="删除帐号"></a>删除帐号</h2><p>如果一个用户的账号不再使用，可以从系统中删除。删除用户账号就是要将/etc/passwd等系统文件中的该用户记录删除，必要时还删除用户的主目录。删除一个已有的用户账号使用userdel命令，其格式如下：</p>
<p>代码:<br>userdel 选项 用户名</p>
<p>常用的选项是-r，它的作用是把用户的主目录一起删除。</p>
<p>代码:</p>
<pre><code># userdel sam
</code></pre><p>此命令删除用户sam在系统文件中（主要是/etc/passwd, /etc/shadow, /etc/group等）的记录，同时删除用户的主目录。</p>
<h2 id="修改帐号"><a href="#修改帐号" class="headerlink" title="修改帐号"></a>修改帐号</h2><p>修改用户账号就是根据实际情况更改用户的有关属性，如用户号、主目录、用户组、登录Shell等。</p>
<pre><code>usermod 选项 用户名
</code></pre><p>常用的选项包括-c, -d, -m, -g, -G, -s, -u以及-o等，这些选项的意义与useradd命令中的选项一样，可以为用户指定新的资源值。另外，有些系统可以使用如下选项：</p>
<p>-l 新用户名</p>
<pre><code>#usermod -l urchin(新用户名称)  test(原来用户名称) 
</code></pre><p>这个选项指定一个新的账号，即将原来的用户名改为新的用户名。</p>
<pre><code># usermod -s /bin/ksh -d /home/z –g developer sam
</code></pre><p>此命令将用户sam的登录Shell修改为ksh，主目录改为/home/z，用户组改为developer。</p>
<h2 id="用户口令的管理"><a href="#用户口令的管理" class="headerlink" title="用户口令的管理"></a>用户口令的管理</h2><p>用户管理的一项重要内容是用户口令的管理。用户账号刚创建时没有口令，但是被系统锁定，无法使用，必须为其指定口令后才可以使用，即使是指定空口令。<br>指定和修改用户口令的Shell命令是passwd。超级用户可以为自己和其他用户指定口令，普通用户只能用它修改自己的口令。</p>
<pre><code>passwd 选项 用户名
</code></pre><p>-l 锁定口令，即禁用账号。<br>-u 口令解锁。<br>-d 使账号无口令。<br>-f 强迫用户下次登录时修改口令。<br>如果默认用户名，则修改当前用户的口令。</p>
<p>假设当前用户是sam，则下面的命令修改该用户自己的口令：</p>
<pre><code>$ passwd
Old password:******
New password:*******
Re-enter new password:*******
</code></pre><p>如果是超级用户，可以用下列形式指定任何用户的口令：</p>
<pre><code># passwd sam
New password:*******
Re-enter new password:*******
</code></pre>
	
	</div>
  <a type="button" href="/2014/10/31/2014-10-31-linux_user_manage/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-10-31-闭包和内存/" >为什么闭包会引起内存泄露</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>JavaScript使用一种称为垃圾收集的技术来管理分配给它的内存。这与C这样的底层语言不同，C要求使用多少借多少，用完再释放回去。其他语言，比如 Objective-C，实现了一个引用计数系统来辅助完成这些工作，我们能够了解到有多少个程序块使用了一个特定的内存段，因而可以在不需要时清除这些内存段。</p>
<p>JavaScript是一种高级语言，它一般是通过后台来维护这种计数系统。</p>
<p>当JavaScript代码生成一个新的内存驻留项时（比如一个对象或函数），系统就会为这个项留出一块内存空间。因为这个对象可能会被传递给很多函数，并且会被指定给很多变量，所以很多代码都会指向这个对象的内存空间。JavaScript会跟踪这些指针，当最后一个指针废弃不用时，这个对象占用的内存会被释放。</p>
<pre><code>A ---------&gt; B ------------&gt; C
</code></pre><p>例如对象A有一个属性指向B，而B也有一个属性指向C。即使当前作用域中只有对象A有效，但由于指针的关系所有3个对象都必须保留在内存中。当离开A的当前作用域时（例如代码执行到声明A的函数的末尾处），垃圾收集器就可以释放A占用的内存。此时，由于没有什么指向B，因此B可以释放，最后，C也可以释放。</p>
<p>然而，当对象间的引用关系变得复杂时，处理起来也会更加困难。</p>
<pre><code>A ---------&gt; B ------------&gt; C
             ^、_ _ _ _ _ _ _|
</code></pre><p>这里，我们又为对象C添加了一个引用B的属性。在这种情况下，当A释放时，仍然有来自C的指针指向B。这种引用循环需要由JavaScript进行特殊的处理，但必须考虑到整个循环与作用域中的其他变量已经处于隔离状态。</p>
<p>从这里我们可以看到，闭包问题的本质是作用域的问题，我平时写的闭包大多出现在：</p>
<h3 id="循环引用"><a href="#循环引用" class="headerlink" title="循环引用"></a>循环引用</h3><p>闭包可能会导致在不经意间创建循环引用。因为函数是必须保存在内存中的对象，所以位于函数执行上下文中的所有变量也需要保存在内存中：</p>
<pre><code>function outerFn() {
    var outerVar = {};
    function innerFn() {
        console.log(outerVar);
    }
    outerVar.fn = innerFn;
    return innerFn;
};
</code></pre><p>这里创建了一个名为 outerVar 的对象，该对象在内部函数innerFn()中被引用。然后，为 outerVar 创建了一个指向 innerFn()的属性，之后返回了innerFn()。这样就在 innerFn() 上创建了一个引用outerVar的闭包，而outerVar又引用了innerFn()。</p>
<p>这会导致变量在内存中存在的时间比想象得长，而且又不容易被发现。这还不算完，还有可能会出现比这种情况更隐蔽的引用循环：</p>
<pre><code>function outerFn() {
    var outerVar = {};
    function innerFn() {
        console.log(&apos;hello&apos;);
    }
    outerVar.fn = innerFn;
    return innerFn;
};
</code></pre><p>这里我们修改了innerFn()，不再招惹 outerVar。但是，这样做仍然没有断开循环引用。<br>即使innerFn()不再勾引 outerVar，outerVar 也仍然位于innerFn()的封闭环境中。由于闭包的原因，位于 outerFn()中的所有变量都隐含地被 innerFn()所引用。我们再想一想，在 java 中的内部类不也是类似当前情况吗，内部类能够‘看’外部的 this。此时此刻，正如彼时彼刻，竟如此相像。因此，闭包会使意外地创建这些引用循环变得易如反掌。</p>
<h3 id="DOM与JavaScript的循环"><a href="#DOM与JavaScript的循环" class="headerlink" title="DOM与JavaScript的循环"></a>DOM与JavaScript的循环</h3><p>虽然我很早就知道闭包，也在调试内存问题时在 chrome F12 里的 profile 是里看到 <code>closure reference</code>,但是并不清除这个问题的根源。因为上述情况通常不是什么问题，JavaScript能够检测到这些情况并在它们孤立时将其清除。</p>
<p>最近看到关于这个问题的解释：在旧版本IE中存在一种难以处理的循环引用问题。</p>
<blockquote>
<p>当一个循环中同时包含DOM元素和常规JavaScript对象时，IE无法释放任何一个对象——因为这两类对象是由不同的内存管理程序负责管理的。</p>
</blockquote>
<p>除非关闭浏览器，否则这种循环在IE中永远得不到释放。为此，随着时间的推移，这可能会导致大量内存被无效地占用。</p>
<p>导致这种循环的一个常见原因是简单的事件处理:</p>
<pre><code>$(document).ready(function() {
    var button = document.getElementById(&apos;button-1&apos;);
        button.onclick = function() {
            console.log(&apos;hello&apos;);
            return false;
        };
});
</code></pre><p>当指定单击事件处理程序时，就创建了一个在其封闭的环境中包含button变量的闭包。而且，现在的button也包含一个指向闭包（onclick属性自身）的引用。这样，就导致了在IE中即使离开当前页面也不会释放这个循环。<br>为了释放内存，就需要断开循环引用，例如关闭窗口,删除onclick属性。另外，也可以像下面这样重写代码来</p>
<p>避免这种闭包：</p>
<pre><code>function hello() {
    console.log(&apos;hello&apos;);
    return false;
}

$(document).ready(function() {
    var button = document.getElementById(&apos;button-1&apos;);
    button.onclick = hello;
});
</code></pre><p>因为hello()函数不再包含  button，引用就成了单向的（从button到hello）,不存的循环，所以就不会造成内存泄漏了。</p>
<p>用jQuery化解引用循环</p>
<p>下面，我们通过常规的jQuery结构来编写同样的代码：</p>
<pre><code>$(document).ready(function() {
    var $button = $(&apos;#button-1&apos;);
        $button.click(function(event) {
            event.preventDefault();
            console.log(&apos;hello&apos;);
        });
});
</code></pre><p>即使此时仍然会创建一个闭包，并且也会导致同前面一样的循环，但这里的代码却不会使 <code>IE</code> 发生内存泄漏。由于jQuery考虑到了内存泄漏的潜在危害，所以它会手动释放自己指定的所有事件处理程序。只要坚持使用jQuery的事件绑定方法，就无需为这种特定的常见原因导致的内存泄<br>漏而担心。</p>
<p>但是，这并不意味着我们完全脱离了险境。当对DOM元素进行其他操作时，仍然要处处留心。只要是将JavaScript对象指定给DOM元素，就可能在旧版本IE中导致内存泄漏。jQuery只是有助于减少发生这种情况的可能性。</p>
<p>有鉴于此，jQuery为我们提供了另一个避免这种泄漏的工具。用.data()方法，将信息附加到DOM元素。由于这里的数据并非直接保存在扩展属性中（jQuery使用一个内部对象并通过它创建的ID来保存这里所说的数<br>据），因此永远也不会构成引用循环，从而有效回避了内存泄漏问题。</p>
<p>下面附上 jQuery 源码的相关说法：</p>
<pre><code>// We have to handle DOM nodes and JS objects differently        
   because IE6-7

// can&apos;t GC object references properly across the DOM-JS boundary

// Only DOM nodes need the global jQuery cache; JS object data is

// attached directly to the object so GC can occur automatically
</code></pre>
	
	</div>
  <a type="button" href="/2014/10/31/2014-10-31-闭包和内存/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-31 </div>
			<div class="article-title"><a href="/2014/10/31/2014-08-20-jquery-event-on/" >jQuery-event-on</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p><strong>.on()</strong></p>
<p><strong>.on(event,[,selector][,data],handler)</strong></p>
<p>重点在于这里有个 selector，这个 selector 是对前面选择器的一个细化，选择的是前面选择器的子元素。</p>
<p> 好方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> option = <span class="string">"loading"</span>;</div><div class="line"><span class="keyword">var</span> a = <span class="keyword">typeof</span> option == <span class="string">"object"</span> &amp;&amp; option;</div><div class="line"><span class="keyword">var</span> b = <span class="literal">true</span> &amp;&amp; option;  <span class="comment">// return "loading"</span></div><div class="line"><span class="keyword">var</span> c = <span class="literal">false</span> &amp;&amp; option; <span class="comment">// return false;</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Selector context is implemented with the .find() method;<br>therefore:</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">   $( <span class="string">"li.item-ii"</span> ).find( <span class="string">"li"</span> ) </div><div class="line"><span class="comment">// is equivalent to </span></div><div class="line">   $( <span class="string">"li"</span>, <span class="string">"li.item-ii"</span> ).</div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/10/31/2014-08-20-jquery-event-on/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-10-23 </div>
			<div class="article-title"><a href="/2014/10/23/2014-10-23-看待不完美/" >不完美</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h1 id="不完美"><a href="#不完美" class="headerlink" title="不完美"></a>不完美</h1><p>黄金是不完美的，</p>
<p>钻石是不完美的，</p>
<p>它们都不纯。</p>
<p>手机不是完美的，</p>
<p>平板不是完美的，</p>
<p>他们太小了，他们没有键盘。</p>
<p>书本是不完美的，太沉，没法搜索，</p>
<p>pdf 也是不完美的，看它们的设备太少。</p>
<p>vim 是不完美的，小问题太多。</p>
<p>我，我自己也是不完美的，</p>
<p>对！</p>
<p>通通不完美！</p>
<p>然而，什么东西又是完美的呢？</p>
<p>眼睛里放的总是不完美，那么天空是暗淡的，</p>
<p>可我要的又是什么呢？</p>
<p>我要的就是使用我身边不完美的东西，</p>
<p>去创造出属于我的同样不完美的完美。</p>
<blockquote>
<p>2014年10月23日 跑步归来有感</p>
</blockquote>

	
	</div>
  <a type="button" href="/2014/10/23/2014-10-23-看待不完美/#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/6/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/8/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			 

		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/bom/">bom<span>1</span></a></li>
		
			<li><a href="/categories/css/code/">code<span>1</span></a></li>
		
			<li><a href="/categories/collection/">collection<span>1</span></a></li>
		
			<li><a href="/categories/css/">css<span>2</span></a></li>
		
			<li><a href="/categories/tools/debug/">debug<span>1</span></a></li>
		
			<li><a href="/categories/default/">default<span>1</span></a></li>
		
			<li><a href="/categories/http/">http<span>1</span></a></li>
		
			<li><a href="/categories/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/categories/javascript-test/">javascript test<span>1</span></a></li>
		
			<li><a href="/categories/jquery/">jquery<span>1</span></a></li>
		
			<li><a href="/categories/js/">js<span>1</span></a></li>
		
			<li><a href="/categories/library/">library<span>2</span></a></li>
		
			<li><a href="/categories/note/">note<span>1</span></a></li>
		
			<li><a href="/categories/note-vim/">note vim<span>2</span></a></li>
		
			<li><a href="/categories/tool/">tool<span>3</span></a></li>
		
			<li><a href="/categories/tools/">tools<span>1</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/linux/">linux<span>5</span></a></li>
		
			<li><a href="/tags/demo/">demo<span>1</span></a></li>
		
			<li><a href="/tags/mobile/">mobile<span>1</span></a></li>
		
			<li><a href="/tags/module/">module<span>2</span></a></li>
		
			<li><a href="/tags/git/">git<span>4</span></a></li>
		
			<li><a href="/tags/webcomponent-framework/">webcomponent,framework<span>1</span></a></li>
		
			<li><a href="/tags/html-优化/">html 优化<span>1</span></a></li>
		
			<li><a href="/tags/shell/">shell<span>1</span></a></li>
		
			<li><a href="/tags/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/tags/js/">js<span>1</span></a></li>
		
			<li><a href="/tags/test/">test<span>3</span></a></li>
		
			<li><a href="/tags/html/">html<span>2</span></a></li>
		
			<li><a href="/tags/javascript/">javascript<span>9</span></a></li>
		
			<li><a href="/tags/library/">library<span>3</span></a></li>
		
			<li><a href="/tags/javascript-test/">javascript test<span>1</span></a></li>
		
			<li><a href="/tags/code/">code<span>2</span></a></li>
		
			<li><a href="/tags/seajs/">seajs<span>1</span></a></li>
		
			<li><a href="/tags/html5/">html5<span>1</span></a></li>
		
			<li><a href="/tags/hg/">hg<span>1</span></a></li>
		
			<li><a href="/tags/design-pattern/">design pattern<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>41</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/04/23/css书写规范/" ><i class="fa fa-file-o"></i>css 编写习惯</a>
      </li>
    
      <li>
        <a href="/2017/04/23/消除函数的术语歧义/" ><i class="fa fa-file-o"></i>消除函数的术语歧义</a>
      </li>
    
      <li>
        <a href="/2017/04/23/脚本的第一行/" ><i class="fa fa-file-o"></i>脚本语言的第一行</a>
      </li>
    
      <li>
        <a href="/2017/04/23/设计模式简介/" ><i class="fa fa-file-o"></i>设计模式简介</a>
      </li>
    
      <li>
        <a href="/2017/04/23/2013-11-09-requirejs/" ><i class="fa fa-file-o"></i></a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/chenyakun" title="My Github repository." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 yakun.cyk
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<!-- <script src="/js/search.js"></script>  -->

<!-- 
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>
 -->

<!-- 
   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>
 -->

<div class="cb-search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px;
        opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">

    <input type="text" class="cb-search-content" id="cb-search-content" style="position: fixed; top: 60px" placeholder="文章标题 日期 标签" />

    <div style="position: fixed; top: 16px; right: 16px;">
        <img src="/search/img/cb-close.png"  id="cb-close-btn"/>
    </div>
</div>

<!-- <div style="position: fixed; right: 16px; bottom: 20px;">
    <img src="/search/img/cb-search.png"  id="cb-search-btn"  title="双击ctrl试一下"/>
</div> -->

<link rel="stylesheet" href="/search/css/cb-search.css">
<script src="/search/js/bootstrap3-typeahead.min.js"></script>
<script src="/search/js/cb-search.js"></script>

</body>
   </html>
