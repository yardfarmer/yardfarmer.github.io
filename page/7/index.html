<!DOCTYPE HTML>
<html>
<head>
  <meta charset="utf-8">
  
  <title>第 7 页 | output stream</title>
  <meta name="author" content="yakun.cyk">
  
  <meta name="description" content="主要内容可能关于 web 技术，感慨心得...">
  
  
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  
  <meta property="og:site_name" content="output stream"/>

  
    <meta property="og:image" content="undefined"/>
  

  
  
    <link href="/favicon.png" rel="icon">
  
  
  <link rel="stylesheet" href="/css/bootstrap.min.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/font-awesome.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/style.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/responsive.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/highlight.css" media="screen" type="text/css">
  <link rel="stylesheet" href="/css/google-fonts.css" media="screen" type="text/css">
  <!--[if lt IE 9]><script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script><![endif]-->

  <script src="/js/jquery-2.0.3.min.js"></script>

  <!-- analytics -->
  



</head>

 <body>  
  <nav id="main-nav" class="navbar navbar-inverse navbar-fixed-top" role="navigation">
  <div class="container">
    <button type="button" class="navbar-header navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
	    <span class="sr-only">Toggle navigation</span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
      <span class="icon-bar"></span>
    </button>
	  <a class="navbar-brand" href="/">output stream</a>
      <div class="collapse navbar-collapse nav-menu">
		    <ul class="nav navbar-nav">
    		  
    		  <li>
    			 <a href="/demos" title="Demos.">
            <i class="fa fa-flask"></i>Demos
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/archives" title="All the articles.">
            <i class="fa fa-archive"></i>归档
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/about" title="About me.">
            <i class="fa fa-user"></i>关于我
    			 </a>
    		  </li>
    		  
    		  <li>
    			 <a href="/#" title="Search Posts.">
            <i class="fa fa-search"></i>搜索
    			 </a>
    		  </li>
    		  
    		</ul>
      </div>
    </div> <!-- container -->
</nav>
<div class="clearfix"></div>

  <div class="container">
  	<div class="content">
    	 <div class="row page">

	
	<div class="col-md-9">
	

		<div class="slogan">
      <!--
        <i class="fa fa-heart"></i> 
      -->
      
</div>    
		<div id="top_search"></div>
		<div class="mypage">
		
		<!-- title and entry -->
		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-30 </div>
			<div class="article-title"><a href="/2014/12/30/2013-12-30-http学习札记/" >http学习札记</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>HTTP 报文会像河水一样流动。不管是请求报文还是响应报文，所有报文都会向下游（downstream） 流动。所有报文的发送者都在接收者的上游。</p>
</blockquote>
<p>HTTP 报文是简单的格式化数据块。</p>
<p>报文块由三个部分组成：</p>
<pre><code>1. 对报文进行描述的起始行（start line）、 //  HTTP/1.0 200 OK
2. 包含属性的首部（header）块，{
    Content-type: text/plain
    Content-length: 100
}
3. 以及可选的、包含数据的主体（body）部分。(get 没有数据主体).
</code></pre><p>起始行和首部就是由行分隔的ASCII 文本。<br>每行都以一个由两个字符组成的行终止序列(CRLF, Carriage Return Line Feed)作为结束，其中包括一个回车符（ASCII 码13）和一个换行符（ASCII 码10）。</p>
<p>所有的HTTP 报文都可以分为两类： 请求报文（request message） 和响应报文（response message）。<code>本质就是 socket</code>。</p>
<ul>
<li>GET  从服务器获取一份文档        不包含主体</li>
<li>POST 向服务器发送需要处理的数据  包含主体 </li>
<li>HTTP 报文可以承载很多类型的数字数据：图片、视频、HTML 文档、软件应用程序、信用卡事务、电子邮件等。</li>
<li>POST 方法起初是用来向服务器输入数据的.</li>
</ul>
<p>重定向状态码要么告知客户端使用替代位置来访问他们所感兴趣的资源，要么就提供一个替代的响应而不是资源的内容。<br>如果资源已被移动，可发送一个重定向状态码和一个可选的Location 首部来告知客户端资源已被移走，以及现在可以在哪里找到它。<br>浏览器就可以在不打扰使用者的情况下，透明地转入新的位置了。(地址栏直接跳转).</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="selector-tag">Remote</span> <span class="selector-tag">Address</span><span class="selector-pseudo">:128.121.66.211</span><span class="selector-pseudo">:80</span> (通过ip-&gt;dns查询来的)</div><div class="line"><span class="selector-tag">Request</span> <span class="selector-tag">URL</span><span class="selector-pseudo">:http</span>:<span class="comment">//www.joes-hardware.com/pet-products.txt</span></div><div class="line"><span class="selector-tag">Request</span> <span class="selector-tag">Method</span><span class="selector-pseudo">:GET</span></div><div class="line"><span class="selector-tag">Status</span> <span class="selector-tag">Code</span><span class="selector-pseudo">:301</span> <span class="selector-tag">Moved</span> <span class="selector-tag">Permanently</span></div><div class="line"><span class="selector-tag">RequestHeaders</span></div><div class="line"><span class="comment">// Accept:text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8</span></div><div class="line"><span class="comment">// Accept-Encoding:gzip,deflate,sdch</span></div><div class="line"><span class="comment">// Accept-Language:en,zh-CN;q=0.8,zh;q=0.6,ja;q=0.4</span></div><div class="line"><span class="comment">// Cache-Control:no-cache</span></div><div class="line"><span class="comment">// Connection:keep-alive</span></div><div class="line"><span class="comment">// DNT:1</span></div><div class="line"><span class="comment">// Host:www.joes-hardware.com</span></div><div class="line"><span class="comment">// Pragma:no-cache</span></div><div class="line"><span class="comment">// User-Agent:Mozilla/5.0</span></div><div class="line"></div><div class="line"><span class="selector-tag">ResonseHeaders</span></div><div class="line"><span class="comment">// Connection:Keep-Alive</span></div><div class="line"><span class="comment">// Content-Length:377</span></div><div class="line"><span class="comment">// Content-Type:text/html; charset=iso-8859-1</span></div><div class="line"><span class="comment">// Date:Wed, 01 Oct 2014 15:22:05 GMT</span></div><div class="line"><span class="comment">// Keep-Alive:timeout=15, max=98</span></div><div class="line"><span class="comment">// Location:http://www.gentle-grooming.com/</span></div><div class="line"><span class="comment">// Server:Apache/2.2.22 (Unix) DAV/2 FrontPage/5.0.2.2635 mod_ssl/2.2.22 OpenSSL/1.0.1h</span></div></pre></td></tr></table></figure>
<p>Location 用于跳转,在相应的 header 中直接提供了 Location 跳转的 url </p>
<p>301 Moved Permanently 在请求的URL 已被移除时使用。响应的Location 首部中应该包含资源现在所处的URL.</p>
<p>304 Not Modified 客户端可以通过所包含的请求首部，使其请求变成有条件的。<br>如果客户端发起了一个条件GET请求，而最近资源未被修改的话，就可以用这个状态码来说明资源未被修改。<br>带有这个状态码的响应不应该包含实体的主体部分。</p>
<p>标识为no-cache 的响应实际上是可以存储在本地缓存区中的。只是在与原始服务器进行新鲜度再验证之前，缓存不能将其提供给客户端使用。</p>
<p>HTTP/1.1 中提供Pragma: no-cache 首部是为了兼容于HTTP/1.0+。除了与只理解Pragma: no-cache 的HTTP/1.0 应用程序进行交互时，HTTP 1.1 应用程序都应该使用 Cache-Control: no-cache.</p>
<p>Cache-Control: max-age 首部表示的是从服务器将文档传来之时起，可以认为此文档处于新鲜状态的秒数.</p>
<p>服务器可以请求缓存不要缓存文档，或者将最大使用期设置为零，从而在每次访问的时候都进行刷新：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Cache</span><span class="params">-Control</span>: <span class="keyword">max</span><span class="params">-age</span>=<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>http-equiv 元信息告诉浏览器如何去做，等效于设置了HTTP 报头。<br>这让你可以向浏览器传达一些原本由服务器告诉它的内容。当你不能控制服务器时，它特别有用。 (这句话很有内容，请求网页使，服务器在响应头里是可以设置属性的，但是如果没有设置。同样也可以在 header 里设置上。效果一样。)</p>
<p>例如，如果你想设置一个缓存头，但又不能控制服务器，你可以使用http-equiv 属性：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"expires"</span> <span class="attr">content</span>=<span class="string">"Wed, 05 August 2020 00:00:00 GMT"</span>&gt;</span>.</div></pre></td></tr></table></figure></p>
<p>http-equiv 属性是 http 协议的响应头报文，此属性出现在 meta 标签中。属性值用 content 属性描述当浏览器等设备接收服务器端传送的文件时，首先会接收文件的相关”(名称/值对)”，通常为多个。<br>所有服务器都至少要发送一个：<code>content-type:text/html</code>。这将告诉浏览器准备接受一个 HTML 文档。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"5; url=http://www.a.com/"</span> /&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"pragma"</span> <span class="attr">content</span>=<span class="string">"no-cache"</span> /&gt;</span></div></pre></td></tr></table></figure>
<p>会产生：<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">Cache</span><span class="params">-Control</span>:<span class="keyword">max</span><span class="params">-age</span>=<span class="number">0</span></div></pre></td></tr></table></figure></p>
<p>no-store 在response 头中是为了声明不让浏览器 存储这次响应的信息。<br>max-age 这个声明过期时间的。单位为秒 0 肯定就是不缓存了。<br>两个选项对于Cache 系统来说。都是比较有用的。</p>
<p>关于 session，cookie，jsessionid 的关系。 session 就是 httpsession，服务器端的， cookie 就是浏览器端的。</p>
<p>在 servlet 里使用了</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">HttpSession session</span> = request.getSession();</div><div class="line"><span class="attribute">String sessionid</span> = session.getId();</div></pre></td></tr></table></figure>
<p>获取了 session ，即使没有在 session 里设置数据，那么在响应里也会去设置 cookie。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="string">Server:</span>Apache-Coyote/<span class="number">1.1</span></div><div class="line">Set-<span class="string">Cookie:</span>JSESSIONID=<span class="number">3</span>B44FEAE6B662D94F4F23DD8EC2D2697; Path=<span class="regexp">/nodeA/</span>; HttpOnly</div></pre></td></tr></table></figure>
<p>并且有意思的是：如果在浏览器里把 cookie 删掉，那么下一次给服务器发请求，那么必然不会带着 cookie。所以服务器在没有 cookie 的请求中会在响应(因为没有把 cookie 中的 sessionid 带上，那么服务器认为这个客户端还没有对应的 session，于是发一个 session 给这个客户端，并且在返回响应的时候顺便设置在 cookie 上)的时候给带上 cookie（sessionid）。</p>
<p>如果客户端在请求的时候把 cookie(seessionid)带上了，那么服务器就不会在响应中设置 cookie 了。如果浏览器把 cookie 禁用了，那么新的 cookie 是存不到浏览器的，响应的时候带着 cookie 也不管用，存不上。  但是禁用cookie 后，浏览器中存储的囤积的还是可以发送出去的。 </p>
<p>那么问题来了，浏览器把 cookie 禁用了怎么办？ 请求的时候把 sessionid 存放到,貌似没有什么好办法，因为禁用 cookie，服务器的 sessionid 传不进来。在禁用 cookie 的情况下，taobao 登陆不上去，页面显示有问题。 amazon，jd 直接在登陆界面提示，不设置 cookie 登陆不进去。</p>
<p>首部 Referer 请求用户是从这个页面上依照链接跳转过来的. Referer 首部提供了用户来源页面的 URL。改动后包含了用户状态信息的URL 被称为胖URL（fat URL）。</p>
<p>可以笼统地将cookie 分为两类： 会话cookie 和持久cookie。会话cookie 是一种临时cookie，它记录了用户访问站点时的设置和偏好。用户退出浏览器时，会话 cookie 就被删除了。</p>
<p>持久cookie 的生存时间更长一些；它们存储在硬盘上，浏览器退出，计算机重启时它们仍然存在。通常会用持久cookie 维护某个用户会周期性访问的站点的配置文件或登录名。</p>
<p>如果设置了Discard 参数，或者没有设置Expires 或Max-Age 参数来说明扩展的客户端识别与cookie机制过期时间，这个cookie 就是一个会话cookie。</p>
<p>浏览器会记住从服务器返回的Set-Cookie 或Set-Cookie2 首部中的cookie 内容，并将cookie 集存储在浏览器的 cookie 数据库中,将来用户返回同一站点时,浏览器会挑中那个服务器贴到用户上的那些cookie，并在一个cookie 请求首部中将其传回去。 </p>
<p>浏览器只向服务器发送服务器产生的那些cookie。(谁拿来的，再给谁拿回去)</p>
<p>版本 0 的Cookie首部客户端发送请求时，会将所有与域、路径和安全过滤器相匹配的未过期cookie 都发送给这个站点。<br>所有cookie 都被组合到一个Cookie 首部中：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Cookie: session-<span class="built_in">id</span>=<span class="number">002</span><span class="number">-1145265</span><span class="number">-8016838</span>; session-<span class="built_in">id</span>-<span class="built_in">time</span>=<span class="number">1007884800</span></div></pre></td></tr></table></figure>
<p>如果客户端既支持版本0 又支持版本1 的cookie，但从服务器获得的是版本0 的<br>Set-Cookie 首部，就应该带着版本0 的Cookie 首部发送cookie。</p>
<p>在绝大多数浏览器中，可以通过检测<br>navigator.cookieEnabled<br>这个属性实现。</p>
<p>但是为 false 也不代表不能用 cookie，只是表示不能使用持久化 cookie<br>“当前浏览会话生命周期” 的非持久化cookie仍然是启用的。</p>
<p>coookie 的作用域并不是局限在浏览器的单个窗口中，它的有效期和整个浏览器进程而不是单个浏览器窗口的有效期一致。</p>
<p>一且设置了有效期，浏览器就会将cookie数据存储在一个文件中，并且直到过了指定的有效期才会删除该文件。</p>
<p>默认情况下， cookie 和创建它的Web页面有关，并对该Web页面以及和该Web页面同目录或者子目录的其他Web页面可见。对其他目录的文件不可见，即使相同域名。如果把路径设置成”/“ , 那么该cookie对 ‘<a href="http://www.example.com`" target="_blank" rel="external">http://www.example.com`</a> 这台Web服务器上的页面都是可见的。</p>
<p>cookie的 path 属性不能被用做访问控制机制。如果一个Web页面想要读取同站点其他页面的cookie ，只要简单地将其他页面以隐藏<code>&lt;iframe&gt;</code>的形式加载进来，随后读取对应文档的cookie就可以了。同源策略限制了跨站的cookie窥探，但是对于同一站点的文档它是完全合法的。</p>
<p>有的大型网站想要子域之间能够互相共享 cookie. 比如， order.example.com 域下的服务器想要读取catalog.example.com域下设置的cookie值。这个时候就需要通过设置cookie的domain属性来达到目的.  比如设置 document.domain = “example.com”</p>
<p><strong> domain属性的默认值是当前Web服务器的主机名.</strong> 由于cookie的名/值中的值是不允许包含分号、逗号和空白符，因此，在存储前一般可以采用JavaScript核心的全局函数 encodeURIComponent() 对值进行编码。</p>
<p>处理 cookie 的技巧：</p>
<ul>
<li>要改变cookie的值，需要使用相同的名字、路径和域，再使新的值重新设置cookie 的值。</li>
<li>delete 将max-age属性指定为0 ，再次设置cookie 。</li>
<li>document.cookie // 返回所有作用在当前文档的所有 cookie ，多个 cookie 的集合的字符串形式。</li>
</ul>
<blockquote>
<p>  <code>RFC 2965</code> 规定 cookie 不超过300个，为每个Web服务器保存的cookie数不能超过20个,数据不能超过4KB, 现代浏览器允许 cookie 超过300个。</p>
</blockquote>
<p>要给当前文档设置 cookie 值，非常简单，只须将cookie属性设置为一个字符串形式的值:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.cookie=<span class="string">'name_self=abc'</span>;</div><div class="line"><span class="built_in">document</span>.cookie=<span class="string">'name_self=abc;max-age=10'</span>; <span class="comment">// 10秒后过期</span></div><div class="line"><span class="built_in">document</span>.cookie=<span class="string">"name_self=abc;max-age=10;path='/path';domain='http://.domain.com';"</span>; <span class="comment">// 10秒后过期,由于设置了 domain 不限于 domain.com/path/xx  path 目录及其子目录的访问，其他子域名也可访问 cookie。</span></div></pre></td></tr></table></figure>
<p>IE5 以及 IE5 以上版本的浏览器是通过在document元素后面附加一个专属的”DHTML行为”来实现客户端存储的。<br>如  </p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">&lt;!--[<span class="keyword">if</span> IE]&gt;</div><div class="line"></div><div class="line">memory.style.behavior = <span class="string">"url('#default#userData')"</span> </div><div class="line"></div><div class="line">&lt;![endif]--&gt;</div></pre></td></tr></table></figure>
<p>附加userData行为。</p>
<h3 id="网络相关的长度问题"><a href="#网络相关的长度问题" class="headerlink" title="网络相关的长度问题"></a>网络相关的长度问题</h3><p>Http  Get方法提交的数据大小长度并没有限制，HTTP协议规范没有对URL长度进行限制。这个限制是特定的浏览器及服务器对它的限制。<br>IE     限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。<br>Firefox 对于Firefox浏览器URL的长度限制为 65536 个字符。<br>Safari  URL最大长度限制为 80000 个字符。<br>Opera   URL最大长度限制为 190000 个字符。<br>Google  URL最大长度限制为 8182 个字符。<br>Apache  能接受最大url长度为 8192 个字符。</p>
<p>Post 长度限制<br>在Tomcat下取消POST大小的限制（Tomcat默认2M）；<br>打开tomcat目录下的conf目录，打开server.xml 文件，修改maxPostSize</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="comment">&lt;!-- &lt;meta http-equiv="refresh" content="5" /&gt; --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">http-equiv</span>=<span class="string">"refresh"</span> <span class="attr">content</span>=<span class="string">"10;url=http://baidu.com"</span> /&gt;</span></div><div class="line"><span class="comment">&lt;!-- 10表示10秒，0即为立即跳转 --&gt;</span></div></pre></td></tr></table></figure>
<h3 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h3><p>首先，浏览器需要知道该网站的IP 地址。它向DNS 服务器发送一个包含域名的请求， 然后DNS 服务器返回给<code>浏览器</code>对应的IP 地址。为了减少DNS 服务器上的负载，并提高性能，DNS 查找机制会被浏览器、设备或设备和服务器之间的路由器和代理服务器缓存。这就是为什么更改DNS 记录可能需要几天才能生效的原因。</p>
<h3 id="浏览器是如何显示页面的？"><a href="#浏览器是如何显示页面的？" class="headerlink" title="浏览器是如何显示页面的？"></a>浏览器是如何显示页面的？</h3><ol>
<li>发起请求 </li>
<li>ip地址 返回给浏览器。</li>
<li><p>然后，浏览器会向由DNS 查找得到的IP 地址的主机发起TCP 连接。然后发送请求。<code>Remote Address:106.38.179.49:80</code>, 请求中包含网址、浏览器信息、浏览器能接受的数据类型（编码和语言），以及所有相关的cookie，包括域和路径的cookie。</p>
</li>
<li><p>发起请求, 浏览器开始下载响应。随着响应流到达，浏览器解析HTML 并识别出更多的资源。然后浏览器开始获取这些资源。</p>
</li>
<li><p>渲染页面,最后浏览器会尽快开始渲染页面。如果页面中外链了CSS 或脚本文件时，浏览器会等到这些文件加载和解析（如果是JavaScript 代码，则还需要执行）完再渲染页面。</p>
</li>
</ol>
<h3 id="为什么页面加载缓慢？"><a href="#为什么页面加载缓慢？" class="headerlink" title="为什么页面加载缓慢？"></a>为什么页面加载缓慢？</h3><p>为什么页面加载缓慢？以下是可能的原因：</p>
<ul>
<li>HTTP 连接数</li>
<li>总的字节数</li>
<li>等待时的渲染阻塞</li>
<li>延迟</li>
<li>缓存能力差</li>
</ul>
<p>我们先把重点放在“网络”选项卡上，它有一个美丽的瀑布图，向我们展示了页面加载时的各种信息。<br>每一栏上的浅色代表的延迟，深色代表下载。</p>
<p>iOS 上的Safari 浏览器支持同一域下的最多 6 个资源并行下载。<br>虽然可以通过添加额外的域名（也许是通过设置别名或子域名）的方式来并行下载更多的文件，但每次请求还是需要承担HTTP 层面的开销。</p>
<p>对于图片，因为下载占到了请求时间的绝大部分，所以并行下载更好。出于这个原因（以及一些其他的原因），在网站上将图像与其他资源置于不同的域下是合理的。<br>(对图片设置 cookie 是完全没有必要的，所以最好给图片单独提供一个域名,可能放在专用的图片服务器上了)</p>
<p>雅虎的Steve Souders 和YSlow 团队发现，为当前域创建两个别名，能允许更多的下载并行，会使大文件下载的性能明显改善。</p>
<p>它的第一次加载必然比部署在多个域下的慢。不过由于每个域都需要进行DNS 查找， 添加太多的域反而会更慢。<br>使用至少两个，至多不超过五个域是YSlow 的经验法则。</p>
<p>如果一个 cookie 与请求的域名或路径相匹配，它会伴随着每次请求发送（即上传）。 所以，如果你在你的域名下的第一个请求中设置了几千字节的cookie，那么此后发送到这个域的每次请求都将把这些字节包含在请求头里，然后发送、解压缩。</p>
<p>服务器还必须在读取请求体之前读取这些cookie。cookie 可以把一个很小的请求变得很大。</p>
<p>高延迟使因请求量大而导致的问题激增，因为每次请求都因延迟增加了往返的时间。</p>
<p>对于低流量的网站 CDN 的帮助不大。 不过，把你的静态文件放在一个单独的没有 cookie 的域下总是有帮助的。<br>所以，如果有条件，务必做到这一点。 如果一个 cookie 与请求的域名或路径相匹配，它会伴随每次请求发送。 所以如果你在你的域名下的第一个请求。 （这里说第一个请求是有原因的，因正常情况下后续的服务器响应是不会再次设置 cookie 的。 没有必要在重新设置。 除非在每次服务器响应的时候强制在 response 里设置了 cookie， 这样才可能在每次的响应头中看到 set-cookie。 酱紫。）</p>
<p>设置了几千个字节的 cookie，那么此后发送到这个域的每次请求都会把这些 cookie 包含在请求头中带回去, 导致 cookie 很耗费资源。</p>
<p>另一个有价值的工具是 Charles proxy（Charlesproxy.com）。<br>Charles 是一个本地工具，能让你检查每一个请求，给请求添加断点，还可以模拟低带宽环境。<br>当开发工具没有给出关于HTTP 的更多信息时，Charles 可以帮助你。</p>
<p>pageSpeed 把规则划分为六类：</p>
<ul>
<li>缓存优化，使页面的应用逻辑实现和所需数据一并离线缓存。</li>
<li>往返时间最小化，减少请求响应的周期次数。</li>
<li>请求开销最小化，减少上传数据包大小，（数据包，cookie 在 header 里）</li>
<li>有效负载最小化，减少响应包，下载包和缓存页面的大小。(压缩,图像压缩)</li>
<li>浏览器渲染优化，改进浏览器的页面布局。</li>
<li>移动设备优化，为移动而优化。</li>
</ul>
<blockquote>
<p>对移动端建议：“”延迟 javasript 解析(不必要的 js 不要放在 header)”+“”使首页的重定向可缓存”</p>
</blockquote>
<p>link 标签上的关于媒体查询的css文件，即使查询的结果不合适，也还是会下载的。只不过是不用。</p>
<h2 id="XSS-的防御-输入框验证"><a href="#XSS-的防御-输入框验证" class="headerlink" title="XSS 的防御(输入框验证)"></a>XSS 的防御(输入框验证)</h2><h3 id="什么是-XSS-（cross-site-script）"><a href="#什么是-XSS-（cross-site-script）" class="headerlink" title="什么是 XSS （cross site script）"></a>什么是 XSS （cross site script）</h3><p>为了防止与层叠样式表css混淆，改为 xss； 通常表现为通过输入框插入非法脚本，获取其他用户安全信息。</p>
<p>HTTPOnly ，一个成熟的标准， 浏览器将禁止页面中的 js 访问带有 HTTPOnly 属性的 cookie。<br>IE 6 和 其他现代浏览器均已支持这个标准。所以，HttpOnly 不是用于对抗 XSS，它是用于在 XSS 攻击后，防护 cookie 被读取，从而使大部分 XSS 攻击失去了意义。</p>
<h3 id="一个-cookie-使用的过程大概是这样的："><a href="#一个-cookie-使用的过程大概是这样的：" class="headerlink" title="一个 cookie 使用的过程大概是这样的："></a>一个 cookie 使用的过程大概是这样的：</h3><ol>
<li>浏览器像服务器发起请求，这时没有设置 cookie。</li>
<li>服务器返回发送 Set-Cookie Header， 向客户端浏览器写入 Cookie。</li>
<li>在 cookie 到期前，浏览器发起的所有的请求(即使 ajax，图片)，都会在请求头里写入 cookie。</li>
</ol>
<p>HttpOnly的使用是十分灵活的，它可以只用在最核心的位置。 比如我们的应用中会设置多个 cookie，而 HttpOnly 可以有选择的加在关键 cookie上，实施关键目标重点保护。</p>
<p>给 Cookie 添加 HttpOnly 的代码：</p>
<p>java:</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">Java:</div><div class="line">		Cookie coki1 = new Cookie("get_acookie_1", "acookieValue");</div><div class="line">		response.addCookie(coki1);</div><div class="line">		Cookie coki2 = new Cookie("get_acookie_2", "acookieValue");</div><div class="line">        // Cookie coki2 = new Cookie("get_acookie_2", "acookieValue;HTTPOnly"); // 这样不管用 </div><div class="line">		coki2.setHttpOnly(true); // ok</div><div class="line">		response.addCookie(coki2);</div><div class="line">C#:</div><div class="line">		HttpCookie ck = new HttpCookie('myCookie');</div><div class="line">		ck.HttpOnly = true;</div><div class="line">		Response.AppendCookie(ck);</div></pre></td></tr></table></figure>
<h3 id="输入检查"><a href="#输入检查" class="headerlink" title="输入检查"></a>输入检查</h3><p>XSS 攻击一般都是在输入框等输入位置输入一些由特殊字符组成的攻击脚本。</p>

	
	</div>
  <a type="button" href="/2014/12/30/2013-12-30-http学习札记/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-28 </div>
			<div class="article-title"><a href="/2014/12/28/2014-12-28-http协议相关知识整理/" >http协议相关知识整理</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>##连接</p>
<p>在HTTP 客户端向服务器发送报文之前，需要用网际协议（Internet Protocol，IP） 地址和端口号在客户端和服务器之间建立一条TCP/IP 连接。<br>HTTP 连接实际上就是TCP 连接及其使用规则。TCP 连接是因特网上的可靠连接。TCP 为HTTP 提供了一条可靠的比特传输管道。从TCP 连接一端填入的字节会从另一端以原有的顺序、正确地传送出来。</p>
<p>浏览器访问服务器的过程：</p>
<ol>
<li>浏览器解析出主机名</li>
<li>浏览器查询这个主机名的IP地址（DNS）</li>
<li>浏览器获得端口号（80）</li>
<li>浏览器发起到 x.x.x.x 端口 xx 的连接</li>
<li>浏览器向服务器发送一条HTTP GET报文</li>
<li>浏览器从服务器读取HTTP响应报文</li>
</ol>
<p>HTTP 事务的时延有以下几种主要原因:</p>
<ol>
<li>客户端首先需要根据URI 确定Web 服务器的IP 地址和端口号。如果最近没有对 URI 中的主机名进行访问，通过DNS 解析系统将URI 中的主机名转换成一个IP 地址可能要花费数十秒的时间。</li>
<li>接下来，客户端会向服务器发送一条TCP 连接请求，并等待服务器回送一个请 求接受应答。每条新的TCP 连接都会有连接建立时延。这个值通常最多只有一 两秒钟，但如果有数百个HTTP 事务的话，这个值会快速地叠加上去。</li>
<li>一旦连接建立起来了，客户端就会通过新建立的TCP 管道来发送HTTP 请求。 数据到达时，Web 服务器会从TCP 连接中读取请求报文，并对请求进行处理</li>
</ol>
<p>大多数HTTP 客户端都有一个小的DNS 缓存，用来保存近期所访问站点的IP 地址。如果 已经在本地“缓存”（记录）了IP 地址，查询就可以立即完成。因为大多数Web 浏览器浏览的都是少数常用站点，所以通常都可以很快地将主机名解析出来。</p>

	
	</div>
  <a type="button" href="/2014/12/28/2014-12-28-http协议相关知识整理/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-27 </div>
			<div class="article-title"><a href="/2014/12/27/2014-12-27-brick/" >brick</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>先占坑。。<br><a href="https://mozbrick.github.io/blog/" target="_blank" rel="external">https://mozbrick.github.io/blog/</a></p>

	
	</div>
  <a type="button" href="/2014/12/27/2014-12-27-brick/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-25 </div>
			<div class="article-title"><a href="/2014/12/25/2014-12-25-git/" >git</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>#分布式版本管理的优点</p>
<p>最初的克隆时间较长,特别是历史记录很长的时候,但最终这个本地镜像备份会带来很多优势.一个显而易见的好处是,当产看一个旧版本时不需要和中心服务器通信.</p>
<h1 id="基本技巧"><a href="#基本技巧" class="headerlink" title="基本技巧"></a>基本技巧</h1><h2 id="git-文件的三种状态"><a href="#git-文件的三种状态" class="headerlink" title="git 文件的三种状态"></a>git 文件的三种状态</h2><ol>
<li>暂存 staged </li>
<li>修改 modify</li>
<li>已提交</li>
</ol>
<p>记录当前状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">git init</div><div class="line">git add .</div><div class="line">git commit -m <span class="string">"my commit description"</span></div></pre></td></tr></table></figure></p>
<p>回退原来编辑的地方,会退到上次版本提交后的最初状态<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git reset --hard</div></pre></td></tr></table></figure></p>
<p>操作是针对本地版本库中已存在文件的操作, 针对已存在本地版本的文件的修改会完全回退,不管是否已经 <code>git add</code>过,<br>针对新加入的文件, add 之前的文件不会删除掉(untracked file: 尚未加入版本控制), add 之后的文件会被抹掉.</p>
<p>git add 操作开始跟踪文件,但是还没有提交版本库, 类似 hibernate 中的持久态, 具有 id,具有 session 管理.<br>在 commit 之前还没有进入到托管的游离态(所以只有 commit 之前可以进行 git reset 操作).<br>add 之前的文件可以看作是 transient 瞬态, 通过 git add 便把无管理的文件进入到持久态, 受到 git 管控.</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add NEWFILES</div></pre></td></tr></table></figure>
<p>删除, 将文件从本地目录，缓存区中删除,提交后才会在本地仓库中删除。</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git</span> rm OLDFILES <span class="comment">#</span></div></pre></td></tr></table></figure>
<p>重命名, 不能进行无版本控制的文件,git 还管控不到</p>
<figure class="highlight cos"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">mv</span> OLDFILES NEWFILES</div></pre></td></tr></table></figure>
<p>看日志</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="built_in">log</span></div></pre></td></tr></table></figure>
<p>彻底恢复到指定版本,并且从记录里永久删除掉所有的后续记录</p>
<figure class="highlight sql"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git <span class="keyword">reset</span> <span class="comment">--hard SHA1_HASH</span></div></pre></td></tr></table></figure>
<p>简单的恢复到以前的某个状态,穿越回去还能回来:</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git</span> checkout SHA1_HASH</div></pre></td></tr></table></figure>
<p>checkout 可以回到过去,并且可以保存在过去状态上的更改.但这会开辟新的分支.</p>
<p>回到现实</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="literal">master</span></div></pre></td></tr></table></figure>
<h2 id="处理分支"><a href="#处理分支" class="headerlink" title="处理分支"></a>处理分支</h2><p>查看分支<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git branch</span></div></pre></td></tr></table></figure></p>
<p>建立分支<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -<span class="selector-tag">b</span> branchName</div></pre></td></tr></table></figure></p>
<p>关于建立分支,实质上是 checkout 到一个某个状态后, git 自动把你放到一个新的,未命名的分支,<br>这个分支可以用<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout -<span class="selector-tag">b</span> branchName</div></pre></td></tr></table></figure></p>
<p>进行对该分支命名.</p>
<p>回到主分支<br><figure class="highlight crmsh"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git checkout <span class="literal">master</span></div></pre></td></tr></table></figure></p>
<p>切换到某分支<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="attribute">git checkout someBranch</span></div></pre></td></tr></table></figure></p>
<p>使用分支工作</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">git checkout -b draft  <span class="comment"># 建立分支</span></div><div class="line"><span class="built_in">do</span> some work <span class="keyword">in</span> <span class="keyword">the</span> branch: draft <span class="keyword">and</span> commmit  <span class="comment"># 在分支上工作</span></div><div class="line">git checkout master <span class="comment"># 回到分支 master</span></div><div class="line">git <span class="built_in">merge</span> draft <span class="comment"># 将 draft 分支所做更改合并到主分支</span></div><div class="line">git branch -d draft <span class="comment"># 不再需要这个分支</span></div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/12/25/2014-12-25-git/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-12-02 </div>
			<div class="article-title"><a href="/2014/12/02/2014-12-02-纯对象事件/" >js 纯对象事件</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<blockquote>
<p>如果给单纯的对象加入事件,怎么做?</p>
</blockquote>
<p>我想到了 jQ, addEventListener, emmit …<br>惭愧！</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> PubSub = &#123;</div><div class="line">	<span class="attr">subscribe</span>: <span class="function"><span class="keyword">function</span>(<span class="params">ev, callback</span>) </span>&#123;</div><div class="line">		<span class="comment">// 创建 _callbacks 对象,除非已有</span></div><div class="line">		<span class="keyword">var</span> calls = <span class="keyword">this</span>._callbacks || (<span class="keyword">this</span>._callbacks = &#123;&#125;);</div><div class="line">		(<span class="keyword">this</span>._callbacks[ev] || (<span class="keyword">this</span>._callbacks[ev] = [])).push(callback);</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;,</div><div class="line">	<span class="attr">publish</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="keyword">var</span> args = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>,<span class="number">0</span>);</div><div class="line"></div><div class="line">		<span class="comment">// 拿出第一个参数, 因为第一个参数用于事件名称</span></div><div class="line">		<span class="keyword">var</span> ev = args.shift();</div><div class="line"></div><div class="line">		<span class="keyword">var</span> list, calls, i, lst;</div><div class="line">		<span class="comment">// 不存在该事件,则返回</span></div><div class="line">		<span class="keyword">if</span> (!(calls = <span class="keyword">this</span>._callbacks)) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">		<span class="keyword">if</span> (!(list = <span class="keyword">this</span>._callbacks[ev])) <span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line"></div><div class="line">		<span class="keyword">for</span>( i = <span class="number">0</span>, lst = list.length; i &lt; lst; i++ ) &#123;</div><div class="line">			list[i].apply(<span class="keyword">this</span>, args);</div><div class="line">		&#125;</div><div class="line">		<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">	&#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/12/02/2014-12-02-纯对象事件/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-16 </div>
			<div class="article-title"><a href="/2014/11/16/2014-11-16-deferred/" >jQueryDeferred对象</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>deferred对象代表了将要完成的某种操作，并提供了一些方法，帮助用户使用。它是jQuery对Promises接口的实现。jQuery的所有Ajax操作函数，默认返回的就是一个deferred对象。</p>
<p>简单说，Promises是异步操作的通用接口，扮演代理人（proxy）的角色，将异步操作包装成具有同步操作特性的特殊对象。异步操作的典型例子就是Ajax操作、网页动画、web worker等等。</p>
<p>由于JavaScript单线程的特点，如果某个操作耗时很长，其他操作就必需排队等待。为了避免整个程序失去响应，通常的解决方法是将那些排在后面的操作，写成“回调函数”（callback）的形式。这样做虽然可以解决问题，但是有一些显著缺点：</p>
<ul>
<li>回调函数往往写成函数参数的形式，形成所谓的“持续传递风格”（即参数就是下一步操作，Continuation-passing style），导致函数的输入和输出非常混乱，整个程序的可阅读性差；</li>
<li>回调函数往往只能指定一个，如果有多个操作，就需要改写回调函数。</li>
<li>除了正常的报错机制，错误还可能通过回调函数的形式返回，增加了除错和调试的难度。</li>
<li>正常的函数输入和输出可以区分得很清楚，回调函数使得函数的输出不再重要。</li>
</ul>
<p>Promises就是为了解决这些问题而提出的，它的主要目的就是取代回调函数，成为非同步操作的解决方案。它的核心思想就是让非同步操作返回一个对象，其他操作都针对这个对象来完成。比如，假定ajax操作返回一个Promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> promise = get(<span class="string">'http://www.example.com'</span>);</div></pre></td></tr></table></figure>
<p>然后，Promise对象有一个then方法，可以用来指定回调函数。一旦非同步操作完成，就调用指定的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(content)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>可以将上面两段代码合并起来，这样程序的流程看得更清楚。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">get(<span class="string">'http://www.example.com'</span>).then(<span class="function"><span class="keyword">function</span> (<span class="params">content</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(content)</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在1.5版之前，jQuery的Ajax操作采用回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>:<span class="string">"/echo/json/"</span>,</div><div class="line">    <span class="attr">success</span>: <span class="function"><span class="keyword">function</span>(<span class="params">response</span>)</span></div><div class="line">    &#123;</div><div class="line">       <span class="built_in">console</span>.info(response.name);</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>1.5版之后，Ajax操作直接返回Promise对象，这意味着可以用then方法指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">    <span class="attr">url</span>: <span class="string">"/echo/json/"</span>,</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.info(response.name);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="deferred对象的方法"><a href="#deferred对象的方法" class="headerlink" title="deferred对象的方法"></a>deferred对象的方法</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><strong>（1）生成deferred对象</strong></p>
<p>第一步是通过$.Deferred()方法，生成一个deferred对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> deferred = $.Deferred();</div></pre></td></tr></table></figure>
<p><strong>（2）deferred对象的状态</strong></p>
<p>deferred对象有三种状态。</p>
<ul>
<li>pending：表示操作还没有完成。</li>
<li>resolved：表示操作成功。</li>
<li>rejected：表示操作失败。</li>
</ul>
<p>state方法用来返回deferred对象当前状态。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.Deferred().state() <span class="comment">// 'pending'</span></div><div class="line">$.Deferred().resolve().state() <span class="comment">// 'resolved'</span></div><div class="line">$.Deferred().reject().state() <span class="comment">// 'rejected'</span></div></pre></td></tr></table></figure>
<p><strong>（3）改变状态的方法</strong></p>
<p>resolve方法将deferred对象的状态从pending改为resolved，reject方法则将状态从pending改为rejected。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> deferred = $.Deferred();</div><div class="line"></div><div class="line">deferred.resolve(<span class="string">"hello world"</span>);</div></pre></td></tr></table></figure>
<p>resolve方法的参数，用来传递给回调函数。</p>
<p><strong>（4）绑定回调函数</strong></p>
<p>deferred对象在状态改变时，会触发回调函数。 </p>
<p>done方法指定状态变为resolved（操作成功）时的回调函数；fail方法指定状态变为rejected（操作失败）时的回调函数；always方法指定，不管状态变为resolved或rejected，都会触发的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> deferred = $.Deferred();</div><div class="line"></div><div class="line">deferred.done(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">   <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).resolve(<span class="string">'hello world'</span>);</div><div class="line"><span class="comment">// hello world</span></div></pre></td></tr></table></figure>
<p>上述三种方法都返回的原有的deferred对象，因此可以采用链式写法，在后面再链接别的方法（包括done和fail在内）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.Deferred().done(f1).fail(f2).always(f3);</div></pre></td></tr></table></figure>
<h3 id="notify-和-progress"><a href="#notify-和-progress" class="headerlink" title="notify() 和 progress()"></a>notify() 和 progress()</h3><p>progress()用来指定一个回调函数，当调用notify()方法时，该回调函数将执行。它的用意是提供一个接口，使得在非同步操作执行过程中，可以执行某些操作，比如定期返回进度条的进度。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> userProgress = $.Deferred();</div><div class="line">   <span class="keyword">var</span> $profileFields = $(<span class="string">"input"</span>);</div><div class="line">   <span class="keyword">var</span> totalFields = $profileFields.length</div><div class="line">       </div><div class="line">   userProgress.progress(<span class="function"><span class="keyword">function</span> (<span class="params">filledFields</span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> pctComplete = (filledFields/totalFields)*<span class="number">100</span>;</div><div class="line">       $(<span class="string">"#progress"</span>).html(pctComplete.toFixed(<span class="number">0</span>));</div><div class="line">   &#125;); </div><div class="line"></div><div class="line">   userProgress.done(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       $(<span class="string">"#thanks"</span>).html(<span class="string">"Thanks for completing your profile!"</span>).show();</div><div class="line">   &#125;);</div><div class="line">   </div><div class="line">   $(<span class="string">"input"</span>).on(<span class="string">"change"</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">       <span class="keyword">var</span> filledFields = $profileFields.filter(<span class="string">"[value!='']"</span>).length;</div><div class="line">       userProgress.notify(filledFields);</div><div class="line">       <span class="keyword">if</span> (filledFields == totalFields) &#123;</div><div class="line">           userProgress.resolve();</div><div class="line">       &#125;</div><div class="line">   &#125;);</div></pre></td></tr></table></figure>
<h3 id="then方法"><a href="#then方法" class="headerlink" title="then方法"></a>then方法</h3><p><strong>（1）概述</strong></p>
<p>then方法的作用也是指定回调函数，它可以接受三个参数，也就是三个回调函数。第一个参数是resolve时调用的回调函数（相当于done方法），第二个参数是reject时调用的回调函数（相当于fail方法），第三个参数是progress()方法调用的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">deferred.then( doneFilter [, failFilter ] [, progressFilter ] )</div></pre></td></tr></table></figure>
<p><strong>（2）返回值</strong></p>
<p>在jQuery 1.8之前，then()只是.done().fail()写法的语法糖，两种写法是等价的。在jQuery 1.8之后，then()返回一个新的promise对象，而done()返回的是原有的deferred对象。如果then()指定的回调函数有返回值，该返回值会作为参数，传入后面的回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> defer = jQuery.Deferred();</div><div class="line"></div><div class="line">defer.done(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;</div><div class="line">            <span class="keyword">return</span> a * b;</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a * b;</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"> a, b </span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> a * b;</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> result </span>) </span>&#123;</div><div class="line">            <span class="built_in">console</span>.log(<span class="string">"result = "</span> + result);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">defer.resolve( <span class="number">2</span>, <span class="number">3</span> );</div></pre></td></tr></table></figure>
<p>在jQuery 1.8版本之前，上面代码的结果是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">result = <span class="number">2</span> </div><div class="line">result = <span class="number">2</span> </div><div class="line">result = <span class="number">2</span></div></pre></td></tr></table></figure>
<p>在jQuery 1.8版本之后，返回结果是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">result = <span class="number">2</span> </div><div class="line">result = <span class="number">6</span> </div><div class="line">result = <span class="literal">NaN</span></div></pre></td></tr></table></figure>
<p>这一点需要特别引起注意。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.ajax( url1, &#123; <span class="attr">dataType</span>: <span class="string">"json"</span> &#125; )</div><div class="line">.then(<span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">    <span class="keyword">return</span> $.ajax( url2, &#123; <span class="attr">data</span>: &#123; <span class="attr">user</span>: data.userId &#125; &#125; );</div><div class="line">&#125;).done(<span class="function"><span class="keyword">function</span>(<span class="params"> data </span>) </span>&#123;</div><div class="line">  <span class="comment">// 从url2获取的数据</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码最后那个done方法，处理的是从url2获取的数据，而不是从url1获取的数据。</p>
<p><strong>（3）对返回值的修改</strong></p>
<p>利用then()会修改返回值这个特性，我们可以在调用其他回调函数之前，对前一步操作返回的值进行处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> post = $.post(<span class="string">"/echo/json/"</span>)</div><div class="line">	.then(<span class="function"><span class="keyword">function</span>(<span class="params">p</span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> p.firstName;</div><div class="line">	&#125;);</div><div class="line"></div><div class="line">post.done(<span class="function"><span class="keyword">function</span>(<span class="params">r</span>)</span>&#123; <span class="built_in">console</span>.log(r); &#125;);</div></pre></td></tr></table></figure>
<p>上面代码先使用then()方法，从返回的数据中取出所需要的字段（firstName），所以后面的操作就可以只处理这个字段了。</p>
<p>有时，Ajax操作返回json字符串里面有一个error属性，表示发生错误。这个时候，传统的方法只能是通过done()来判断是否发生错误。通过then()方法，可以让deferred对象调用fail()方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> myDeferred = $.post(<span class="string">'/echo/json/'</span>, &#123;<span class="attr">json</span>:<span class="built_in">JSON</span>.stringify(&#123;<span class="string">'error'</span>:<span class="literal">true</span>&#125;)&#125;)</div><div class="line">    .then(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">            <span class="keyword">if</span> (response.error) &#123;</div><div class="line">                <span class="keyword">return</span> $.Deferred().reject(response);</div><div class="line">            &#125;</div><div class="line">            <span class="keyword">return</span> response;</div><div class="line">        &#125;,<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">            <span class="keyword">return</span> $.Deferred().reject(&#123;<span class="attr">error</span>:<span class="literal">true</span>&#125;);</div><div class="line">        &#125;</div><div class="line">    );</div><div class="line"></div><div class="line">myDeferred.done(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">        $(<span class="string">"#status"</span>).html(<span class="string">"Success!"</span>);</div><div class="line">    &#125;).fail(<span class="function"><span class="keyword">function</span> (<span class="params">response</span>) </span>&#123;</div><div class="line">        $(<span class="string">"#status"</span>).html(<span class="string">"An error occurred"</span>);</div><div class="line">    &#125;);</div></pre></td></tr></table></figure>
<p>上面代码中，不管是通信出错，或者服务器返回一个错误，都会调用reject方法，返回一个新的deferred对象，状态为rejected，因此就会触发fail方法指定的回调函数。</p>
<p>关于error的处理，jQuery的deferred对象与其他实现Promises规范的函数库有一个重大不同。就是说，如果deferred对象执行过程中，抛出一个非Promises对象的错误，那么将不会被后继的then方法指定的rejected回调函数捕获，而会一直传播到应用程序层面。为了代码行为与Promises规范保持一致，建议出错时，总是使用reject方法返回错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">d = $.Deferred()  </div><div class="line">d.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;  </div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'err'</span>)</div><div class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'fail'</span>)</div><div class="line">&#125;)</div><div class="line">d.resolve()</div><div class="line"><span class="comment">// Error: err</span></div></pre></td></tr></table></figure>
<p>上面代码中，then的回调函数抛出一个错误，按照Promises规范，应该被fail方法的回调函数捕获，但是jQuery的部署是上升到应用程序的层面。</p>
<p><strong>（4）回调函数的返回值</strong></p>
<p>如果回调函数返回deferred对象，则then方法的返回值将是对应这个返回值的promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> d1 = $.Deferred();</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = $.when(<span class="string">'Hello'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">h</span>)</span>&#123;  </div><div class="line">  <span class="keyword">return</span> $.when(h,d1);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">promise.done(<span class="function"><span class="keyword">function</span> (<span class="params">s1,s2</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(s1);</div><div class="line">	<span class="built_in">console</span>.log(s2);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">d1.resolve(<span class="string">'World'</span>)</div><div class="line"><span class="comment">// Hello</span></div><div class="line"><span class="comment">// World</span></div></pre></td></tr></table></figure>
<p>上面代码中，done方法的回调函数，正常情况下只能接受一个参数。但是由于then方法的回调函数，返回一个when方法生成的deferred对象，导致它可以接受两个参数。</p>
<h3 id="pipe方法"><a href="#pipe方法" class="headerlink" title="pipe方法"></a>pipe方法</h3><p>pipe方法接受一个函数作为参数，表示在调用then方法、done方法、fail方法、always方法指定的回调函数之前，先运行pipe方法指定的回调函数。它通常用来对服务器返回的数据做初步处理。</p>
<h3 id="与Promise-A-规格的差异"><a href="#与Promise-A-规格的差异" class="headerlink" title="与Promise A+规格的差异"></a>与Promise A+规格的差异</h3><p>Promise事实上的标准是社区提出的Promise A+规格，jQuery的实现并不完全符合Promise A+，主要是对错误的处理。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> promise2 = promise1.then(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">"boom!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码在回调函数中抛出一个错误，Promise A+规定此时Promise实例的状态变为reject，该错误被下一个catch方法指定的回调函数捕获。但是，jQuery的Deferred对象此时不会改变状态，亦不会触发回调函数，该错误一般情况下会被window.onerror捕获。换句话说，在Deferred对象中，总是必须使用reject方法来改变状态。</p>
<h2 id="promise对象"><a href="#promise对象" class="headerlink" title="promise对象"></a>promise对象</h2><p><strong>（1）概念</strong></p>
<p>一般情况下，从外部改变第三方完成的异步操作（比如Ajax）的状态是毫无意义的。为了防止用户这样做，可以在deferred对象的基础上，返回一个针对它的promise对象。</p>
<p>简单说，promise对象就是不能改变状态的deferred对象，也就是deferred的只读版。或者更通俗地理解成，promise是一个对将要完成的任务的承诺，排除了其他人破坏这个承诺的可能性，只能等待承诺方给出结果。</p>
<p>你可以通过promise对象，为原始的deferred对象添加回调函数，查询它的状态，但是无法改变它的状态，也就是说<strong>promise对象不允许你调用resolve和reject方法</strong>。</p>
<p><strong>（2）生成promise对象</strong></p>
<p>deferred对象的promise方法，用来生成对应的promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPromise</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> $.Deferred().promise();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">    getPromise().resolve(<span class="string">"a"</span>);</div><div class="line">&#125; <span class="keyword">catch</span>(err) &#123;</div><div class="line">    <span class="built_in">console</span>.log(err);</div><div class="line">&#125;</div><div class="line"><span class="comment">// TypeError</span></div></pre></td></tr></table></figure>
<p>上面代码对promise对象，调用resolve方法，结果报错。</p>
<p>jQuery的ajax() 方法返回的就是一个promise对象。此外，Animation类操作也可以使用promise方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$(<span class="string">'body'</span>).toggle(<span class="string">'blinds'</span>).promise().then(</div><div class="line">  <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    $(<span class="string">'body'</span>).toggle(<span class="string">'blinds'</span>)</div><div class="line">  &#125;</div><div class="line">)</div></pre></td></tr></table></figure>
<h2 id="辅助方法"><a href="#辅助方法" class="headerlink" title="辅助方法"></a>辅助方法</h2><p>deferred对象还有一系列辅助方法，使它更方便使用。</p>
<h3 id="when-方法"><a href="#when-方法" class="headerlink" title="$.when()方法"></a>$.when()方法</h3><p>$.when()接受多个deferred对象作为参数，当它们全部运行成功后，才调用resolved状态的回调函数，但只要其中有一个失败，就调用rejected状态的回调函数。它相当于将多个非同步操作，合并成一个。实质上，when方法为多个deferred对象，返回一个单一的promise对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.when(</div><div class="line">    $.ajax( <span class="string">"/main.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/modules.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/lists.php"</span> )</div><div class="line">).then(successFunc, failureFunc);</div></pre></td></tr></table></figure>
<p>上面代码表示，要等到三个ajax操作都结束以后，才执行then方法指定的回调函数。</p>
<p>when方法里面要执行多少个操作，回调函数就有多少个参数，对应前面每一个操作的返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.when(</div><div class="line">    $.ajax( <span class="string">"/main.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/modules.php"</span> ),</div><div class="line">    $.ajax( <span class="string">"/lists.php"</span> )</div><div class="line">).then(<span class="function"><span class="keyword">function</span> (<span class="params">resp1, resp2, resp3</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(resp1);</div><div class="line">	<span class="built_in">console</span>.log(resp2);</div><div class="line">	<span class="built_in">console</span>.log(resp3);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>上面代码的回调函数有三个参数，resp1、resp2和resp3，依次对应前面三个ajax操作的返回结果。</p>
<p>如果when方法的参数不是deferred或promise对象，则直接作为回调函数的参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">d = $.Deferred()  </div><div class="line">$.when(d, <span class="string">'World'</span>).done(<span class="function"><span class="keyword">function</span> (<span class="params">s1, s2</span>)</span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(s1);</div><div class="line">	<span class="built_in">console</span>.log(s2);</div><div class="line">&#125;)</div><div class="line"></div><div class="line">d.resolve(<span class="string">'Hello'</span>) </div><div class="line"><span class="comment">// Hello </span></div><div class="line"><span class="comment">// World</span></div></pre></td></tr></table></figure>
<p>上面代码中，when的第二个参数是一个字符串，则直接作为回调函数的第二个参数。</p>
<p>此外，如果when方法的参数都不是deferred或promise对象，那么when方法的回调函数将立即运行。</p>
<h2 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h2><h3 id="wait方法"><a href="#wait方法" class="headerlink" title="wait方法"></a>wait方法</h3><p>我们可以用deferred对象写一个wait方法，表示等待多少毫秒后再执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.wait = <span class="function"><span class="keyword">function</span>(<span class="params">time</span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> $.Deferred(<span class="function"><span class="keyword">function</span>(<span class="params">dfd</span>) </span>&#123;</div><div class="line">    setTimeout(dfd.resolve, time);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">$.wait(<span class="number">5000</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Hello from the future!"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="改写setTimeout"><a href="#改写setTimeout" class="headerlink" title="改写setTimeout"></a>改写setTimeout</h3><p>在上面的wait方法的基础上，还可以改写setTimeout方法，让其返回一个deferred对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomethingLater</span>(<span class="params">fn, time</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    dfd.resolve(fn());</div><div class="line">  &#125;, time || <span class="number">0</span>);</div><div class="line">  <span class="keyword">return</span> dfd.promise();</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> promise = doSomethingLater(<span class="function"><span class="keyword">function</span> (<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log( <span class="string">'已经延迟执行'</span> );</div><div class="line">&#125;, <span class="number">100</span>);</div></pre></td></tr></table></figure>
<h3 id="自定义操作使用deferred接口"><a href="#自定义操作使用deferred接口" class="headerlink" title="自定义操作使用deferred接口"></a>自定义操作使用deferred接口</h3><p>我们可以利用deferred接口，使得任意操作都可以用done()和fail()指定回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Twitter = &#123;</div><div class="line">  <span class="attr">search</span>:<span class="function"><span class="keyword">function</span>(<span class="params">query</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">    $.ajax(&#123;</div><div class="line">     <span class="attr">url</span>:<span class="string">"http://search.twitter.com/search.json"</span>,</div><div class="line">     <span class="attr">data</span>:&#123;<span class="attr">q</span>:query&#125;,</div><div class="line">     <span class="attr">dataType</span>:<span class="string">'jsonp'</span>,</div><div class="line">     <span class="attr">success</span>:dfd.resolve</div><div class="line">    &#125;);</div><div class="line">    <span class="keyword">return</span> dfd.promise();</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>使用方法如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">Twitter.search(<span class="string">'javaScript'</span>).then(<span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  alert(data.results[<span class="number">0</span>].text);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>deferred对象的另一个优势是可以附加多个回调函数。下面的例子使用了上面所改写的setTimeout函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">arg</span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> dfd = $.Deferred();</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    dfd.reject(<span class="string">"Sorry, something went wrong."</span>);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> dfd;</div><div class="line">&#125;</div><div class="line"></div><div class="line">doSomething(<span class="string">"uh oh"</span>).done(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">"Won't happen, we're erroring here!"</span>);</div><div class="line">&#125;).fail(<span class="function"><span class="keyword">function</span>(<span class="params">message</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(message);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Matt Baker, <a href="http://eng.wealthfront.com/2012/12/jquerydeferred-is-most-important-client.html" target="_blank" rel="external">jQuery.Deferred is the most important client-side tool you have</a></li>
<li><a href="http://www.intridea.com/blog/2011/2/8/fun-with-jquery-deferred" target="_blank" rel="external">Fun With jQuery Deferred</a></li>
<li>Bryan Klimt, <a href="http://blog.parse.com/2013/01/29/whats-so-great-about-javascript-promises/" target="_blank" rel="external">What’s so great about JavaScript Promises?</a></li>
<li>José F. Romaniello, <a href="http://joseoncode.com/2011/09/26/a-walkthrough-jquery-deferred-and-promise/" target="_blank" rel="external">Understanding JQuery.Deferred and Promise</a></li>
<li>Julian Aubourg, Addy Osmani, <a href="http://msdn.microsoft.com/en-us/magazine/gg723713.aspx" target="_blank" rel="external">Creating Responsive Applications Using jQuery Deferred and Promises</a></li>
<li>Graham Jenson, <a href="http://maori.geek.nz/post/i_promise_this_will_be_short" target="_blank" rel="external">JQuery Promises and Deferreds: I promise this will be short</a></li>
<li>Q module document, <a href="https://github.com/kriskowal/q/wiki/Coming-from-jQuery" target="_blank" rel="external">Coming from jQuery</a> </li>
</ul>

	
	</div>
  <a type="button" href="/2014/11/16/2014-11-16-deferred/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-12 </div>
			<div class="article-title"><a href="/2014/11/12/2014-11-22-无交互行为内容的闪烁FUBC/" >无交互行为内容的闪烁FOUC</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>#无交互行为内容的闪烁FOUC</p>
<p>今天了解了一个新的名词叫做 FOUC 浏览器样式闪烁，之前也听说过一些类似的东西，比如样式突变等等，但这东西竟然有学名的。</p>
<p>###什么是FOUC?</p>
<p>如果使用import方法对CSS进行导入,会导致某些页面在 Windows 下的<code>IE</code>出现一些奇怪的现象:以无样式显示页面内容的瞬间闪烁,这种现象称之为文档样式短暂失效(Flash of Unstyled Content),简称为FOUC。</p>
<p>出现的原因大致为：</p>
<ol>
<li>使用import方法导入样式表。</li>
<li>将样式表放在页面底部</li>
<li>有几个样式表，放在html结构的不同位置。</li>
</ol>
<p>其实原理很清楚：当样式表晚于结构性html加载，当加载到此样式表时，页面将停止之前的渲染。此样式表被下载和解析后，将重新渲染页面，也就出现了短暂的花屏现象。</p>
<p>一般的解决方法：<strong>使用LINK标签将样式表放在文档head中</strong>。</p>
<h3 id="在其他技术中，同样存在-FOUC："><a href="#在其他技术中，同样存在-FOUC：" class="headerlink" title="在其他技术中，同样存在 FOUC："></a>在其他技术中，同样存在 FOUC：</h3><h4 id="requirejs"><a href="#requirejs" class="headerlink" title="requirejs"></a>requirejs</h4><p>使用 requireJs,加载器来加载页面时，也会出现一部分没有交互行为的内容快速闪过（FOUC），比如在JavaScript 执行之前会有一部分无样式的页面原始内容闪烁一下。如果不依赖JavaScript 来修改初始页面的样式， 问题其实并不严重。但如果依赖JavaScript 来操作样式，则需要将样式提取出来放入初 始化CSS 之中，比如隐藏一些元素或展示一个加载指示器，提示页面正在加载中。 </p>
<h4 id="polymer"><a href="#polymer" class="headerlink" title="polymer"></a>polymer</h4><p>在 custom elements 更新 之前可能显示错乱。 为了缓解 FOUC 问题, Polymer 提供了一个 polyfill 解决方案，配合 :unresolved 伪类 使用。 对于简单的 app，你可以为 body 添加 unresolved 属性。这将在页面初始化时隐藏页面直到所有的 elements 被更新才显示。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">unresolved</span>&gt;</span></div><div class="line"><span class="comment">&lt;!-- 或者,更具体些 --&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">unresolved</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></div></pre></td></tr></table></figure>

	
	</div>
  <a type="button" href="/2014/11/12/2014-11-22-无交互行为内容的闪烁FUBC/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-12 </div>
			<div class="article-title"><a href="/2014/11/12/2014-11-12-CSS代码段笔记/" >CSS代码段笔记</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h3 id="内层div充满外层div"><a href="#内层div充满外层div" class="headerlink" title="内层div充满外层div"></a>内层div充满外层div</h3><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>1.内层div充满外层div<span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="css"></span></div><div class="line">	<span class="selector-tag">inner_div</span>&#123;</div><div class="line">		<span class="attribute">position</span>: absolute;</div><div class="line">		<span class="attribute">top</span>:<span class="number">0</span>;</div><div class="line">		<span class="attribute">right</span>:<span class="number">0</span>;</div><div class="line">		<span class="attribute">bottom</span>:<span class="number">0</span>;</div><div class="line">		<span class="attribute">left</span>:<span class="number">0</span>;</div><div class="line">	&#125;</div><div class="line"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></div></pre></td></tr></table></figure>
<p>如果单纯充满外层，淡出 with/height: 100%也可做到，但是这其它元素就不可以覆盖到上面了，absolute 不在正常的瀑布流中.</p>
<h3 id="渐变的用法"><a href="#渐变的用法" class="headerlink" title="渐变的用法"></a>渐变的用法</h3><pre><code>linear-gradient {color startAt,color endAt},{color startAt,color endAt},{...}, 


&lt;style&gt;
    elemnt{
        background-image:-webkit-linear-gradient(
            45deg, 
            red 25%,
            transparent 25%, transparent 50%,
            red 50%, red 75%,
            transparent 75%, transparent 100%
            );
    }
&lt;/style&gt;
</code></pre><h3 id="图片防下载，在图片上做个遮罩"><a href="#图片防下载，在图片上做个遮罩" class="headerlink" title="图片防下载，在图片上做个遮罩"></a>图片防下载，在图片上做个遮罩</h3><pre><code>&lt;div&gt;
    &lt;div class=&apos;cover&apos;&gt;&lt;/div&gt;
    &lt;img&gt;&lt;/img&gt;
&lt;/div&gt;

&lt;style&gt;
    .cover {
        position: absolute;
        width:100%;
        height:100%;

        /*
        positon:absolute;
        top:0;
        right:0;
        bottom:0;
        left:0;
        */
    }    
&lt;/style&gt;
</code></pre><h3 id="div-style"><a href="#div-style" class="headerlink" title="div.style"></a>div.style</h3><pre><code>&lt;script&gt;
    div.style =&gt; CSSStyleDeclaration{}
    div.classList =&gt; [&quot;a&quot;,&quot;b&quot;];  //元素应用的class
    div.className =&gt; &quot;a b&quot;;      //应用的类名
&lt;/script&gt;
</code></pre><h3 id="border-的颜色"><a href="#border-的颜色" class="headerlink" title="border 的颜色"></a>border 的颜色</h3><pre><code>&lt;p&gt;
    如果没有在 border 属性中指定，则默认采用前景色，
    同字体一个颜色，字体默认黑色，
    可通过color指定，所以这个color也适用于border;
&lt;/p&gt;
</code></pre><h3 id="clip-图片剪切显示"><a href="#clip-图片剪切显示" class="headerlink" title="clip 图片剪切显示"></a>clip 图片剪切显示</h3><pre><code>&lt;style&gt;
img {
    position: absolute; left:526px;
    clip: rect(40px  200px  150px  30px);
    /* non-standard syntax, but supported by all major browsers including Firefox and IE */
}
&lt;/style&gt;
</code></pre><p>window.innerHeight 有用的显示区域，视口的高度<br>window.outerHeight 浏览器窗口的高度，包括标题栏菜单栏等等。</p>
<h2 id="transition"><a href="#transition" class="headerlink" title="transition"></a>transition</h2><pre><code>过度 transition: 
        transition-property: 指定过度的 css 属性,
        transition-duration: 指定完成过渡所需时间,
        transition-timing-function: 指定过渡函数,
        transition-delay: 指定过渡开始出现的延迟时间
</code></pre><h2 id="结构性伪类"><a href="#结构性伪类" class="headerlink" title="结构性伪类"></a>结构性伪类</h2><p>:nth-of-type 和 :nth-child 类似, 不同的是它只计算父元素中指定的某种类型的子元素.</p>
<pre><code>ul&gt;li:nth-of-type(3) {
    background-color: orange;
}
</code></pre>
	
	</div>
  <a type="button" href="/2014/11/12/2014-11-12-CSS代码段笔记/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-12 </div>
			<div class="article-title"><a href="/2014/11/12/2014-11-12-Hammerjs的使用/" >移动端技术积累</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<p>先占位置。</p>
<h2 id="基本使用方法"><a href="#基本使用方法" class="headerlink" title="基本使用方法"></a>基本使用方法</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></div><div class="line"><span class="keyword">var</span> hammer = <span class="keyword">new</span> Hammer(<span class="built_in">document</span>.getElementById(<span class="string">"container"</span>));</div><div class="line"></div><div class="line">hammer.on(<span class="string">'pan'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"pan"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hammer.on(<span class="string">'tap'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"tap-单击"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hammer.on(<span class="string">"doubletap"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="string">"onhold-双击"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">hammer.on(<span class="string">'press'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">ev</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="string">"press-长按"</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"></div><div class="line"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></div></pre></td></tr></table></figure>
<p>hammer.js <a href="http://hammerjs.github.io/" target="_blank" rel="external">跨中断的事件解决方案</a></p>

	
	</div>
  <a type="button" href="/2014/11/12/2014-11-12-Hammerjs的使用/#more" class="btn btn-default more">阅读此文</a>
</div>

		
			
	
	<!-- display as entry -->	
		<h3 class="title">
			<div class="date"> 2014-11-10 </div>
			<div class="article-title"><a href="/2014/11/10/2014-11-10-regexp-inaction/" >regexp-head-first</a></div>						
		</h3>
	


			<div class="entry">
  <div class="row">
	
	
		<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>正则表达式（regular expression）是一种表达文本模式的方法，常常用作按照“给定模式”匹配文本的工具，比如给定一个Email地址的模式，然后用来确定一个字符串是否为Email地址。JavaScript的正则表达式体系是参照Perl 5建立的。</p>
<p>新建正则表达式有两种方法。一种是使用字面量，以斜杠表示开始和结束。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/</span>;</div></pre></td></tr></table></figure>
<p>另一种是使用RegExp构造函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"xyz"</span>);</div></pre></td></tr></table></figure>
<p>上面两种写法是等价的，都建立了一个内容为xyz的正则表达式对象。</p>
<p>RegExp构造函数还可以接受第二个参数，表示修饰符（详细解释见下文）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"xyz"</span>, <span class="string">"i"</span>);</div><div class="line"><span class="comment">// 等价于</span></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</div></pre></td></tr></table></figure>
<p>这两种写法在运行时有一个细微的区别。采用字面量的写法，正则对象在代码载入时（即编译时）生成；采用构造函数的方法，正则对象在代码运行时生成。考虑到书写的便利和直观，实际应用中，基本上都采用字面量的写法。</p>
<p>正则对象生成以后，有两种使用方式：</p>
<ul>
<li><p>使用正则对象本身的方法，将字符串作为参数，比如regex.test(string)。</p>
</li>
<li><p>使用字符串对象的方法，将正则对象作为参数，比如string.match(regex)。</p>
</li>
</ul>
<p>下面逐一介绍这两种使用方式。</p>
<h2 id="正则对象的属性和方法"><a href="#正则对象的属性和方法" class="headerlink" title="正则对象的属性和方法"></a>正则对象的属性和方法</h2><h3 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h3><p>正则对象的属性主要如下：</p>
<ul>
<li><p><strong>ignoreCase</strong>：返回一个布尔值，表示是否设置了i修饰符，该属性只读。</p>
</li>
<li><p><strong>global</strong>：返回一个布尔值，表示是否设置了g修饰符，该属性只读。</p>
</li>
<li><p><strong>lastIndex</strong>：返回下一次开始搜索的位置。该属性可读写，但是只在设置了g修饰符时有意义。</p>
</li>
<li><p><strong>source</strong>：返回正则表达式的字符串形式（不包括反斜杠），该属性只读。</p>
</li>
<li><p><strong>multiline</strong>：返回一个布尔值，表示是否设置了m修饰符，该属性只读。</p>
</li>
</ul>
<p>下面是属性应用的实例。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/abc/igm</span>;</div><div class="line"></div><div class="line">r.ignoreCase <span class="comment">// true</span></div><div class="line">r.global <span class="comment">// true</span></div><div class="line">r.multiline <span class="comment">// true</span></div><div class="line">r.lastIndex <span class="comment">// 0</span></div><div class="line">r.source <span class="comment">// "abc"</span></div></pre></td></tr></table></figure>
<h3 id="test方法"><a href="#test方法" class="headerlink" title="test方法"></a>test方法</h3><p>test方法返回布尔值，用来验证字符串是否符合某个模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/cat/.test(<span class="string">'cats and dogs'</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码验证参数字符串之中是否包含cat，结果返回true。</p>
<p>如果正则表达式带有g修饰符，则每一次test方法都从上一次结束的位置开始向后匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/x/g</span>;</div><div class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</div><div class="line"></div><div class="line">r.lastIndex <span class="comment">// 0</span></div><div class="line">r.test(s) <span class="comment">// true</span></div><div class="line"></div><div class="line">r.lastIndex <span class="comment">// 2</span></div><div class="line">r.test(s) <span class="comment">// true</span></div><div class="line"></div><div class="line">r.lastIndex <span class="comment">// 4</span></div><div class="line">r.test(s) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>上面代码的正则对象使用了g修饰符，表示要记录搜索位置。接着，三次使用test方法，每一次开始搜索的位置都是上一次匹配的后一个位置。</p>
<p>如果正则模式是一个空字符串，则匹配所有字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">""</span>).test(<span class="string">"abc"</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="exec方法"><a href="#exec方法" class="headerlink" title="exec方法"></a>exec方法</h3><p>exec方法返回匹配结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</div><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</div><div class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</div><div class="line"></div><div class="line">r1.exec(s) <span class="comment">// ["x"]</span></div><div class="line">r2.exec(s) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>上面代码表示，如果匹配成功，exec方法返回一个数组，里面是匹配结果。如果匹配失败，返回null。</p>
<p>如果正则表示式包含圆括号，则返回的数组会包括多个元素。其中，第一个元素是整个匹配成功的结果，后面的元素就是圆括号对应的匹配成功的组，也就是说第二个元素就对应第一个括号，第三个元素对应第二个括号，以此类推。整个返回数组的length属性等于匹配成功的组数+1。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/_(x)/</span>;</div><div class="line"></div><div class="line">r.exec(s) <span class="comment">// ["_x", "x"]</span></div></pre></td></tr></table></figure>
<p>上面代码的exex方法，返回一个数组。第一个元素是整个匹配的结果，第二个元素是圆括号匹配的结果。</p>
<p>exec方法的返回数组还包含以下两个属性：</p>
<ul>
<li><strong>input</strong>：整个原字符串。</li>
<li><strong>index</strong>：整个模式匹配成功的开始位置。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> arr = regex.exec(<span class="string">"_abbba_aba_"</span>);</div><div class="line"></div><div class="line">arr</div><div class="line"><span class="comment">// ["abbba", "bbb"]</span></div><div class="line"></div><div class="line">arr.index</div><div class="line"><span class="comment">// 1</span></div><div class="line"></div><div class="line">arr.input</div><div class="line"><span class="comment">// "_abbba_aba_"</span></div></pre></td></tr></table></figure>
<p>上面代码中的index属性等于1，是因为从原字符串的第二个位置开始匹配成功。</p>
<p>如果正则表达式加上g修饰符，则可以使用多次exec方法，下一次搜索的位置从上一次匹配成功结束的位置开始。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> a1 = r.exec(<span class="string">"_abbba_aba_"</span>);</div><div class="line">a1 <span class="comment">// ["abbba", "bbb"]</span></div><div class="line">a1.index <span class="comment">// 1</span></div><div class="line">r.lastIndex <span class="comment">// 6</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a2 = r.exec(<span class="string">"_abbba_aba_"</span>);</div><div class="line">a2 <span class="comment">// ["aba", "b"]</span></div><div class="line">a2.index <span class="comment">// 7</span></div><div class="line">r.lastIndex <span class="comment">// 10</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a3 = r.exec(<span class="string">"_abbba_aba_"</span>);</div><div class="line">a3 <span class="comment">// null</span></div><div class="line">a3.index <span class="comment">// TypeError: Cannot read property 'index' of null</span></div><div class="line">r.lastIndex <span class="comment">// 0</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a4 = r.exec(<span class="string">"_abbba_aba_"</span>);</div><div class="line">a4 <span class="comment">// ["abbba", "bbb"]</span></div><div class="line">a4.index <span class="comment">// 1</span></div><div class="line">r.lastIndex <span class="comment">// 6</span></div></pre></td></tr></table></figure>
<p>上面代码连续用了四次exec方法，前三次都是从上一次匹配结束的位置向后匹配。当第三次匹配结束以后，整个字符串已经到达尾部，正则对象的lastIndex属性重置为0，意味着第四次匹配将从头开始。</p>
<p>利用g修饰符允许多次匹配的特点，可以用一个循环完成全部匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/a(b+)a/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">"_abbba_aba_"</span>;</div><div class="line"></div><div class="line"><span class="keyword">while</span>(<span class="literal">true</span>) &#123;</div><div class="line">	<span class="keyword">var</span> match = r.exec(s);</div><div class="line">	<span class="keyword">if</span> (!match) <span class="keyword">break</span>;</div><div class="line">	<span class="built_in">console</span>.log(match[<span class="number">1</span>]);</div><div class="line">&#125;</div><div class="line"><span class="comment">// bbb</span></div><div class="line"><span class="comment">// b</span></div></pre></td></tr></table></figure>
<p>如果正则对象是一个空字符串，则exec方法会匹配成功，但返回的也是空字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> r1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">""</span>);</div><div class="line"><span class="keyword">var</span> a1 = r1.exec(<span class="string">"abc"</span>);</div><div class="line">a1 <span class="comment">// [""]</span></div><div class="line">a1.index <span class="comment">// 0</span></div><div class="line">r1.lastIndex <span class="comment">// 0 </span></div><div class="line"></div><div class="line"><span class="keyword">var</span> r2 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"()"</span>);</div><div class="line"><span class="keyword">var</span> a2 = r2.exec(<span class="string">"abc"</span>);</div><div class="line">a2 <span class="comment">// ["", ""]</span></div><div class="line">a2.index <span class="comment">// 0</span></div><div class="line">r2.lastIndex <span class="comment">// 0</span></div></pre></td></tr></table></figure>
<h2 id="字符串对象的方法"><a href="#字符串对象的方法" class="headerlink" title="字符串对象的方法"></a>字符串对象的方法</h2><p>字符串对象的方法之中，有4种与正则对象有关。</p>
<ul>
<li><p><strong>match</strong>：返回匹配的子字符串。</p>
</li>
<li><p><strong>search</strong>：按照给定的正则规则进行搜索。</p>
</li>
<li><p><strong>replace</strong>：按照给定的正则规则进行替换。</p>
</li>
<li><p><strong>split</strong>：按照给定规则进行字符串分割。</p>
</li>
</ul>
<p>下面逐一介绍。</p>
<h3 id="match方法"><a href="#match方法" class="headerlink" title="match方法"></a>match方法</h3><p>match方法对字符串进行正则匹配，返回匹配结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">'_x_x'</span>;</div><div class="line"><span class="keyword">var</span> r1 = <span class="regexp">/x/</span>;</div><div class="line"><span class="keyword">var</span> r2 = <span class="regexp">/y/</span>;</div><div class="line"></div><div class="line">s.match(r1) <span class="comment">// ["x"]</span></div><div class="line">s.match(r2) <span class="comment">// null</span></div></pre></td></tr></table></figure>
<p>从上面代码可以看到，字符串的match方法与正则对象的exec方法非常类似：匹配成功返回一个数组，匹配失败返回null。</p>
<p>如果正则表达式带有g修饰符，则该方法与正则对象的exec方法行为不同，会返回所有匹配成功的结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> s = <span class="string">"abba"</span>;</div><div class="line"><span class="keyword">var</span> r = <span class="regexp">/a/g</span>;</div><div class="line"></div><div class="line">s.match(r) <span class="comment">// ["a", "a"]</span></div><div class="line">r.exec(s) <span class="comment">// ["a"]</span></div></pre></td></tr></table></figure>
<h3 id="search方法"><a href="#search方法" class="headerlink" title="search方法"></a>search方法</h3><p>search方法返回第一个满足条件的匹配结果在整个字符串中的位置。如果没有任何匹配，则返回-1。该方法会忽略g参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">'_x_x'</span>.search(<span class="regexp">/x/</span>)</div><div class="line"><span class="comment">// 1</span></div></pre></td></tr></table></figure>
<h3 id="replace方法"><a href="#replace方法" class="headerlink" title="replace方法"></a>replace方法</h3><p>replace方法可以替换匹配的值，它接受两个参数，第一个是搜索模式，第二个是替换的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">str.replace(search, replacement)</div></pre></td></tr></table></figure>
<p>搜索模式如果不加g修饰符，就替换第一个匹配成功的值，否则替换所有匹配成功的值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"aaa"</span>.replace(<span class="string">"a"</span>, <span class="string">"b"</span>)</div><div class="line"><span class="comment">// "baa"</span></div><div class="line"></div><div class="line"><span class="string">"aaa"</span>.replace(<span class="regexp">/a/</span>, <span class="string">"b"</span>)</div><div class="line"><span class="comment">// "baa"</span></div><div class="line"></div><div class="line"><span class="string">"aaa"</span>.replace(<span class="regexp">/a/g</span>, <span class="string">"b"</span>)</div><div class="line"><span class="comment">// "bbb"</span></div><div class="line"></div><div class="line"><span class="comment">// 去掉两边的空格</span></div><div class="line"><span class="string">"   a    b   "</span>.replace(<span class="regexp">/(?:^\s+)|(?:[\s]+$)/g</span>,<span class="string">''</span>)</div><div class="line"><span class="comment">// "a   b"</span></div></pre></td></tr></table></figure>
<p>replace方法的第二个参数可以使用美元符号$，(从匹配子串中提取替换使用的原料)用来指代所替换的内容。</p>
<blockquote>
<p>青出于蓝而胜于蓝</p>
</blockquote>
<figure class="highlight haml"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">-<span class="ruby"> $&amp; 指代匹配的子字符串。</span></div><div class="line">-<span class="ruby"> $` 指代匹配结果前面的文本。</span></div><div class="line">-<span class="ruby"> $' 指代匹配结果后面的文本。</span></div><div class="line">-<span class="ruby"> $n 指代匹配成功的第n组内容，n从<span class="number">1</span>开始计数。</span></div><div class="line">-<span class="ruby"> $$ 指代美元符号$。</span></div></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="string">"abc"</span>.replace(<span class="string">"b"</span>, <span class="string">"[$`-$&amp;-$']"</span>)</div><div class="line"><span class="comment">// "a[a-b-c]c"</span></div><div class="line"></div><div class="line"><span class="string">"hello world"</span>.replace(<span class="regexp">/(\w+)\s(\w+)/</span>,<span class="string">"$2 $1"</span>)</div><div class="line"><span class="comment">// "world hello"</span></div></pre></td></tr></table></figure>
<p>第二个参数还可以是一个函数，将匹配内容替换为函数返回值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"3 and 5"</span>.replace(<span class="regexp">/[0-9]+/g</span>, <span class="function"><span class="keyword">function</span>(<span class="params">match</span>)</span>&#123;</div><div class="line">			<span class="keyword">return</span> <span class="number">2</span> * match; &#125;)</div><div class="line"><span class="comment">// "6 and 10"</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> a = <span class="string">"The quick brown fox jumped over the lazy dog."</span>;</div><div class="line"><span class="keyword">var</span> pattern = <span class="regexp">/quick|brown|lazy/ig</span>;</div><div class="line">a.replace( pattern, <span class="function"><span class="keyword">function</span> <span class="title">replacer</span>(<span class="params">match</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> match.toUpperCase();</div><div class="line">&#125; );</div><div class="line"><span class="comment">// The QUICK BROWN fox jumped over the LAZY dog.</span></div></pre></td></tr></table></figure>
<p>作为replace方法第二个参数的替换函数，可以接受多个参数。它的第一个参数是捕捉到的内容，第二个参数是捕捉到的组匹配（有多少个组匹配，就有多少个对应的参数）。此外，最后还可以添加两个参数，倒数第二个参数是捕捉到的内容在整个字符串中的位置（比如从第五个位置开始），最后一个参数是原字符串。下面是一个网页模板替换的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> prices = &#123;</div><div class="line">    <span class="string">"pr_1"</span>: <span class="string">"$1.99"</span>,</div><div class="line">    <span class="string">"pr_2"</span>: <span class="string">"$9.99"</span>,</div><div class="line">    <span class="string">"pr_3"</span>: <span class="string">"$5.00"</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> template = <span class="string">".."</span>; <span class="comment">// some ecommerce page template</span></div><div class="line"></div><div class="line">template.replace(</div><div class="line">    <span class="regexp">/(&lt;span id=")(.*?)("&gt;)(&lt;\/span&gt;)/g</span>,</div><div class="line">    <span class="function"><span class="keyword">function</span>(<span class="params">match,$<span class="number">1</span>,$<span class="number">2</span>,$<span class="number">3</span>,$<span class="number">4</span></span>)</span>&#123;</div><div class="line">        <span class="keyword">return</span> $<span class="number">1</span> + $<span class="number">2</span> + $<span class="number">3</span> + prices[$<span class="number">2</span>] + $<span class="number">4</span>;</div><div class="line">    &#125;</div><div class="line">);</div></pre></td></tr></table></figure>
<p>上面代码的捕捉模式中，有四个括号，所以会产生四个组匹配，在匹配函数中用$1到$4表示。匹配函数的作用是将价格插入模板中。</p>
<h3 id="split方法"><a href="#split方法" class="headerlink" title="split方法"></a>split方法</h3><p>split方法按照正则规则分割字符串，返回一个由分割后的各个部分组成的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">str.split(separator, [limit])</div></pre></td></tr></table></figure>
<p>该方法接受两个参数，第一个参数是分隔规则，第二个参数是返回数组的最大成员数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="string">','</span>) </div><div class="line"><span class="comment">// [ 'a', '  b', 'c', ' d' ]</span></div><div class="line"></div><div class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>)</div><div class="line"><span class="comment">// [ 'a', 'b', 'c', 'd' ]</span></div><div class="line"></div><div class="line"><span class="string">'a,  b,c, d'</span>.split(<span class="regexp">/, */</span>, <span class="number">2</span>)</div><div class="line">[ <span class="string">'a'</span>, <span class="string">'b'</span> ]</div></pre></td></tr></table></figure>
<p>上面代码使用正则表达式，去除了子字符串的逗号前面的空格。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"aaa*a*"</span>.split(<span class="regexp">/a*/</span>)</div><div class="line"><span class="comment">// [ '', '*', '*' ]</span></div><div class="line"></div><div class="line"><span class="string">"aaa**a*"</span>.split(<span class="regexp">/a*/</span>)</div><div class="line"><span class="comment">// ["", "*", "*", "*"]</span></div></pre></td></tr></table></figure>
<p>上面代码的分割规则是出现0次或多次的a，所以第一个分隔符是“aaa”，第二个分割符是“a”，将整个字符串分成三个部分。出现0次的a，意味着只要没有a就可以分割，实际上就是按字符分割。</p>
<p>如果正则表达式带有括号，则括号匹配的部分也会作为数组成员返回。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">"aaa*a*"</span>.split(<span class="regexp">/(a*)/</span>)</div><div class="line"><span class="comment">// [ '', 'aaa', '*', 'a', '*' ]</span></div></pre></td></tr></table></figure>
<p>上面代码的正则表达式使用了括号，第一个组匹配是“aaa”，第二个组匹配是“a”，它们都作为数组成员返回。</p>
<p>下面是另一个组匹配的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="string">'a,  b  ,  '</span>.split(<span class="regexp">/(,)/</span>)</div><div class="line"><span class="comment">// ["a", ",", "  b  ", ",", "  "]</span></div><div class="line"></div><div class="line"><span class="string">'a,  b  ,  '</span>.split(<span class="regexp">/ *(,) */</span>)</div><div class="line"><span class="comment">// ["a", ",", "b", ",", ""]</span></div></pre></td></tr></table></figure>
<h2 id="匹配规则"><a href="#匹配规则" class="headerlink" title="匹配规则"></a>匹配规则</h2><p>正则表达式对字符串的匹配有很复杂的规则。下面一一介绍这些规则。</p>
<h3 id="字面量字符和元字符"><a href="#字面量字符和元字符" class="headerlink" title="字面量字符和元字符"></a>字面量字符和元字符</h3><p>大部分字符在正则表达式中，就是字面的含义，比如/a/匹配a，/b/匹配b。它们都叫做“字面量字符”（literal characters）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/dog/.test(<span class="string">"old dog"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中正则表达式的dog，就是字面量字符，所以/dog/匹配old dog，因为它就表示d、o、g三个字母连在一起。</p>
<p>除了字面量字符以外，还有一部分字符有特殊含义，不代表字面的意思。它们叫做“元字符”（metacharacters），主要有以下几个。</p>
<p><strong>（1）点字符（.)</strong></p>
<p>点字符（.）匹配除回车（\r）、换行(\n) 、行分隔符（\u2028）和段分隔符（\u2029）以外的所有字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/c.t/</div></pre></td></tr></table></figure>
<p>上面代码中的c.t匹配c和t之间包含任意一个字符的情况，只要这三个字符在同一行，比如cat、c2t、c-t等等，但是不匹配coot。</p>
<p><strong>（2）位置字符</strong></p>
<p>位置字符用来提示字符所处的位置，主要有两个字符。</p>
<ul>
<li>^ 表示字符串的起首。</li>
<li>$ 表示字符串的行尾。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/^test/.test(<span class="string">"test123"</span>) <span class="comment">// true</span></div><div class="line">/test$/.test(<span class="string">"new test"</span>) <span class="comment">// true</span></div><div class="line">/^test$/.test(<span class="string">"test"</span>) <span class="comment">// true</span></div><div class="line">/^test$/.test(<span class="string">"test test"</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><strong>（3）选择符（|）</strong></p>
<p>竖线符号（|）在正则表达式中表示“或关系”（OR），即 cat|dog 表示匹配cat或dog。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/<span class="number">11</span>|<span class="number">22</span>/.test(<span class="string">"911"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="字符类"><a href="#字符类" class="headerlink" title="字符类"></a>字符类</h3><p>字符类（class）表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内，比如[xyz] 表示x、y、z之中任选一个匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/[abc]/.test(<span class="string">"hello world"</span>) <span class="comment">// false</span></div><div class="line">/[abc]/.test(<span class="string">"apple"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，字符串hello world不包含abc这三个字母中的任一个，而字符串apple包含字母a。</p>
<p>有两个字符在字符类中有特殊含义。</p>
<p><strong>（1）脱字符（&#94;）</strong></p>
<p>如果方括号内的第一个字符是[&#94;]，则表示除了字符类之中的字符，其他字符都可以匹配。比如，[&#94;xyz] 表示除了x、y、z之外都可以匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/[^abc]/.test(<span class="string">"hello world"</span>) <span class="comment">// true</span></div><div class="line">/[^abc]/.test(<span class="string">"bbc"</span>) <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>上面代码表示，字符串hello world不包含字母abc中的任一个，所以返回true；字符串bbc不包含abc以外的字母，所以返回false。</p>
<blockquote>
<p>注意，脱字符只有在字符类的第一个位置才有特殊含义，否则就是字面含义。</p>
</blockquote>
<p><strong>（2）连字符（-）</strong></p>
<p>某些情况下，对于连续序列的字符，连字符（-）用来提供简写形式，表示字符的连续范围。比如，[abc]可以写成[a-c]，[0123456789]可以写成[0-9]，同理[A-Z]表示26个大写字母。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/a-z/.test(<span class="string">"b"</span>) <span class="comment">// false</span></div><div class="line">/[a-z]/.test(<span class="string">"b"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码中，当连字号（dash）不出现在方括号之中，就不具备简写的作用，只代表字面的含义，所以不匹配字符b。只有当连字号用在方括号之中，才表示连续的字符序列。</p>
<p>以下都是合法的字符类简写形式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">[<span class="number">0</span><span class="number">-9.</span>,]</div><div class="line">[<span class="number">0</span><span class="number">-9</span>a-fA-F]</div><div class="line">[a-zA-Z0<span class="number">-9</span>-]</div><div class="line">[<span class="number">1</span><span class="number">-31</span>]</div></pre></td></tr></table></figure>
<p>上面代码中最后一个字符类[1-31]，不代表1到31，只代表1到3。</p>
<blockquote>
<p>注意，字符类的连字符必须在头尾两个字符中间，才有特殊含义，否则就是字面含义。</p>
</blockquote>
<h3 id="重复类"><a href="#重复类" class="headerlink" title="重复类"></a>重复类</h3><p>{} 表示模式的重复次数。{n}表示重复n次，{n,}表示至少重复n次，{n,m}表示重复不少于n次，不多于m次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/lo&#123;<span class="number">2</span>&#125;k/.test(<span class="string">"look"</span>) <span class="comment">// true</span></div><div class="line">/lo&#123;<span class="number">2</span>,<span class="number">5</span>&#125;k/.test(<span class="string">"looook"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="量词符"><a href="#量词符" class="headerlink" title="量词符"></a>量词符</h3><ul>
<li>? 表示某个模式出现1次或0次，等同于{0, 1}。</li>
<li>* 表示某个模式出现0次或多次，等同于 {0,}。</li>
<li>+ 表示某个模式出现1次或多次，等同于 {1,}。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/t?est/.test(<span class="string">"test"</span>) <span class="comment">// true</span></div><div class="line">/t?est/.test(<span class="string">"est"</span>) <span class="comment">// true</span></div><div class="line"></div><div class="line">/t+est/.test(<span class="string">"test"</span>) <span class="comment">// true</span></div><div class="line">/t+est/.test(<span class="string">"ttest"</span>) <span class="comment">// true</span></div><div class="line">/t+est/.test(<span class="string">"tttest"</span>) <span class="comment">// true</span></div><div class="line">/t+est/.test(<span class="string">"est"</span>) <span class="comment">// false</span></div><div class="line"></div><div class="line">/t*est/.test(<span class="string">"test"</span>) <span class="comment">// true</span></div><div class="line">/t*est/.test(<span class="string">"ttest"</span>) <span class="comment">// true</span></div><div class="line">/t*est/.test(<span class="string">"tttest"</span>) <span class="comment">// true</span></div><div class="line">/t*est/.test(<span class="string">"est"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>以上三个量词符，默认情况下的匹配规则都是贪婪模式，即最大可能匹配，直到下一个字符不满足匹配规则为止。比如，对于字符串“aaa”来说，/a+/将会匹配“aaa”，而不会匹配“aa”。为了将贪婪模式改为非贪婪模式，可以在量词符后面加一个问号，/a+?/将会只匹配“a”。</p>
<h3 id="转义符"><a href="#转义符" class="headerlink" title="转义符"></a>转义符</h3><p>正则表达式中那些有特殊含义的字符，如果要匹配它们本身，就需要在它们前面要加上反斜杠。比如要匹配加号，就要写成\+。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/<span class="number">1</span>+<span class="number">1</span>/.test(<span class="string">"1+1"</span>)</div><div class="line"><span class="comment">// false</span></div><div class="line"></div><div class="line">/<span class="number">1</span>\+<span class="number">1</span>/.test(<span class="string">"1+1"</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>正则模式中，需要用斜杠转义的，一共有12个字符：&#94;、.、[、$、(、)、|、*、+、?、{和 \。需要特别注意的是，如果使用RegExp方法生成正则对象，转义需要使用两个斜杠，因为字符串内部会先转义一次。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"1\+1"</span>)).test(<span class="string">"1+1"</span>) <span class="comment">// false</span></div><div class="line">(<span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"1\\+1"</span>)).test(<span class="string">"1+1"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<h3 id="修饰符"><a href="#修饰符" class="headerlink" title="修饰符"></a>修饰符</h3><p>修饰符（modifier）表示模式的附加规则，放在正则模式的最尾部。</p>
<p><strong>（1）g修饰符</strong></p>
<p>默认情况下，第一次匹配成功后，正则对象就停止向下匹配了。g修饰符表示全局匹配（global），加上它以后，正则对象将匹配全部符合条件的结果，主要用于搜索和替换。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">'abba'</span>;</div><div class="line"></div><div class="line">regex.test(str); <span class="comment">// true</span></div><div class="line">regex.test(str); <span class="comment">// true</span></div><div class="line">regex.test(str); <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码连续做了三次匹配，都返回true。它的含义是如果不加g修饰符，每次匹配时都是从字符串头部开始匹配。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/b/g</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> str = <span class="string">'abba'</span>;</div><div class="line"></div><div class="line">regex.test(str); <span class="comment">// true</span></div><div class="line">regex.test(str); <span class="comment">// true</span></div><div class="line">regex.test(str); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>上面代码中，因为字符串“abba”只有两个“b”，所以前两次匹配结果为true，第三次匹配结果为false。它的含义是加上g修饰符以后，每次匹配都是从上一次匹配成功处开始往后匹配。</p>
<p><strong>（2）i修饰符</strong></p>
<p>默认情况下，正则对象区分字母的大小写，加上i修饰符以后表示忽略大小写（ignorecase）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/abc/.test(<span class="string">"ABC"</span>) <span class="comment">// false</span></div><div class="line">/abc/i.test(<span class="string">"ABC"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面代码表示，加了i修饰符以后，不考虑大小写，所以模式abc匹配字符串ABC。</p>
<p><strong>（3）m修饰符</strong></p>
<p>有时，字符串的头部或尾部可能会有换行符。默认情况下，正则对象会将换行符当作算入字符串的开头或结尾。m修饰符表示多行模式（multiline），加上它以后，正则对象会忽略字符串头部或尾部的换行符，即&#94;和$会忽略换行符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/world$/.test(<span class="string">"hello world\n"</span>) <span class="comment">// false</span></div><div class="line">/world$/m.test(<span class="string">"hello world\n"</span>) <span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面的代码中，字符串结尾处有一个换行符。如果不加m修饰符，匹配不成功，因为字符串的结尾不是world；加上以后，换行符被省略，匹配成功。</p>
<p>修饰符可以多个一起使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> regex = <span class="regexp">/test/ig</span>;</div></pre></td></tr></table></figure>
<h3 id="预定义模式"><a href="#预定义模式" class="headerlink" title="预定义模式"></a>预定义模式</h3><p>预定义模式指的是某些常见模式的简写方式。</p>
<ul>
<li>\d 匹配0-9之间的任一数字，相当于[0-9]。</li>
<li>\D 匹配所有0-9以外的字符，相当于[^0-9]。</li>
<li>\w 匹配任意的字母、数字和下划线，相当于[A-Za-z0-9_]。</li>
<li>\W 除所有字母、数字和下划线以外的字符，相当于/[&#94;A-Za-z0-9_]/ 。</li>
<li>\s 匹配空格（包括制表符、空格符、断行符等），相等于[\t\r\n\v\f]。</li>
<li>\S 匹配非空格的字符，相当于[&#94;\t\r\n\v\f]。</li>
<li>\b 匹配词的边界。</li>
<li>\B 匹配非词边界，即在词的内部。</li>
</ul>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/\s\w*/.exec("hello world") // [" world"]</div><div class="line"></div><div class="line">/\bworld/.test("hello world") // true</div><div class="line">/\bworld/.test("hello-world") // true</div><div class="line">/\bworld/.test("helloworld") // false</div><div class="line"></div><div class="line">/\Bworld/.test("hello-world") // false</div><div class="line">/\Bworld/.test("helloworld") // true</div></pre></td></tr></table></figure>
<h3 id="特殊字符"><a href="#特殊字符" class="headerlink" title="特殊字符"></a>特殊字符</h3><p>正则对象对一些不能打印的特殊字符，提供了表达形式。</p>
<ul>
<li>\cX 表示 Ctrl-X</li>
<li>[\b] 匹配退格键(U+0008)，不要与\b混淆。</li>
<li>\n 匹配换行键。</li>
<li>\r 匹配回车键。</li>
<li>\t 匹配制表符tab（U+0009）。</li>
<li>\v 匹配垂直制表符（U+000B）。</li>
<li>\f 匹配换页符（U+000C）。</li>
<li>\0 匹配null字符（U+0000）。</li>
<li>\xhh 匹配一个以两位十六进制数表示的字符。</li>
<li>\uhhhh 匹配一个以四位十六进制数表示的unicode字符。</li>
</ul>
<h3 id="组匹配"><a href="#组匹配" class="headerlink" title="组匹配"></a>组匹配</h3><p><strong>（1）概述</strong></p>
<p>正则表达式的括号表示分组匹配，括号中的模式可以用来捕获分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="string">"abcabc"</span>.match(<span class="regexp">/(.)b(.)/</span>);</div><div class="line">m </div><div class="line"><span class="comment">// ["abc", "a", "c"]</span></div></pre></td></tr></table></figure>
<p>上面代码中，正则表达式/(.)b(.)/一共使用两个括号，第一个括号捕获a，第二个括号捕获c。</p>
<p>注意，使用组匹配时，不宜同时使用g修饰符，否则match方法不会捕获分组的内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="string">"abcabc"</span>.match(<span class="regexp">/(.)b(.)/g</span>);</div><div class="line">m</div><div class="line"><span class="comment">// ["abc", "abc"]</span></div></pre></td></tr></table></figure>
<p>上面代码使用带g修饰符的正则表达式，结果match方法只捕获了匹配整个表达式的部分。</p>
<p>在正则表达式内部，可以用\n引用括号匹配的内容，n是从1开始的自然数，表示对应顺序的括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"></div><div class="line">/(.)b(.)\<span class="number">1</span>b\<span class="number">2</span>/.test(<span class="string">"abcabc"</span>)</div><div class="line"><span class="comment">// true</span></div></pre></td></tr></table></figure>
<p>上面的代码中，\1表示前一个括号匹配的内容（即“a”），\2表示第二个括号匹配的内容（即“b”）。</p>
<p>组匹配非常有用，下面是一个匹配网页标签的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> tagName = <span class="regexp">/&lt;([^&gt;]+)&gt;[^&lt;]*&lt;\/\1&gt;/</span>;</div><div class="line">tagName.exec(<span class="string">"&lt;b&gt;bold&lt;/b&gt;"</span>)[<span class="number">1</span>]</div><div class="line"><span class="comment">// 'b'</span></div></pre></td></tr></table></figure>
<p><strong>（2）非捕获组</strong></p>
<p>(?:x)称为非捕获组（Non-capturing group），表示不返回该组匹配的内容，即匹配的结果中不计入这个括号。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="string">"abc"</span>.match(<span class="regexp">/(?:.)b(.)/</span>);</div><div class="line"></div><div class="line">m[<span class="number">1</span>]</div><div class="line"><span class="comment">// "c"</span></div></pre></td></tr></table></figure>
<p>上面代码中的模式，一共使用了两个括号。其中第一个括号是非捕获组，所以返回的第一个被捕获的组是第二个括号所匹配的“c”。</p>
<p>下面是用来分解网址的正则表达式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> url = <span class="regexp">/(http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</div><div class="line"></div><div class="line">url.exec(<span class="string">"http://google.com/"</span>);</div><div class="line"><span class="comment">// ["http://google.com/", "http", "google.com", "/"]</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> url = <span class="regexp">/(?:http|ftp):\/\/([^/\r\n]+)(\/[^\r\n]*)?/</span>;</div><div class="line"></div><div class="line">url.exec(<span class="string">"http://google.com/"</span>);</div><div class="line"><span class="comment">// ["http://google.com/", "google.com", "/"]</span></div></pre></td></tr></table></figure>
<p>上面的代码中，前一个正则表达式是正常匹配，第一个括号返回网络协议；后一个正则表达式是非捕获匹配，返回结果中不包括网络协议。</p>
<p><strong>（3）先行断言</strong></p>
<p>x(?=y)称为先行断言（Positive look-ahead），x只有在y前面才匹配，y不会被计入返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="string">"abc"</span>.match(<span class="regexp">/b(?=c)/</span>);</div><div class="line">m </div><div class="line"><span class="comment">// "b"</span></div></pre></td></tr></table></figure>
<p>上面的代码使用了先行断言，b在c前面所以被匹配，但是括号对应的c不会被返回。</p>
<p><strong>（4）后行断言</strong></p>
<p>x(?!y)称为后行断言（Negative look-ahead），x只有不在y前面才匹配，y不会被计入返回结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> m = <span class="string">"abd"</span>.match(<span class="regexp">/b(?!c)/</span>);</div><div class="line">m</div><div class="line"><span class="comment">// ["b"]</span></div></pre></td></tr></table></figure>
<p>上面的代码使用了后行断言，b不在c前面所以被匹配，而且括号对应的d不会被返回。</p>
<h2 id="参考链接"><a href="#参考链接" class="headerlink" title="参考链接"></a>参考链接</h2><ul>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2011/04/javascript-overview-of-regular.html" target="_blank" rel="external">JavaScript: an overview of the regular expression API</a></li>
<li>Mozilla Developer Network, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="external">Regular Expressions</a></li>
<li>Axel Rauschmayer, <a href="http://www.2ality.com/2013/08/regexp-g.html" target="_blank" rel="external">The flag /g of JavaScript’s regular expressions</a></li>
<li>Sam Hughes, <a href="http://qntm.org/files/re/re.html" target="_blank" rel="external">Learn regular expressions in about 55 minutes</a></li>
</ul>

	
	</div>
  <a type="button" href="/2014/11/10/2014-11-10-regexp-inaction/#more" class="btn btn-default more">阅读此文</a>
</div>

		

		</div>

		<!-- pagination -->
		<div>
  		<center>
		<div class="pagination">
<ul class="pagination">
	 
		
    	<li class="prev"><a href="/page/6/" class="alignleft prev"><i class="fa fa-arrow-circle-o-left"></i> 上一页</a></li>
  		

        <li><a href="/"><i class="fa fa-home"></i>Home</a></li>

		
		   <li class="next"> <a href="/page/8/" class="alignright next">下一页<i class="fa fa-arrow-circle-o-right"></i></a> </li>          
        
	
</ul>
</div>

  		</center>
		</div>

		
		
	</div> <!-- col-md-9 -->

	
		<div class="col-md-3">
	<div id="sidebar">
	
			 

		
			
	<div class="widget">
		<h4>分类</h4>
		<ul class="tag_box inline list-unstyled">
		
			<li><a href="/categories/Sports/Baseball/">Baseball<span>2</span></a></li>
		
			<li><a href="/categories/Sports/">Sports<span>2</span></a></li>
		
			<li><a href="/categories/bom/">bom<span>1</span></a></li>
		
			<li><a href="/categories/collection/">collection<span>1</span></a></li>
		
			<li><a href="/categories/css/">css<span>1</span></a></li>
		
			<li><a href="/categories/http/">http<span>1</span></a></li>
		
			<li><a href="/categories/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/categories/javascript-test/">javascript test<span>1</span></a></li>
		
			<li><a href="/categories/jquery/">jquery<span>1</span></a></li>
		
			<li><a href="/categories/library/">library<span>2</span></a></li>
		
			<li><a href="/categories/note/">note<span>1</span></a></li>
		
			<li><a href="/categories/note-vim/">note vim<span>2</span></a></li>
		
			<li><a href="/categories/tool/">tool<span>3</span></a></li>
		
		</ul>
	</div>

		
			
	<div class="widget">
		<h4>标签云</h4>
		<ul class="tag_box inline list-unstyled">		
		
			<li><a href="/tags/test/">test<span>2</span></a></li>
		
			<li><a href="/tags/mobile/">mobile<span>1</span></a></li>
		
			<li><a href="/tags/webcomponent-framework/">webcomponent,framework<span>1</span></a></li>
		
			<li><a href="/tags/webcomponent/">webcomponent<span>2</span></a></li>
		
			<li><a href="/tags/w3c/">w3c<span>1</span></a></li>
		
			<li><a href="/tags/database-linux/">database linux<span>1</span></a></li>
		
			<li><a href="/tags/mac/">mac<span>1</span></a></li>
		
			<li><a href="/tags/javascript-template/">javascript template<span>1</span></a></li>
		
			<li><a href="/tags/css/">css<span>7</span></a></li>
		
			<li><a href="/tags/Fight/">Fight<span>2</span></a></li>
		
			<li><a href="/tags/git/">git<span>5</span></a></li>
		
			<li><a href="/tags/seajs/">seajs<span>1</span></a></li>
		
			<li><a href="/tags/module/">module<span>2</span></a></li>
		
			<li><a href="/tags/jquery/">jquery<span>3</span></a></li>
		
			<li><a href="/tags/html/">html<span>2</span></a></li>
		
			<li><a href="/tags/linux/">linux<span>6</span></a></li>
		
			<li><a href="/tags/framework/">framework<span>1</span></a></li>
		
			<li><a href="/tags/html5/">html5<span>1</span></a></li>
		
			<li><a href="/tags/regexp/">regexp<span>6</span></a></li>
		
			<li><a href="/tags/demo/">demo<span>1</span></a></li>
		
		
		   <li><a href="/tags">...<span>39</span></a></li>
		 
		</ul>
	</div>


		
			
<div class="widget">
  <h4>最新文章</h4>
  <ul class="entry list-unstyled">
    
      <li>
        <a href="/2017/02/01/2012-08-03-XMLHttpRequest发送put,delete请求/" ><i class="fa fa-file-o"></i>XMLHttpRequest发送put,delete请求</a>
      </li>
    
      <li>
        <a href="/2017/02/01/设计模式简介/" ><i class="fa fa-file-o"></i></a>
      </li>
    
      <li>
        <a href="/2017/02/01/2012-08-03-页面性能的几个评测点/" ><i class="fa fa-file-o"></i>页面性能的几个评测点</a>
      </li>
    
      <li>
        <a href="/2017/02/01/脚本的第一行/" ><i class="fa fa-file-o"></i></a>
      </li>
    
      <li>
        <a href="/2017/02/01/消除函数的术语歧义/" ><i class="fa fa-file-o"></i></a>
      </li>
    
  </ul>
</div>

		
			
<div class="widget">
	<h4>链接</h4>
	<ul class="blogroll list-unstyled">
	
		<li><i class="fa fa-github"></i><a href="https://github.com/chenyakun" title="My Github repository." target="_blank"]);">My Github</a></li>
	
	</ul>
</div>


		
	</div> <!-- sidebar -->
</div> <!-- col-md-3 -->

	
	
</div> <!-- row-fluid -->
	</div>
  </div>
  <div class="container-narrow">
  <footer> <p>
  &copy; 2017 yakun.cyk
  
      with help from <a href="http://hexo.io/" target="_blank">Hexo</a> and <a href="http://getbootstrap.com/" target="_blank">Twitter Bootstrap</a>. Theme by <a href="http://github.com/wzpan/hexo-theme-freemind/">Freemind</a>.    
</p> </footer>
</div> <!-- container-narrow -->
  
  
<a id="gotop" href="#">   
  <span>▲</span> 
</a>

<script src="/js/jquery.imagesloaded.min.js"></script>
<script src="/js/gallery.js"></script>
<script src="/js/bootstrap.min.js"></script>
<script src="/js/main.js"></script>
<!-- <script src="/js/search.js"></script>  -->

<!-- 
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css" media="screen" type="text/css">
<script src="/fancybox/jquery.fancybox.pack.js"></script>
<script type="text/javascript">
(function($){
  $('.fancybox').fancybox();
})(jQuery);
</script>
 -->

<!-- 
   <script type="text/javascript">      
     var search_path = "search.xml";
	 if (search_path.length == 0) {
	 	search_path = "search.xml";
	 }
	 var path = "/" + search_path;
     searchFunc(path, 'local-search-input', 'local-search-result');
   </script>
 -->

<div class="cb-search-tool" style="position: fixed; top: 0px ; bottom: 0px; left: 0px; right:  0px;
        opacity: 0.95; background-color: #111111; z-index: 9999; display: none;">

    <input type="text" class="cb-search-content" id="cb-search-content" style="position: fixed; top: 60px" placeholder="文章标题 日期 标签" />

    <div style="position: fixed; top: 16px; right: 16px;">
        <img src="/search/img/cb-close.png"  id="cb-close-btn"/>
    </div>
</div>

<!-- <div style="position: fixed; right: 16px; bottom: 20px;">
    <img src="/search/img/cb-search.png"  id="cb-search-btn"  title="双击ctrl试一下"/>
</div> -->

<link rel="stylesheet" href="/search/css/cb-search.css">
<script src="/search/js/bootstrap3-typeahead.min.js"></script>
<script src="/search/js/cb-search.js"></script>

</body>
   </html>
